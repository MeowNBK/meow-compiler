import * as CodeGenerator from "./codeGenerator.meow";
import * as Io from "io";
import * as Json from "json";
import * as System from "system";
// import * as Meta from "meta";
import { makeCacheFile } from "./utils/makeCacheFile.meow";
import { BytecodeStringifier } from "./bytecodeStringifier.meow";
import { Lexer } from "../frontend/lexer.meow";
import { Parser } from "../frontend/parser.meow";
import { Preprocessor } from "../frontend/preprocessor.meow";

fn _getDirectoryPath(fullPath) {
    let filename = Io.getFileName(fullPath);
    if (filename.length >= fullPath.length) return "";
    return fullPath.slice(0, fullPath.length - filename.length);
}

fn _isAbsolutePath(path) {
    if (path.length == 0) return false;

    if (path[0] == "/" || path[0] == "\\") return true;

    if (path.length >= 3 && path[1] == ":") {
        let driveLetter = path[0];
        if ((driveLetter >= "a" && driveLetter <= "z") || (driveLetter >= "A" && driveLetter <= "Z")) {
            if (path[2] == "/" || path[2] == "\\") return true;
        }
    }
    return false;
}

fn _findExportedNames(ast) {
    let names = [];
    if (!ast || !ast.body) return names;
    for (stmt in ast.body) {
        if (stmt.type == "ExportStatement" && stmt.declaration) {
            if (stmt.declaration.name && stmt.declaration.name.name) {
                // L·∫•y t√™n t·ª´ `export class Name`, `export function Name`, `export let Name`
                names.push(stmt.declaration.name.name);
            }
        }
    }
    return names;
}


export class Compiler {
    fn init(isNoCache, options) {
        this.compiledModules = {};
        this.isNoCache = isNoCache;
        this.dependencyGraph = {};
        this.reverseGraph = {};
        this.options = options || {};
    }

    fn compileProject(entryPath) {
        let initialDir = ".";
        let entryCache = this._compileFile(entryPath, initialDir);
        if (this.options.bundle) {
            return this._createBundle(entryPath);
        }
        if (this.options.out) {
            Io.copyFile(entryCache, this.options.out);
            // print("‚úÖ Vi·∫øt output v√†o: " + this.options.out);
            return Io.getAbsolutePath(this.options.out);
        }
        return entryCache;
    }

    fn _compileFile(sourcePath, importerDir) {
        let absolutePath = this._resolvePath(sourcePath, importerDir);

        if (this.compiledModules[absolutePath]) return this.compiledModules[absolutePath];

        let cachePath = makeCacheFile(absolutePath, this.options.buildDir || "build");
        let metaPath = cachePath + ".meta";

        if (this._isCacheValid(absolutePath, cachePath)) {
            let metaText = Io.read(metaPath);
            if (!metaText) {
                print("[ERROR] Kh√¥ng th·ªÉ ƒë·ªçc meta file: " + metaPath);
                System.exit(1);
            }
            let meta = Json.parse(metaText);
            this.dependencyGraph[absolutePath] = meta.imports || [];

            for (imp in this.dependencyGraph[absolutePath]) {
                if (!this.reverseGraph[imp]) this.reverseGraph[imp] = {};
                this.reverseGraph[imp][absolutePath] = true;
            }

            this.compiledModules[absolutePath] = Io.getAbsolutePath(cachePath);
            // print("‚ôªÔ∏è ƒê√£ d√πng l·∫°i cache cho: " + absolutePath);
            return Io.getAbsolutePath(cachePath);
        }

        if (!Io.fileExists(absolutePath)) {
            print("[ERROR] File ngu·ªìn kh√¥ng t·ªìn t·∫°i: " + absolutePath);
            System.exit(1);
        }

        let source = Io.read(absolutePath);
        if (source == null) {
            print("[ERROR] Kh√¥ng th·ªÉ ƒë·ªçc file ngu·ªìn: " + absolutePath);
            System.exit(1);
        }

        // let filename = Io.getFileName(absolutePath);
        let preprocessor = new Preprocessor();
        let processedSource = preprocessor.process(source, absolutePath);

        let lexer = new Lexer(processedSource, absolutePath);
        let tokens = lexer.tokenize();
        let parser = new Parser(tokens);
        let ast = parser.parseProgram();
        if (!ast) {
            print("[ERROR] Meta.compile tr·∫£ v·ªÅ null/undefined cho: " + absolutePath);
            System.exit(1);
        }

        let sourceDir = _getDirectoryPath(absolutePath);
        let imports = this._extractImportsFromAST(ast, sourceDir);

        for (imp in imports) {
            this._compileFile(imp, sourceDir);
            if (!this.reverseGraph[imp]) this.reverseGraph[imp] = {};
            this.reverseGraph[imp][absolutePath] = true;
        }

        let generator = CodeGenerator.CodeGenerator(ast, this, absolutePath);
        let protos = generator.compile();

        // if (!Io.fileExists("tokens")) {
        //     Io.createDir("tokens");
        // }

        // if (!Io.fileExists("asts")) {
        //     Io.createDir("asts");
        // }
        // if (!Io.fileExists("protos")) {
        //     Io.createDir("protos");
        // }

        // Io.write("tokens/" + Io.getFileStem(absolutePath) + ".json", str(Json.stringify(tokens)));
        // Io.write("asts/" + Io.getFileStem(absolutePath) + ".json", str(Json.stringify(ast)));
        // Io.write("protos/" + Io.getFileStem(absolutePath) + ".json", str(Json.stringify(protos)));

        let stringifier = BytecodeStringifier();
        let bytecodeText = stringifier.stringify(protos);

        Io.write(cachePath, bytecodeText);

        let metaOut = { imports: imports, srcTime: Io.getFileTimestamp(absolutePath), srcSize: Io.getFileSize(absolutePath) };
        metaOut.importTimes = {};
        metaOut.importSizes = {};
        for (imp in imports) {
            metaOut.importTimes[imp] = Io.getFileTimestamp(imp);
            metaOut.importSizes[imp] = Io.getFileSize(imp);
        }
        Io.write(metaPath, Json.stringify(metaOut));

        this.dependencyGraph[absolutePath] = imports;
        this.compiledModules[absolutePath] = Io.getAbsolutePath(cachePath);

        // print("‚úÖ Bi√™n d·ªãch xong, t·∫°o file cache m·ªõi: " + cachePath);

        let dependents = this._gatherDependents(absolutePath, null);
        for (d in dependents) {
            if (!this.compiledModules[d]) {
                let dd = _getDirectoryPath(d);
                this._compileFile(d, dd);
            }
        }

        return Io.getAbsolutePath(cachePath);
    }

    fn _resolvePath(p, importerDir) {
        // 0) absolute -> tr·∫£ lu√¥n
        if (_isAbsolutePath(p)) return Io.getAbsolutePath(p);

        // Chu·∫©n ho√° importerDir th√†nh absolute (n·∫øu c√≥)
        let absImporter = null;
        if (importerDir && importerDir.length > 0) {
            absImporter = Io.getAbsolutePath(importerDir);
        }

        // X√°c ƒë·ªãnh xem import c√≥ ph·∫£i l√† explicit-relative (./ or ../)
        let isExplicitRelative = false;
        if (p.startsWith("./") || p.startsWith("../")) isExplicitRelative = true;

        // Build candidate list:
        let candidates = [];

        // 1) n·∫øu import d·∫°ng ./... ho·∫∑c ../... th√¨ ∆∞u ti√™n importerDir
        if (isExplicitRelative && absImporter) {
            candidates.push(absImporter + "/" + p);
        }

        // 2) includePaths t·ª´ options (n·∫øu c√≥)
        if (this && this.options && this.options.includePaths) {
            for (ip in this.options.includePaths) {
                candidates.push(Io.getAbsolutePath(ip) + "/" + p);
            }
        }

        // 3) cwd
        candidates.push(Io.getAbsolutePath(".") + "/" + p);

        // 4) fallback: original p (module name / maybe absolute after Io.getAbsolutePath)
        candidates.push(p);

        // Th·ª≠ each candidate; n·∫øu kh√¥ng t√¨m, th·ª≠ th√™m .meow
        let tryWithExt = !p.endsWith(".meow");
        for (cand in candidates) {
            let absCand = Io.getAbsolutePath(cand);
            if (Io.fileExists(absCand)) return absCand;
            if (tryWithExt) {
                let absExt = Io.getAbsolutePath(cand + ".meow");
                if (Io.fileExists(absExt)) return absExt;
            }
        }

        // cu·ªëi c√πng: n·∫øu import l√† explicit-relative th√¨ tr·∫£ path relativized importerDir/p
        if (isExplicitRelative && absImporter) return Io.getAbsolutePath(absImporter + "/" + p);

        // fallback cu·ªëi c√πng
        if (absImporter && !isExplicitRelative) return Io.getAbsolutePath(absImporter + "/" + p);
        return Io.getAbsolutePath(p);
    }


    fn _extractImportsFromAST(ast, sourceDir) {
        let imports = [];
        if (!ast || !ast.body) return imports;
        for (stmt in ast.body) {
            if (stmt.type == "ImportStatement") {
                let dependencyPath = stmt.path.value;
                if (dependencyPath.endsWith(".meow")) {
                    imports.push(this._resolvePath(dependencyPath, sourceDir));
                }
            }
        }
        return imports;
    }

    fn _gatherDependents(absSource, accum) {
        if (!accum) accum = {};
        let direct = this.reverseGraph[absSource];
        if (!direct) return accum;
        for (d in direct) {
            if (!accum[d]) {
                accum[d] = true;
                this._gatherDependents(d, accum);
            }
        }
        return accum;
    }

    fn _isCacheValid(absSourcePath, cachePath) {
        // 1. Gi·ªØ l·∫°i t·∫•t c·∫£ c√°c b∆∞·ªõc ki·ªÉm tra ban ƒë·∫ßu (file c√≥ t·ªìn t·∫°i kh√¥ng, v.v...)
        if (this.isNoCache || this.options.force) return false;
        if (!Io.fileExists(cachePath)) return false;

        let metaPath = cachePath + ".meta";
        if (!Io.fileExists(metaPath)) return false;

        let metaText = Io.read(metaPath);
        if (!metaText) return false;

        let meta = Json.parse(metaText);
        if (!meta) return false;

        if (!Io.fileExists(absSourcePath)) return false;
        let srcTime = Io.getFileTimestamp(absSourcePath);
        let srcSize = Io.getFileSize(absSourcePath);
        
        // 2. V·∫´n ki·ªÉm tra ch√≠nh file ngu·ªìn, n·∫øu n√≥ thay ƒë·ªïi th√¨ ch·∫Øc ch·∫Øn kh√¥ng h·ª£p l·ªá
        if (meta.srcTime != srcTime || meta.srcSize != srcSize) return false;

        // 3. --- N√ÇNG C·∫§P LOGIC KI·ªÇM TRA ƒê·ªÜ QUY ---
        // Thay v√¨ ch·ªâ check timestamp, ta check xem cache c·ªßa file con c√≥ h·ª£p l·ªá kh√¥ng
        for (imp in meta.imports) {
            // T·ª± t√≠nh ra ƒë∆∞·ªùng d·∫´n cache c·ªßa file dependency
            let impCachePath = makeCacheFile(imp, this.options.buildDir || "build");
            
            // ƒê·ªÜ QUY TH·∫¶N S·∫¶U ƒê√ÇY R·ªíI!
            // N·∫øu cache c·ªßa th·∫±ng con kh√¥ng h·ª£p l·ªá th√¨ cache c·ªßa m√¨nh c≈©ng v·ª©t ƒëi!
            if (!this._isCacheValid(imp, impCachePath)) {
                return false;
            }
        }

        // 4. N·∫øu t·∫•t c·∫£ c√°c file con ch√°u ƒë·ªÅu h·ª£p l·ªá, th√¨ cache n√†y m·ªõi th·ª±c s·ª± h·ª£p l·ªá
        return true;
    }

    fn _createBundle(entryPath) {
        print("üì¶ B·∫Øt ƒë·∫ßu qu√° tr√¨nh bundle t·ª´ entrypoint: " + entryPath);
        let visited = {};
        // H√†m _bundleAst gi·ªù s·∫Ω tr·∫£ v·ªÅ m·ªôt object, ta ch·ªâ c·∫ßn ph·∫ßn body cu·ªëi c√πng.
        let bundledResult = this._bundleAst(entryPath, ".", visited);
        let bundledAst = { type: "Program", body: bundledResult.body };

        let outPath = this.options.out || "bundle.meowb";
        let generator = CodeGenerator.CodeGenerator(bundledAst, this, outPath);
        let protos = generator.compile();

        let stringifier = BytecodeStringifier();
        let bytecodeText = stringifier.stringify(protos);

        Io.write(outPath, bytecodeText);
        print("üì¶ T·∫°o bundle th√†nh c√¥ng: " + outPath);
        return Io.getAbsolutePath(outPath);
    }

    // S·ª¨A ƒê·ªîI H√ÄM N√ÄY
    fn _bundleAst(sourcePath, importerDir, visited) {
        let absolutePath = this._resolvePath(sourcePath, importerDir);

        if (visited[absolutePath]) {
            // Tr·∫£ v·ªÅ m·ªôt c·∫•u tr√∫c r·ªóng ƒë·ªÉ tr√°nh l·ªói v√† import l·∫∑p.
            return { type: "Program", body: [], exports: [] };
        }
        visited[absolutePath] = true;

        let source = Io.read(absolutePath);
        if (source == null) {
            print("[ERROR] Bundle: Kh√¥ng th·ªÉ ƒë·ªçc file ngu·ªìn: " + absolutePath);
            System.exit(1);
        }

        let lexer = new Lexer(source, absolutePath);
        let tokens = lexer.tokenize();
        let parser = new Parser(tokens);
        let ast = parser.parseProgram();

        let exportedNames = _findExportedNames(ast); // T√¨m c√°c t√™n export c·ªßa file n√†y.
        let newBody = [];
        let sourceDir = _getDirectoryPath(absolutePath);

        for (stmt in ast.body) {
            if (stmt.type == "ImportStatement") {
                let dependencyPath = stmt.path.value;
                if (dependencyPath.endsWith(".meow")) {
                    // ƒê·ªá quy ƒë·ªÉ l·∫•y AST v√† danh s√°ch export c·ªßa module con.
                    let importedResult = this._bundleAst(dependencyPath, sourceDir, visited);
                    
                    // D√°n ph·∫ßn th√¢n c·ªßa module con v√†o tr∆∞·ªõc.
                    for (childStmt in importedResult.body) {
                        newBody.push(childStmt);
                    }

                    // X·ª≠ l√Ω logic t·∫°o namespace n·∫øu c·∫ßn.
                    if (stmt.namespaceImport != null) {
                        // ƒê√¢y l√† `import * as Name from ...`
                        let namespaceName = stmt.namespaceImport.name;
                        let properties = [];
                        for (exportedName in importedResult.exports) {
                            properties.push({
                                key: { type: "StringLiteral", value: exportedName },
                                value: { type: "Identifier", name: exportedName }
                            });
                        }
                        let objectLiteral = { type: "ObjectLiteral", properties: properties };
                        // T·∫°o c√¢u l·ªánh `let Name = { ... };` b·∫±ng AST
                        let letStmt = {
                            type: "LetStatement",
                            name: { type: "Identifier", name: namespaceName },
                            value: objectLiteral,
                            isConstant: true
                        };
                        newBody.push(letStmt);
                    }
                    // V·ªõi `import {..}` ho·∫∑c `import '...'`, ta ch·ªâ c·∫ßn d√°n code, kh√¥ng c·∫ßn l√†m g√¨ th√™m.

                } else {
                    newBody.push(stmt); // Gi·ªØ l·∫°i import stdlib
                }
            } else if (stmt.type == "ExportStatement") {
                // "M·ªü g√≥i" export ƒë·ªÉ n√≥ tr·ªü th√†nh khai b√°o b√¨nh th∆∞·ªùng.
                if (stmt.declaration) {
                    newBody.push(stmt.declaration);
                }
            } else {
                newBody.push(stmt);
            }
        }

        ast.body = newBody;
        // Tr·∫£ v·ªÅ c·∫£ th√¢n AST ƒë√£ x·ª≠ l√Ω v√† danh s√°ch t√™n ƒë√£ export.
        return { type: "Program", body: ast.body, exports: exportedNames };
    }



}