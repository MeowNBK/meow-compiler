import * as Io from "io";
import * as Json from "json";
import * as System from "system";
import { Lexer } from "frontend/lexer.meow";
import { Parser } from "frontend/parser.meow";
import { Preprocessor } from "frontend/preprocessor.meow";
import { ScopeAnalyzer } from "middle-end/scopeAnalyzer.meow";
import { TypeInferrer } from "middle-end/typeInferrer.meow";
import { BytecodeStringifier } from "backend/bytecodeStringifier.meow";
import { CodeGenerator } from "backend/codeGenerator.meow";
import { getDirectoryPath, isAbsolutePath } from "backend/utils/pathUtils.meow";
import { AstLinker } from "backend/astLinker.meow";
import { optimizeRegisters } from "backend/registerOptimizer.meow";

export class Compiler {
    fn init(options) {
        this.options = options || {};
    }

    fn parseOnly(absolutePath) {
        if (!Io.fileExists(absolutePath)) return null;
        let source = Io.read(absolutePath);
        if (source == null) return null;

        // Preprocess & Lex
        let preprocessor = new Preprocessor();
        let processedSource = preprocessor.process(source, absolutePath);
        let lexer = new Lexer(processedSource, absolutePath);
        let tokens = lexer.tokenize();

        // Parse
        let parser = new Parser(tokens);
        let ast = parser.parseProgram();

        if (parser.diagnostics.size() > 0) {
            for (let i = 0; i < parser.diagnostics.size(); ++i) {
                print(parser.diagnostics[i]);
            }
            return null;
        }
        return ast;
    }

    fn _getDirectoryPath(p) {
        return getDirectoryPath(p);
    }

    fn compileBundle(entryPath, options) {
        // 1. Resolve Entry Path
        let absEntry = this._resolvePath(entryPath, ".");
        if (!Io.fileExists(absEntry)) {
            print("[Error] Entry file not found: " + absEntry);
            System.exit(1);
        }

        // 2. Linking: Tạo ra 1 AST duy nhất cho toàn bộ project
        let linker = new AstLinker();
        linker.init();
        
        // Truyền 'this' (Compiler instance) vào để linker dùng _resolvePath và parseOnly
        let bundleAst = linker.link(absEntry, this);

        // 3. Analysis: Analyze Scope cho toàn bộ Bundle
        // ScopeAnalyzer [cite: 218] sẽ chạy trên Program mới này.
        // Nó sẽ resolve __modules__, __loader__ vào Global hoặc Local của main,
        // và resolve các biến bên trong FunctionLiteral module chính xác.
        let analyzer = new ScopeAnalyzer(bundleAst);
        analyzer.analyze();

        print("\n[INFO] Chạy Type Inference...");
        let inferrer = new TypeInferrer(bundleAst);
        inferrer.analyze();

        // 4. Code Generation: AST -> Protos
        // Lúc này AST chỉ toàn là Function, Call, Array... không còn Import/Export
        // CodeGenerator [cite: 135] xử lý bình thường.
        let generator = new CodeGenerator(bundleAst, this, null, "bundle");
        let protos = generator.compile();

        // protos = optimizeRegisters(protos);

        // 5. Optimization (Optional but recommended)
        // import { optimizeRegisters } from "backend/registerOptimizer.meow";
        // protos = optimizeRegisters(protos);

        // 6. Stringify: Protos -> Bytecode Text
        let stringifier = new BytecodeStringifier();
        let bytecodeText = stringifier.stringify(protos);

        return bytecodeText;
    }

    fn getImportsOnly(absolutePath) {
        if (!Io.fileExists(absolutePath)) {
            print("[ERROR] getImportsOnly: File nguồn không tồn tại: " + absolutePath);
            return [];
        }
        let source = Io.read(absolutePath);
        if (source == null) {
            print("[ERROR] getImportsOnly: Không thể đọc file nguồn: " + absolutePath);
            return [];
        }

        let preprocessor = new Preprocessor();
        let processedSource = preprocessor.process(source, absolutePath);
        let lexer = new Lexer(processedSource, absolutePath);
        let tokens = lexer.tokenize();
        let parser = new Parser(tokens);
        let ast = parser.parseProgram();
        if (parser.diagnostics.size() > 0) {
            for (diagnostic in parser.diagnostics) {
                print(diagnostic);
            }
            print("[ERROR] compileFile: Dừng biên dịch do có lỗi cú pháp.");
            System.exit(1);
        }
        if (!ast) {
            print("[ERROR] getImportsOnly: Không thể parse AST: " + absolutePath);
            return [];
        }
        
        let sourceDir = getDirectoryPath(absolutePath);
        let imports = this._extractImportsFromAST(ast, sourceDir);
        return imports;
    }


    fn compileFile(absolutePath, cacheManager) {
        if (!Io.fileExists(absolutePath)) {
            print("[ERROR] File nguồn không tồn tại: " + absolutePath);
            System.exit(1);
        }

        let source = Io.read(absolutePath);
        if (source == null) {
            print("[ERROR] Không thể đọc file nguồn: " + absolutePath);
            System.exit(1);
        }

        let preprocessor = new Preprocessor();
        let processedSource = preprocessor.process(source, absolutePath);
        let lexer = new Lexer(processedSource, absolutePath);
        let tokens = lexer.tokenize();
        let parser = new Parser(tokens);
        let ast = parser.parseProgram();
        if (parser.diagnostics.size() > 0) {
            for (diagnostic in parser.diagnostics) {
                print(diagnostic);
            }
            print("[ERROR] getImportsOnly: Dừng lại do có lỗi cú pháp.");
            return [];
        }
        if (!ast) {
            print("[ERROR] Meta.compile trả về null/undefined cho: " + absolutePath);
            System.exit(1);
        }
        let analyzer = new ScopeAnalyzer(ast);
        analyzer.analyze();
        
        let sourceDir = getDirectoryPath(absolutePath);
        let imports = this._extractImportsFromAST(ast, sourceDir);
        
        let generator = CodeGenerator(ast, this, cacheManager, absolutePath);
        let protos = generator.compile();

        let stringifier = BytecodeStringifier();
        let bytecodeText = stringifier.stringify(protos);

        return {
            "bytecodeText": bytecodeText,
            "imports": imports
        };
    }

    fn _resolvePath(p, importerDir) {
        if (isAbsolutePath(p)) return Io.getAbsolutePath(p);
        let absImporter = null;
        if (importerDir && importerDir.size() > 0) {
            absImporter = Io.getAbsolutePath(importerDir);
        }

        let isExplicitRelative = false;
        if (p.startsWith("./") || p.startsWith("../")) isExplicitRelative = true;
        let candidates = [];
        if (isExplicitRelative && absImporter) {
            candidates.push(absImporter + "/" + p);
        }

        if (this && this.options && this.options.includePaths) {
            for (ip in this.options.includePaths) {
                candidates.push(Io.getAbsolutePath(ip) + "/" + p);
            }
        }

        candidates.push(Io.getAbsolutePath(".") + "/" + p);
        candidates.push(p);
        let tryWithExt = !p.endsWith(".meow");
        for (cand in candidates) {
            let absCand = Io.getAbsolutePath(cand);
            if (Io.fileExists(absCand)) return absCand;
            if (tryWithExt) {
                let absExt = Io.getAbsolutePath(cand + ".meow");
                if (Io.fileExists(absExt)) return absExt;
            }
        }

        if (isExplicitRelative && absImporter) return Io.getAbsolutePath(absImporter + "/" + p);
        if (absImporter && !isExplicitRelative) return Io.getAbsolutePath(absImporter + "/" + p);
        return Io.getAbsolutePath(p);
    }

    fn _extractImportsFromAST(ast, sourceDir) {
        let imports = [];
        if (!ast || !ast.body) return imports;
        for (stmt in ast.body) {
            if (stmt.type == "ImportStatement") {
                let dependencyPath = stmt.path.value;
                if (dependencyPath.endsWith(".meow")) {
                    imports.push(this._resolvePath(dependencyPath, sourceDir));
                }
            }
        }
        return imports;
    }
}
