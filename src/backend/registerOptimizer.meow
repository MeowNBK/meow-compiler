import * as Emitter from "backend/emitter.meow";
import { OpCodes } from "backend/opCodes.meow";

fn getRegArgIndices(opcode) {
    return Emitter.getRegArgIndices(opcode);
}

// [FIX] Hàm helper để kiểm tra xem Opcode có CHỈ ĐỌC thanh ghi đầu tiên hay không.
// Nếu trả về true, nghĩa là arg[0] là READ (Use).
// Nếu trả về false, nghĩa là arg[0] là WRITE (Def).
fn isReadOnlyFirstArg(op) {
    // Các lệnh nhảy có điều kiện đọc thanh ghi điều kiện
    if (op == OpCodes.JUMP_IF_FALSE || op == OpCodes.JUMP_IF_TRUE) return true;
    
    // Các lệnh SET vào môi trường bên ngoài, đọc thanh ghi giá trị nguồn
    if (op == OpCodes.SET_GLOBAL || op == OpCodes.SET_UPVALUE) return true;
    
    // Các lệnh gán thuộc tính/index: target[prop] = value.
    // Reg 0 là target (object), Reg 1/2 là value. Chúng đều là READ (để tìm địa chỉ heap).
    if (op == OpCodes.SET_PROP || op == OpCodes.SET_INDEX) return true;
    
    // Các lệnh return/export/throw đọc giá trị trả về
    if (op == OpCodes.EXPORT || op == OpCodes.RETURN || op == OpCodes.THROW) return true;
    
    // Các lệnh class/object
    if (op == OpCodes.SET_METHOD || op == OpCodes.INHERIT) return true;
    if (op == OpCodes.IMPORT_MODULE) return true;
    
    return false;
}

// Hàm này sẽ tối ưu hóa một proto và trả về bảng ánh xạ vReg -> pReg
fn optimizeProtoAndGetMapping(proto) {
    let code = proto.code;
    if (code.size() == 0) {
        proto.numRegisters = 0;
        return {};
    }
    
    // Bước 1: Phân tích Live Range (tìm Start và End)
    let vRegStart = {}; // [FIX] Theo dõi lần xuất hiện đầu tiên (Instruction Pointer)
    let vRegEnd = {};   // [FIX] Theo dõi lần xuất hiện cuối cùng
    let allVRegs = {};
    
    for (let ip = 0; ip < code.size(); ++ip) {
        let inst = code[ip];
        let regIdxs = getRegArgIndices(inst.op);
        
        if (regIdxs == null) continue;
        
        let args = inst.args;
        for (let i = 0; i < regIdxs.size(); ++i) {
            let argIndex = regIdxs[i];
            if (argIndex >= args.size()) continue;
            let vReg = args[argIndex];

            if (typeof(vReg) != "int") continue;
            
            let sReg = str(vReg);
            allVRegs[sReg] = true;

            // [FIX] Cập nhật thời điểm bắt đầu (nếu chưa có)
            if (vRegStart[sReg] == null) {
                vRegStart[sReg] = ip;
            }

            // [FIX] Luôn cập nhật thời điểm kết thúc tại lệnh hiện tại
            // (Đơn giản hóa: biến sống đến lệnh cuối cùng nó được nhắc đến, dù là Read hay Write)
            vRegEnd[sReg] = ip;
        }
    }
    
    // Bước 2: Chuẩn bị cho Linear Scan
    let intervals = [];
    let vRegs = allVRegs.keys();
    
    // [FIX] Không cần sort vRegs ở đây nữa, ta sẽ sort intervals bên dưới
    
    for (let i = 0; i < vRegs.size(); ++i) {
        let sReg = vRegs[i];
        
        // [FIX] start và end phải dựa trên IP thực tế
        let startPos = vRegStart[sReg];
        let endPos = vRegEnd[sReg];

        intervals.push({ 
            vReg: int(sReg), 
            sReg: sReg,
            start: startPos, 
            end: endPos
        });
    }

    // [FIX] QUAN TRỌNG: Linear Scan yêu cầu intervals phải được sắp xếp theo thời gian BẮT ĐẦU
    intervals.sort(fn(a, b) { 
        return a.start - b.start; 
    });

    // Bước 3: Linear Scan (Giữ nguyên logic nhưng giờ input đã đúng)
    let active = [];
    let vToNewReg = {};
    let freeRegs = [];
    let nextNewReg = 0;

    for (let i = 0; i < intervals.size(); ++i) {
        let interval = intervals[i];

        // Loại bỏ các interval đã kết thúc khỏi danh sách active
        let newActive = [];
        for (let j = 0; j < active.size(); ++j) {
            let activeInterval = active[j];
            // [FIX Logic] Nếu active kết thúc TRƯỚC HOẶC TẠI thời điểm interval mới bắt đầu
            // Ta có thể tái sử dụng (tùy thuộc vào định nghĩa live range, an toàn nhất là <)
            if (activeInterval.end < interval.start) { 
                freeRegs.push(vToNewReg[activeInterval.sReg]);
            } else {
                newActive.push(activeInterval);
            }
        }
        active = newActive;

        // Cấp phát thanh ghi
        let newReg;
        if (freeRegs.size() > 0) {
            // Tái sử dụng thanh ghi có số hiệu nhỏ nhất (để tối ưu memory)
            freeRegs.sort(fn(a, b) { return a - b; });
            newReg = freeRegs[0];
            
            // Xóa phần tử đầu (thủ công vì chưa có shift)
            let newFreeRegs = [];
            for (let k = 1; k < freeRegs.size(); ++k) newFreeRegs.push(freeRegs[k]);
            freeRegs = newFreeRegs;
        } else {
            newReg = nextNewReg++;
        }
        
        vToNewReg[interval.sReg] = newReg;
        active.push(interval);
        
        // Sắp xếp active theo thời gian kết thúc (để heuristic loại bỏ tốt hơn)
        active.sort(fn(a, b) { return a.end - b.end; });
    }
    
    // Bước 4 & 5: Áp dụng ánh xạ (Giữ nguyên code cũ)
    for (inst in code) {
        let regIdxs = getRegArgIndices(inst.op);
        if (regIdxs == null) continue;

        for (argIndex in regIdxs) {
            if (argIndex >= inst.args.size()) continue;
            let vReg = inst.args[argIndex];

            if (typeof(vReg) == "int") {
                let sReg = str(vReg);
                let newReg = vToNewReg[sReg];
                if (newReg != null) {
                    inst.args[argIndex] = newReg;
                }
            }
        }
    }
    
    proto.numRegisters = Emitter.computeMaxRegister(proto) + 1;
    return vToNewReg;
}

// Hàm chính được export, điều phối 2 giai đoạn
export fn optimizeRegisters(protos) {
    let allMappings = {};
    let protoNames = protos.keys();
    protoNames.sort(); // Sắp xếp để đảm bảo thứ tự xử lý nhất quán

    // GIAI ĐOẠN 1: Tối ưu hóa bytecode và thu thập bảng ánh xạ
    for (pName in protoNames) {
        let proto = protos[pName];
        allMappings[pName] = optimizeProtoAndGetMapping(proto);
    }

    // GIAI ĐOẠN 2: Dùng các bảng ánh xạ để vá lại upvalueDescs
    for (pName in protoNames) {
        let parentProto = protos[pName];
        if (!parentProto || !parentProto.constantPool) continue;

        let parentMap = allMappings[pName];
        if (!parentMap) continue;

        for (constant in parentProto.constantPool) {
            // Kiểm tra xem hằng số có phải là một hàm con không
            if (typeof(constant) == "object" && constant != null && constant.sourceName) {
                let childProto = protos[constant.sourceName];

                if (childProto && childProto.upvalueDescs) {
                    for (desc in childProto.upvalueDescs) {
                        // Nếu upvalue này là một biến local của hàm cha
                        if (desc.isLocal) {
                            let oldVirtualReg = desc.index;
                            let newPhysicalReg = parentMap[str(oldVirtualReg)];

                            if (newPhysicalReg != null) {
                                // Cập nhật lại chỉ số thành số hiệu thanh ghi vật lý mới
                                desc.index = newPhysicalReg;
                            } else {
                                print("[WARN] Optimizer: Không tìm thấy ánh xạ cho upvalue vReg " + str(oldVirtualReg) + " từ hàm " + pName);
                            }
                        }
                    }
                }
            }
        }
    }

    return protos;
}