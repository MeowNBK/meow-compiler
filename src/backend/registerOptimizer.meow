import * as Emitter from "backend/emitter.meow";
import { OpCodes } from "backend/opCodes.meow";

fn getRegArgIndices(opcode) {
    return Emitter.getRegArgIndices(opcode);
}

// Hàm này sẽ tối ưu hóa một proto và trả về bảng ánh xạ vReg -> pReg
fn optimizeProtoAndGetMapping(proto) {
    let code = proto.code;
    if (code.size() == 0) {
        proto.numRegisters = 0;
        return {};
    }
    
    // --- BƯỚC 1: Phân tích Live Range & Identify Blocks ---
    let vRegStart = {};
    let vRegEnd = {};
    let allVRegs = {};
    
    // Block tracking
    let blockInfo = {};    // LeaderVReg -> Size
    let memberOfBlock = {}; // VReg -> LeaderVReg

    for (let ip = 0; ip < code.size(); ++ip) {
        let inst = code[ip];

        // 1.1. Cập nhật Start/End cho các thanh ghi thường
        let regIdxs = getRegArgIndices(inst.op);
        if (regIdxs != null) {
            let args = inst.args;
            for (let i = 0; i < regIdxs.size(); ++i) {
                let argIndex = regIdxs[i];
                if (argIndex >= args.size()) continue;
                let vReg = args[argIndex];

                if (typeof(vReg) != "int") continue;
                
                let sReg = str(vReg);
                allVRegs[sReg] = true;

                if (vRegStart[sReg] == null) vRegStart[sReg] = ip;
                vRegEnd[sReg] = ip;
            }
        }

        // 1.2. [CRITICAL FIX] Xử lý CLOSURE (Keep-alive captured variables)
        if (inst.op == OpCodes.CLOSURE) {
            let protoIdx = inst.args[1];
            if (protoIdx < proto.constantPool.size()) {
                let childProto = proto.constantPool[protoIdx];
                if (childProto && childProto.upvalueDescs) {
                    for (let k = 0; k < childProto.upvalueDescs.size(); ++k) {
                        let desc = childProto.upvalueDescs[k];
                        if (desc.isLocal) {
                            let sReg = str(desc.index);
                            allVRegs[sReg] = true;
                            if (vRegStart[sReg] == null) vRegStart[sReg] = ip;
                            vRegEnd[sReg] = ip; // Kéo dài sự sống đến đây
                        }
                    }
                }
            }
        }

        // 1.3. [CRITICAL FIX] Nhận diện Register Blocks (CALL, NEW_ARRAY...)
        // Những lệnh này yêu cầu 'cnt' thanh ghi liên tiếp bắt đầu từ 'leader'
        let leader = -1;
        let cnt = 0;

        if (inst.op == OpCodes.CALL) {
            // CALL dest, callee, argStart, argc
            leader = inst.args[2];
            cnt = inst.args[3];
        } else if (inst.op == OpCodes.NEW_ARRAY || inst.op == OpCodes.NEW_HASH) {
            // NEW_ARRAY dest, start, count
            leader = inst.args[1];
            cnt = inst.args[2];
        }

        if (cnt > 0 && leader != -1) {
            let sLeader = str(leader);
            blockInfo[sLeader] = cnt;
            
            // Đánh dấu các thành viên thuộc block này
            for (let k = 0; k < cnt; ++k) {
                let memberReg = leader + k;
                memberOfBlock[str(memberReg)] = sLeader;
            }
        }
    }
    
    // --- BƯỚC 2: Tạo Intervals (Gộp block thành 1 interval lớn) ---
    let intervals = [];
    let vRegs = allVRegs.keys();
    
    for (let i = 0; i < vRegs.size(); ++i) {
        let sReg = vRegs[i];
        
        // Nếu là member của block (nhưng không phải leader), bỏ qua, sẽ xử lý theo leader
        if (memberOfBlock[sReg] != null && memberOfBlock[sReg] != sReg) {
            continue;
        }

        // Nếu là Leader của block (hoặc register thường)
        let blockSize = 1;
        if (blockInfo[sReg] != null) blockSize = blockInfo[sReg];

        let startPos = vRegStart[sReg];
        let endPos = vRegEnd[sReg];

        // Nếu là block, Master Interval phải bao trùm tất cả member
        if (blockSize > 1) {
            let vLeader = int(sReg);
            for (let k = 1; k < blockSize; ++k) {
                let sMember = str(vLeader + k);
                if (vRegStart[sMember] != null) {
                    if (vRegStart[sMember] < startPos) startPos = vRegStart[sMember];
                }
                if (vRegEnd[sMember] != null) {
                    if (vRegEnd[sMember] > endPos) endPos = vRegEnd[sMember];
                }
            }
        }

        intervals.push({ 
            vReg: int(sReg), 
            sReg: sReg,
            start: startPos, 
            end: endPos,
            size: blockSize
        });
    }

    // Sort theo Start Time
    intervals.sort(fn(a, b) { return a.start - b.start; });

    // --- BƯỚC 3: Linear Scan Allocation ---
    let active = [];
    let vToNewReg = {};
    let freeRegs = [];
    let nextNewReg = 0;

    for (let i = 0; i < intervals.size(); ++i) {
        let interval = intervals[i];

        // Expire Old Intervals
        let newActive = [];
        for (let j = 0; j < active.size(); ++j) {
            let act = active[j];
            if (act.end < interval.start) {
                // Trả lại tất cả thanh ghi đã chiếm
                for (let k = 0; k < act.size; ++k) {
                    freeRegs.push(act.assignedReg + k);
                }
            } else {
                newActive.push(act);
            }
        }
        active = newActive;

        // Allocate
        let baseReg = -1;

        if (interval.size == 1) {
            // Single register: Ưu tiên tái sử dụng
            if (freeRegs.size() > 0) {
                baseReg = freeRegs.pop();
            } else {
                baseReg = nextNewReg;
                nextNewReg += 1;
            }
        } else {
            // Block register: Cấp phát mới hoàn toàn để đảm bảo tính liên tục (Contiguous)
            // (Việc tìm chuỗi liên tiếp trong freeRegs quá phức tạp, nên ta cứ lấy mới cho an toàn)
            baseReg = nextNewReg;
            nextNewReg += interval.size;
        }
        
        // Map Leader
        vToNewReg[interval.sReg] = baseReg;
        
        // Map Members (nếu là block)
        if (interval.size > 1) {
            for (let k = 1; k < interval.size; ++k) {
                let sMember = str(interval.vReg + k);
                vToNewReg[sMember] = baseReg + k;
            }
        }

        // Add to active (ghi lại assignedReg để giải phóng sau này)
        interval.assignedReg = baseReg;
        active.push(interval);
    }
    
    // --- BƯỚC 4: Apply Mapping ---
    for (let i = 0; i < code.size(); ++i) {
        let inst = code[i];
        let regIdxs = getRegArgIndices(inst.op);
        if (regIdxs == null) continue;

        for (let k = 0; k < regIdxs.size(); ++k) {
            let argIndex = regIdxs[k];
            if (argIndex >= inst.args.size()) continue;
            let vReg = inst.args[argIndex];

            if (typeof(vReg) == "int") {
                let sReg = str(vReg);
                let newReg = vToNewReg[sReg];
                if (newReg != null) {
                    inst.args[argIndex] = newReg;
                }
            }
        }
    }
    
    proto.numRegisters = Emitter.computeMaxRegister(proto) + 1;
    return vToNewReg;
}

// Hàm chính được export
export fn optimizeRegisters(protos) {
    let allMappings = {};
    let protoNames = protos.keys();
    protoNames.sort(); 

    // GIAI ĐOẠN 1: Tối ưu
    for (let i = 0; i < protoNames.size(); ++i) {
        let pName = protoNames[i];
        let proto = protos[pName];
        allMappings[pName] = optimizeProtoAndGetMapping(proto);
    }

    // GIAI ĐOẠN 2: Vá Upvalues
    for (let i = 0; i < protoNames.size(); ++i) {
        let pName = protoNames[i];
        let parentProto = protos[pName];
        if (!parentProto || !parentProto.constantPool) continue;

        let parentMap = allMappings[pName];
        if (!parentMap) continue;

        for (let j = 0; j < parentProto.constantPool.size(); ++j) {
            let constant = parentProto.constantPool[j];
            if (typeof(constant) == "object" && constant != null && constant.sourceName) {
                let childProto = protos[constant.sourceName];
                if (childProto && childProto.upvalueDescs) {
                    for (let k = 0; k < childProto.upvalueDescs.size(); ++k) {
                        let desc = childProto.upvalueDescs[k];
                        if (desc.isLocal) {
                            let oldVirtualReg = desc.index;
                            let newPhysicalReg = parentMap[str(oldVirtualReg)];

                            if (newPhysicalReg != null) {
                                desc.index = newPhysicalReg;
                            } else {
                                print("[WARN] Optimizer: Lost mapping for upvalue vReg " + str(oldVirtualReg) + " in " + pName);
                            }
                        }
                    }
                }
            }
        }
    }

    return protos;
}