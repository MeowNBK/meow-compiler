export class RegisterAllocator {
    fn init(numRegisters) {
        // Mặc dù không dùng numRegisters, cứ để đây cho vui, 
        // biết đâu sau này lại cần 🤣
        this._numRegisters = (numRegisters > 0) ? numRegisters : 256;
        this.reset();
    }

    fn reset() {
        this._nextRegister = 0; // Bắt đầu từ thanh ghi 0
    }

    // Không cần hàm _grow nữa, vì ta cấp phát vô hạn 🚀

    fn ralloc() {
        // Cứ lấy thanh ghi tiếp theo và tăng biến đếm. Ez game!
        let r = this._nextRegister;
        this._nextRegister++;
        return r;
    }

    fn rallocBlock(n) {
        assert(n > 0, "RegisterAllocator.rallocBlock: n phải > 0");
        // Lấy một khối và tăng biến đếm lên n. Quá đơn giản!
        let startReg = this._nextRegister;
        this._nextRegister += n;
        return startReg;
    }

    fn free(reg) {
        // "Tôi không quan tâm." - RegisterAllocator said. 😼
        // Hàm này giờ không làm gì cả.
    }

    fn beginScope() { 
        // Scope là gì? Có ăn được không? 🤔
    }

    fn endScope() {
        // Kết thúc scope? Kệ nó đi. 🤣
    }

    fn take() {
        // take() giờ cũng như ralloc() thôi
        return this.ralloc();
    }

    fn withTemp(fnUse) {
        let r = this.ralloc();
        let out = fnUse(r);
        // Không free nữa nhé. Cứ để đó.
        return out;
    }

    fn usedRegisters() { 
        // Số thanh ghi đã dùng chính là giá trị của biến đếm
        return this._nextRegister;
    }

    fn numRegisters() { 
        // Về mặt lý thuyết là "vô hạn", nhưng ta cứ trả về cái này cho nó có 🤓
        return this._nextRegister; 
    }
}