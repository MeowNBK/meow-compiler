import * as Io from "io";
import * as Json from "json";
import * as System from "system";
import { Compiler } from "backend/compiler.meow";
import { makeCacheFile } from "backend/utils/makeCacheFile.meow";
import { getDirectoryPath } from "backend/utils/pathUtils.meow";

export class CacheManager {
    fn init(compilerInstance, isNoCache, options) {
        this.compiler = compilerInstance; 
        this.isNoCache = isNoCache;
        this.options = options;
        
        this.compiledModules = {};
        this.dependencyGraph = {};
        this.reverseGraph = {};
    }

    fn compileProject(entryPath) {
        let initialDir = ".";
        let entryCache = this._getCachedOrCompile(entryPath, initialDir);
        
        if (this.options.out) {
            Io.copyFile(entryCache, this.options.out);
            return Io.getAbsolutePath(this.options.out);
        }
        return entryCache;
    }

    fn _getCachedOrCompile(sourcePath, importerDir) {
        let absolutePath = this.compiler._resolvePath(sourcePath, importerDir);
        if (this.compiledModules[absolutePath]) return this.compiledModules[absolutePath];

        let cachePath = makeCacheFile(absolutePath, this.options.buildDir || "builds/build");
        let metaPath = cachePath + ".meta";
        
        if (this._isCacheValid(absolutePath, cachePath)) {
            let metaText = Io.read(metaPath);
            if (!metaText) {
                print("[ERROR] Không thể đọc meta file: " + metaPath);
                System.exit(1);
            }
            let meta = Json.parse(metaText);
            this.dependencyGraph[absolutePath] = meta.imports || [];

            for (imp in this.dependencyGraph[absolutePath]) {
                if (!this.reverseGraph[imp]) this.reverseGraph[imp] = {};
                this.reverseGraph[imp][absolutePath] = true;
            }

            this.compiledModules[absolutePath] = Io.getAbsolutePath(cachePath);
            return Io.getAbsolutePath(cachePath);
        }

        let imports = this.compiler.getImportsOnly(absolutePath);

        for (imp in imports) {
            let sourceDir = getDirectoryPath(absolutePath);
            this._getCachedOrCompile(imp, sourceDir);
            if (!this.reverseGraph[imp]) this.reverseGraph[imp] = {};
            this.reverseGraph[imp][absolutePath] = true;
        }
        let compileResult = this.compiler.compileFile(absolutePath, this);
        let bytecodeText = compileResult.bytecodeText;

        Io.write(cachePath, bytecodeText);
        let metaOut = { imports: imports, srcTime: Io.getFileTimestamp(absolutePath), srcSize: Io.getFileSize(absolutePath) };
        metaOut.importTimes = {};
        metaOut.importSizes = {};
        for (imp in imports) {
            metaOut.importTimes[imp] = Io.getFileTimestamp(imp);
            metaOut.importSizes[imp] = Io.getFileSize(imp);
        }
        Io.write(metaPath, Json.stringify(metaOut));

        this.dependencyGraph[absolutePath] = imports;
        this.compiledModules[absolutePath] = Io.getAbsolutePath(cachePath);
        
        let dependents = this._gatherDependents(absolutePath, null);
        for (d in dependents) {
            if (!this.compiledModules[d]) {
                let dd = getDirectoryPath(d);
                this._getCachedOrCompile(d, dd);
            }
        }

        return Io.getAbsolutePath(cachePath);
    }

    fn _gatherDependents(absSource, accum) {
        if (!accum) accum = {};
        let direct = this.reverseGraph[absSource];
        if (!direct) return accum;
        for (d in direct) {
            if (!accum[d]) {
                accum[d] = true;
                this._gatherDependents(d, accum);
            }
        }
        return accum;
    }

    fn _isCacheValid(absSourcePath, cachePath) {
        if (this.isNoCache || this.options.force) return false;
        if (!Io.fileExists(cachePath)) return false;

        let metaPath = cachePath + ".meta";
        if (!Io.fileExists(metaPath)) return false;

        let metaText = Io.read(metaPath);
        if (!metaText) return false;

        let meta = Json.parse(metaText);
        if (!meta) return false;

        if (!Io.fileExists(absSourcePath)) return false;
        let srcTime = Io.getFileTimestamp(absSourcePath);
        let srcSize = Io.getFileSize(absSourcePath);
        if (meta.srcTime != srcTime || meta.srcSize != srcSize) return false;
        
        for (imp in meta.imports) {
            let impCachePath = makeCacheFile(imp, this.options.buildDir || "builds/build");
            if (!this._isCacheValid(imp, impCachePath)) {
                return false;
            }
        }
        return true;
    }
}