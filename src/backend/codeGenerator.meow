import * as Emitter from "backend/emitter.meow";
import { OpCodes } from "backend/opCodes.meow";
import { Visitor } from "backend/visitor/visitor.meow";
import { CompilerState } from "backend/compilerState.meow";

export class CodeGenerator {
    fn init(ast, compiler, cacheManager, sourceName) {
        this.ast = ast;
        this.compiler = compiler;
        this.cacheManager = cacheManager;
        this.sourceName = sourceName;
        this.protos = {};
        this.states = [];
        this.currentState = null;
        this.isInsideClass = false;
    }

    fn compile() {
        let mainStr = "@main";
        this.enterState("@main");
        this.currentState.proto.sourceName = this.sourceName;
        
        for (let i = 0; i < this.ast.body.size(); ++i) {
            this.visitStatement(this.ast.body[i]);
        }
        
        let mainProto = this.exitState();
        this.protos["@main"] = mainProto;

        return this.protos;
    }

    fn enterState(name) {
        let parentState = this.currentState;
        let newState = new CompilerState(name);

        if (parentState) {
            for (key in parentState.moduleVariables.keys()) {
                newState.moduleVariables[key] = parentState.moduleVariables[key];
            }
            for (key in parentState.importedVariables.keys()) {
                newState.importedVariables[key] = parentState.importedVariables[key];
            }
        }

        this.states.push(newState);
        this.currentState = newState;
    }

    fn exitState() {
        let finishedState = this.states.pop();
        let proto = finishedState.proto;

        let lastIdx = proto.code.size() - 1;
        if (lastIdx < 0 || proto.code[lastIdx].op != OpCodes.RETURN) {

            finishedState.allocator.withTemp(fn(r) {
                Emitter.emit(proto, OpCodes.LOAD_NULL, [r]);
                Emitter.emit(proto, OpCodes.RETURN, [r]);
            });
        }
        
        proto.numRegisters = finishedState.allocator.usedRegisters();
        let recomputed = Emitter.computeMaxRegister(proto) + 1;
        if (recomputed > proto.numRegisters) proto.numRegisters = recomputed;

        if (!proto.upvalueDescs) proto.upvalueDescs = [];
        proto.numUpvalues = proto.upvalueDescs.size();

        Emitter.patchPendingJumps(proto);
        
        if (this.states.size() > 0) {
            this.currentState = this.states[this.states.size() - 1];
        } else {
            this.currentState = null;
        }
        return proto;
    }
    
    fn visitStatement(node) {
        if (node == null) return;
        let handler = Visitor.statements[node.type];
        assert(handler, `Lỗi: Không hỗ trợ kiểu statement '%{node.type}'`);
        handler(this, node);
    }

    fn visitExpression(node) {
        if (node == null) return -1;
        let handler = Visitor.expressions[node.type];
        assert(handler, `Lỗi: Không hỗ trợ kiểu expression '%{node.type}'`);
        return handler(this, node);
    }
}