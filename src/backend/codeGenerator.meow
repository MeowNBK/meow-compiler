
import * as RegisterAllocator from "./registerAllocator.meow";
import * as ConstantPool from "./constantPool.meow";
import * as Emitter from "./emitter.meow";
import * as RegisterOptimizer from "./registerOptimizer.meow";
import { OpCodes } from "./opCodes.meow";
import { Visitor } from "./visitor/visitor.meow";

class CompilerState {
    fn init(name) {
        this.proto = Emitter.createProto(name, 256);
        this.pool = ConstantPool.ConstantPool(this.proto.constantPool);
        this.allocator = RegisterAllocator.RegisterAllocator(256);
        this.scope = [{}];
        this.loopLabels = [];
        this.moduleVariables = {};
        this.importedVariables = {};
        this.capturedLocals = {};
        this.regToLocalIndex = {};
        this.localIndexToReg = {};
        this.localCount = 0;
    }
}

export class CodeGenerator {
    fn init(ast, compiler, sourceName) {
        this.ast = ast;
        this.compiler = compiler;
        this.sourceName = sourceName;
        this.protos = {};
        this.states = [];
        this.currentState = null;
        this.isInsideClass = false;

    }

    fn compile() {
        let mainStr = "@main";
        this.enterState("@main");
        this.currentState.proto.sourceName = this.sourceName;
        
        for (let i = 0; i < this.ast.body.length; ++i) {
            this.visitStatement(this.ast.body[i]);
        }
        
        let mainProto = this.exitState();
        this.protos["@main"] = mainProto;

        // this.protos = RegisterOptimizer.optimizeRegisters(this.protos);

        return this.protos;
    }

    fn enterState(name) {
        let parentState = this.currentState;
        let newState = new CompilerState(name);

        if (parentState) {
            for (key in parentState.moduleVariables.keys()) {
                newState.moduleVariables[key] = parentState.moduleVariables[key];
            }
            for (key in parentState.importedVariables.keys()) {
                newState.importedVariables[key] = parentState.importedVariables[key];
            }
        }

        this.states.push(newState);
        this.currentState = newState;
    }

    fn exitState() {
        let finishedState = this.states.pop();
        let proto = finishedState.proto;

        let lastIdx = proto.code.length - 1;
        if (lastIdx < 0 || proto.code[lastIdx].op != OpCodes.RETURN) {

            finishedState.allocator.withTemp(fn(r) {
                Emitter.emit(proto, OpCodes.LOAD_NULL, [r]);
                Emitter.emit(proto, OpCodes.RETURN, [r]);
            });
        }
        
        proto.numRegisters = finishedState.allocator.usedRegisters();
        let recomputed = Emitter.computeMaxRegister(proto) + 1;
        if (recomputed > proto.numRegisters) proto.numRegisters = recomputed;

        if (!proto.upvalueDescs) proto.upvalueDescs = [];
        proto.numUpvalues = proto.upvalueDescs.length;

        Emitter.patchPendingJumps(proto);
        
        if (this.states.length > 0) {
            this.currentState = this.states[this.states.length - 1];
        } else {
            this.currentState = null;
        }
        return proto;
    }
    
    fn visitStatement(node) {
        if (node == null) return;
        let handler = Visitor.statements[node.type];
        assert(handler, `Lỗi: Không hỗ trợ kiểu statement '%{node.type}'`);
        handler(this, node);
    }

    fn visitExpression(node) {
        if (node == null) return -1;
        let handler = Visitor.expressions[node.type];
        assert(handler, `Lỗi: Không hỗ trợ kiểu expression '%{node.type}'`);
        return handler(this, node);
    }
    
    fn findVariable(name) {
        let localResult = this._findLocalInCurrentState(name);
        if (localResult != null) {
            return localResult;
        }

        if (this.states.length > 1) {

            let upvalueResult = this._findUpvalueRecursive(name, this.states.length - 2);
            if (upvalueResult != null) {
                return upvalueResult;
            }
        }

        return { "type": "global", "name": name };
    }

    fn _findLocalInCurrentState(name) {

        for (let i = this.currentState.scope.length - 1; i >= 0; --i) {
            let scope = this.currentState.scope[i];
            if (scope[name] != null) {

                let localIndex = scope[name];

                let reg = this.currentState.localIndexToReg[localIndex];

                assert(reg != null, `Lỗi nghiêm trọng: Không tìm thấy register cho localIndex=${localIndex} của biến '${name}'`);


                return {'type': 'local', 'index': reg, 'localIndex': localIndex};
            }
        }
        return null;

    }

    fn _findUpvalueRecursive(name, parentStateIndex) {
        if (parentStateIndex < 0) {
            return null;
        }

        let parentState = this.states[parentStateIndex];
        let childState = this.states[parentStateIndex + 1];


        for (let i = parentState.scope.length - 1; i >= 0; --i) {
            let scope = parentState.scope[i];
            if (scope[name] != null) {

                let localIndex = scope[name];
                let registerToCapture = parentState.localIndexToReg[localIndex];
                assert(registerToCapture != null, `Lỗi nghiêm trọng: Không tìm thấy thanh ghi cho local '${name}'`);

                parentState.capturedLocals[localIndex] = true;


                return this._addUpvalueToState({'isLocal': true, 'index': registerToCapture}, childState);
            }
        }

        if (parentStateIndex > 0) {
            let resultFromGrandparent = this._findUpvalueRecursive(name, parentStateIndex - 1);

            if (resultFromGrandparent != null) {



                return this._addUpvalueToState({'isLocal': false, 'index': resultFromGrandparent.index}, childState);
            }
        }

        return null;
    }

    fn _addUpvalue(desc) {
        return this._addUpvalueToState(desc, this.currentState);
    }
    
    fn _addUpvalueToState(desc, state) {

        let proto = state.proto;
        if (!proto.upvalueDescs) proto.upvalueDescs = [];

        assert(typeof(desc.isLocal) == 'bool' || typeof(desc.isLocal) == 'boolean', 'upvalue desc phải có isLocal boolean');
        assert(typeof(desc.index) == 'int' || typeof(desc.index) == 'real' || typeof(desc.index) == 'number', 'upvalue desc.index phải là số (int)');

        for (let i = 0; i < proto.upvalueDescs.length; ++i) {
            let d = proto.upvalueDescs[i];
            if (d.index == desc.index && d.isLocal == desc.isLocal) {
                return {'type': 'upvalue', 'index': i};
            }
        }
        let newIndex = proto.upvalueDescs.length;
        proto.upvalueDescs.push(desc);
        return {'type': 'upvalue', 'index': newIndex};

    }
}