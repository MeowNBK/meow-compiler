import * as System from "system";
import * as Io from "io";

let stdlib = { 
    "io": true, "array": true, "json": true, "object": true, 
    "string": true, "system": true, "native": true 
};

export class AstLinker {
    fn init() {
        this.pathToId = {};
        this.idToPath = {};   
        this.modulesList = []; 
        this.nextId = 0;
    }

    fn link(entryPath, compilerInstance) {
        let absEntry = compilerInstance._resolvePath(entryPath, ".");
        let rawAsts = {}; 
        
        let queue = [absEntry];
        let processed = {}; 

        this._assignId(absEntry);
        while (queue.size() > 0) {
            let currentPath = queue.pop();
            if (processed[currentPath]) continue;
            processed[currentPath] = true;

            let ast = compilerInstance.parseOnly(currentPath);
            if (ast == null) {
                print("[Linker Error] Cannot parse: " + currentPath);
                System.exit(1);
            }
            rawAsts[currentPath] = ast;

            let dir = compilerInstance._getDirectoryPath(currentPath);
            let imports = this._scanImports(ast);

            for (let i = 0; i < imports.size(); ++i) {
                let rawImportPath = imports[i];
                if (stdlib[rawImportPath]) continue;

                let absImportPath = compilerInstance._resolvePath(rawImportPath, dir);
                if (!Io.fileExists(absImportPath)) {
                     print("[Linker Error] File not found: " + absImportPath);
                     System.exit(1);
                }

                this._assignId(absImportPath);
                if (!processed[absImportPath]) {
                    queue.push(absImportPath);
                }
            }
        }

        // Sắp xếp theo ID để đảm bảo thứ tự module trong mảng __modules__
        for (let id = 0; id < this.nextId; ++id) {
            let path = this.idToPath[id];
            let rawAst = rawAsts[path];
            let moduleFunc = this._transformModule(rawAst, path, compilerInstance);
            this.modulesList.push(moduleFunc);
        }

        return this._createBundleProgram(absEntry);
    }

    fn _assignId(absPath) {
        if (this.pathToId[absPath] == null) {
            let id = this.nextId;
            this.nextId = this.nextId + 1;
            this.pathToId[absPath] = id;
            this.idToPath[id] = absPath;
        }
    }

    fn _scanImports(ast) {
        let paths = [];
        if (!ast.body) return paths;
        for (let i = 0; i < ast.body.size(); ++i) {
            let stmt = ast.body[i];
            if (stmt.type == "ImportStatement") paths.push(stmt.path.value);
        }
        return paths;
    }

    fn _makeDummyToken(file) {
        return {
            "type": "SYNTHETIC",
            "lexeme": "<linker_generated>",
            "line": 0,
            "col": 0,
            "file": file
        };
    }

    fn _transformModule(ast, currentAbsPath, compiler) {
        let newStatements = [];
        let dummyToken = this._makeDummyToken(currentAbsPath);

        // [FIX 1] KHÔNG tạo let __exports__ = {} ở đây nữa.
        // Nó sẽ được truyền vào từ tham số hàm.
        
        let currentDir = compiler._getDirectoryPath(currentAbsPath);

        for (let i = 0; i < ast.body.size(); ++i) {
            let stmt = ast.body[i];
            if (stmt.type == "ImportStatement") {
                if (stdlib[stmt.path.value]) {
                    newStatements.push(stmt);
                } else {
                    let rawPath = stmt.path.value;
                    let absPath = compiler._resolvePath(rawPath, currentDir);
                    let moduleId = this.pathToId[absPath];
                    
                    if (moduleId == null) {
                        print("[Linker Logic Error] Missing ID for: " + absPath);
                        System.exit(1);
                    }

                    let originToken = stmt.token || dummyToken;
                    let tempVarName = "__mod_" + str(moduleId) + "_" + str(i);
                    
                    // let __mod_X_Y = __loader__(moduleId);
                    newStatements.push({
                        "type": "LetStatement",
                        "token": originToken, 
                        "name": { "type": "Identifier", "name": tempVarName, "token": originToken },
                        "value": {
                            "type": "CallExpression",
                            "token": originToken,
                            "callee": { "type": "Identifier", "name": "__loader__", "token": originToken },
                            "args": [{ "type": "IntegerLiteral", "value": moduleId, "token": originToken }]
                        }
                    });

                    if (stmt.namedImports) {
                        for (let j = 0; j < stmt.namedImports.size(); ++j) {
                            let spec = stmt.namedImports[j];
                            let localName = spec.name;
                            let exportName = spec.name; // Tạm thời giả sử local = export
                            let specToken = spec.token || originToken;

                            if (localName == null) {
                                print("[Linker Error] Import name is null in " + currentAbsPath);
                                System.exit(1);
                            }

                            newStatements.push({
                                "type": "LetStatement",
                                "token": specToken,
                                "name": { "type": "Identifier", "name": localName, "token": specToken },
                                "value": {
                                    "type": "PropertyAccess",
                                    "token": specToken,
                                    "object": { "type": "Identifier", "name": tempVarName, "token": specToken },
                                    "property": { "type": "Identifier", "name": exportName, "token": specToken }
                                }
                            });
                        }
                    }

                    if (stmt.namespaceImport) {
                        let nsToken = stmt.namespaceImport.token || originToken;
                        newStatements.push({
                            "type": "LetStatement",
                            "token": nsToken,
                            "name": { "type": "Identifier", "name": stmt.namespaceImport.name, "token": nsToken },
                            "value": { "type": "Identifier", "name": tempVarName, "token": nsToken }
                        });
                    }
                }

            } else if (stmt.type == "ExportStatement") {
                let originToken = stmt.token || dummyToken;
                
                if (stmt.declaration) {
                    let decl = stmt.declaration;
                    newStatements.push(decl);

                    let name = null;
                    if (decl.type == "LetStatement" || decl.type == "ConstStatement" || 
                        decl.type == "FunctionDeclaration" || decl.type == "FunctionStatement" ||
                        decl.type == "ClassDeclaration" || decl.type == "ClassStatement") {
                        name = decl.name.name;
                    }
                    
                    if (name) {
                        // __exports__.name = name;
                        newStatements.push({
                            "type": "ExpressionStatement",
                            "token": originToken,
                            "expression": {
                                "type": "AssignmentExpression",
                                "token": originToken,
                                "target": { 
                                    "type": "PropertyAccess",
                                    "token": originToken,
                                    "object": { "type": "Identifier", "name": "__exports__", "token": originToken },
                                    "property": { "type": "Identifier", "name": name, "token": originToken }
                                },
                                "op": "=",
                                "value": { "type": "Identifier", "name": name, "token": originToken }
                            }
                        });
                    }
                } else if (stmt.specifiers) {
                    for (let j = 0; j < stmt.specifiers.size(); ++j) {
                        let spec = stmt.specifiers[j];
                        let localName = spec.name;
                        let exportedName = spec.name;
                        let specToken = spec.token || originToken;
                        
                        if (localName == null) {
                            print("[Linker Error] Export name is null in " + currentAbsPath);
                            System.exit(1);
                        }

                        // __exports__.exportedName = localName;
                        newStatements.push({
                            "type": "ExpressionStatement",
                            "token": specToken,
                            "expression": {
                                "type": "AssignmentExpression",
                                "token": specToken,
                                "target": {
                                    "type": "PropertyAccess",
                                    "token": specToken,
                                    "object": { "type": "Identifier", "name": "__exports__", "token": specToken },
                                    "property": { "type": "Identifier", "name": exportedName, "token": specToken }
                                },
                                "op": "=",
                                "value": { "type": "Identifier", "name": localName, "token": specToken }
                            }
                        });
                    }
                }

            } else {
                newStatements.push(stmt);
            }
        }

        // Return __exports__ (để tương thích logic cũ, dù object đã được pass-by-ref)
        newStatements.push({
            "type": "ReturnStatement",
            "token": dummyToken,
            "argument": { "type": "Identifier", "name": "__exports__", "token": dummyToken }
        });

        // [FIX 2] Thêm tham số __exports__ vào FunctionLiteral wrapper
        return {
            "type": "FunctionLiteral",
            "token": dummyToken,
            "name": null, 
            "params": [{ "type": "Identifier", "name": "__exports__", "token": dummyToken }],
            "parameters": [{ "type": "Identifier", "name": "__exports__", "token": dummyToken }], 
            "body": {
                "type": "BlockStatement",
                "token": dummyToken,
                "statements": newStatements, 
                "body": newStatements        
            }
        };
    }

    fn _createBundleProgram(entryAbsPath) {
        let entryId = this.pathToId[entryAbsPath];
        let body = [];
        let dummyToken = this._makeDummyToken("BUNDLE_INTERNAL");

        // 1. let __modules__ = [ ... ];
        // Tạo mảng chứa tất cả các hàm module đã transform
        body.push({
            "type": "LetStatement",
            "token": dummyToken,
            "name": { "type": "Identifier", "name": "__modules__", "token": dummyToken },
            "value": { "type": "ArrayLiteral", "elements": this.modulesList, "token": dummyToken }
        });

        // 2. [FIX] let __cache__ = [null, null, ...];
        // Tạo mảng cache có kích thước cố định bằng số lượng module, điền sẵn giá trị null.
        // Điều này ngăn lỗi "Index out of bounds" khi VM truy cập __cache__[id] lần đầu.
        let cacheElements = [];
        for (let i = 0; i < this.modulesList.size(); ++i) {
            cacheElements.push({ 
                "type": "NullLiteral", 
                "value": null, 
                "token": dummyToken 
            });
        }

        body.push({
            "type": "LetStatement",
            "token": dummyToken,
            "name": { "type": "Identifier", "name": "__cache__", "token": dummyToken },
            "value": { 
                "type": "ArrayLiteral", 
                "elements": cacheElements, // <--- Mảng đã được fill null
                "token": dummyToken 
            } 
        });

        // 3. fn __loader__(id) { ... }
        // Tạo hàm loader (đã được sửa ở bước trước để hỗ trợ circular dependency)
        body.push(this._createLoaderFunction(dummyToken));

        // 4. __loader__(entryId);
        // Gọi module chính để bắt đầu chạy chương trình
        body.push({
            "type": "ExpressionStatement",
            "token": dummyToken,
            "expression": {
                "type": "CallExpression",
                "token": dummyToken,
                "callee": { "type": "Identifier", "name": "__loader__", "token": dummyToken },
                "args": [{ "type": "IntegerLiteral", "value": entryId, "token": dummyToken }]
            }
        });

        // Trả về AST của toàn bộ bundle
        return {
            "type": "Program",
            "token": dummyToken,
            "body": body
        };
    }

    fn _createLoaderFunction(token) {
        let statements = [];
        
        // 1. Kiểm tra cache: if (__cache__[id] != null) return __cache__[id];
        statements.push({
            "type": "IfStatement",
            "token": token,
            "condition": {
                "type": "BinaryExpression",
                "token": token,
                "op": "OP_NEQ", 
                "left": {
                    "type": "IndexExpression",
                    "token": token,
                    "object": { "type": "Identifier", "name": "__cache__", "token": token },
                    "index": { "type": "Identifier", "name": "id", "token": token }
                },
                "right": { "type": "NullLiteral", "token": token }
            },
            "thenBranch": {
                "type": "ReturnStatement",
                "token": token,
                "value": {
                    "type": "IndexExpression",
                    "token": token,
                    "object": { "type": "Identifier", "name": "__cache__", "token": token },
                    "index": { "type": "Identifier", "name": "id", "token": token }
                }
            },
            "elseBranch": null
        });

        // 2. [QUAN TRỌNG] Tạo exports rỗng: let exports = {};
        statements.push({
            "type": "LetStatement",
            "token": token,
            "name": { "type": "Identifier", "name": "exports", "token": token },
            "value": { "type": "ObjectLiteral", "properties": [], "token": token }
        });

        // 3. [QUAN TRỌNG] Lưu cache TRƯỚC khi chạy module: __cache__[id] = exports;
        statements.push({
            "type": "ExpressionStatement",
            "token": token,
            "expression": {
                "type": "AssignmentExpression",
                "token": token,
                "target": { 
                    "type": "IndexExpression",
                    "token": token,
                    "object": { "type": "Identifier", "name": "__cache__", "token": token },
                    "index": { "type": "Identifier", "name": "id", "token": token }
                },
                "op": "=",
                "value": { "type": "Identifier", "name": "exports", "token": token }
            }
        });

        // 4. Lấy hàm module: let modFunc = __modules__[id];
        statements.push({
            "type": "LetStatement",
            "token": token,
            "name": { "type": "Identifier", "name": "modFunc", "token": token },
            "value": {
                "type": "IndexExpression",
                "token": token,
                "object": { "type": "Identifier", "name": "__modules__", "token": token },
                "index": { "type": "Identifier", "name": "id", "token": token }
            }
        });

        // 5. Chạy module với tham số exports: modFunc(exports);
        statements.push({
            "type": "ExpressionStatement",
            "token": token,
            "expression": {
                "type": "CallExpression",
                "token": token,
                "callee": { "type": "Identifier", "name": "modFunc", "token": token },
                "args": [{ "type": "Identifier", "name": "exports", "token": token }]
            }
        });

        // 6. Trả về exports: return exports;
        statements.push({
            "type": "ReturnStatement",
            "token": token,
            "value": { "type": "Identifier", "name": "exports", "token": token }
        });

        return {
            "type": "FunctionStatement",
            "token": token,
            "name": { "type": "Identifier", "name": "__loader__", "token": token },
            "func": {
                "type": "FunctionLiteral",
                "token": token,
                "params": [{ "type": "Identifier", "name": "id", "token": token }],
                "parameters": [{ "type": "Identifier", "name": "id", "token": token }],
                "body": {
                    "type": "BlockStatement",
                    "token": token,
                    "statements": statements, 
                    "body": statements
                }
            }
        };
    }
}