import * as System from "system";
import * as Io from "io";

export class AstLinker {
    fn init() {
        this.pathToId = {};        // Map<AbsolutePath, Int>
        this.idToPath = {};        // Map<Int, AbsolutePath>
        this.modulesList = [];     // Array<FunctionLiteral> (Đúng thứ tự ID)
        this.nextId = 0;
    }

    // compilerInstance: Instance của Compiler để gọi hàm resolve và parse
    fn link(entryPath, compilerInstance) {
        // --- PHASE 1: DISCOVERY & PARSING ---
        // Mục tiêu: Tìm tất cả file cần thiết, gán ID và Parse ra AST thô.
        
        let absEntry = compilerInstance._resolvePath(entryPath, ".");
        let rawAsts = {}; // Map<AbsolutePath, AST>
        
        // Queue chứa các đường dẫn tuyệt đối cần xử lý
        let queue = [absEntry];
        let processed = {}; // Set<AbsolutePath> để tránh vòng lặp vô hạn

        // Gán ID cho Entry Point luôn là 0
        this._assignId(absEntry);

        while (queue.size() > 0) {
            let currentPath = queue.pop(); // Lấy 1 path ra (đã là absolute)
            
            if (processed[currentPath]) continue;
            processed[currentPath] = true;

            // 1.1 Parse file (Sử dụng hàm parseOnly của Compiler - xem bên dưới)
            let ast = compilerInstance.parseOnly(currentPath);
            if (ast == null) {
                print("[Linker Error] Không thể đọc hoặc parse file: " + currentPath);
                System.exit(1);
            }
            rawAsts[currentPath] = ast;

            // 1.2 Quét Import trong AST để tìm dependency con
            let dir = compilerInstance._getDirectoryPath(currentPath);
            let imports = this._scanImports(ast); // Trả về danh sách đường dẫn raw trong import string

            for (let i = 0; i < imports.size(); ++i) {
                let rawImportPath = imports[i];
                
                // QUAN TRỌNG: Resolve ngay lập tức để có Absolute Path
                let absImportPath = compilerInstance._resolvePath(rawImportPath, dir);
                
                if (!Io.fileExists(absImportPath)) {
                     print("[Linker Error] File không tồn tại: " + absImportPath + " (được import từ " + currentPath + ")");
                     System.exit(1);
                }

                // Gán ID nếu chưa có
                this._assignId(absImportPath);
                
                // Đẩy vào queue để xử lý tiếp
                if (!processed[absImportPath]) {
                    queue.push(absImportPath);
                }
            }
        }

        // --- PHASE 2: TRANSFORMATION ---
        // Biến đổi AST thô thành Module Function dựa trên ID đã cấp
        
        // Duyệt theo thứ tự ID từ 0 -> nextId
        for (let id = 0; id < this.nextId; ++id) {
            let path = this.idToPath[id];
            let rawAst = rawAsts[path];
            
            // Transform
            let moduleFunc = this._transformModule(rawAst, path, compilerInstance);
            this.modulesList.push(moduleFunc);
        }

        // --- PHASE 3: BUNDLING ---
        // Tạo Program chính chứa Loader và Mảng Modules
        return this._createBundleProgram(absEntry);
    }

    fn _assignId(absPath) {
        if (this.pathToId[absPath] == null) {
            let id = this.nextId;
            this.nextId = this.nextId + 1;
            this.pathToId[absPath] = id;
            this.idToPath[id] = absPath;
        }
    }

    // Helper: Chỉ quét lấy string path từ ImportStatement để discovery
    fn _scanImports(ast) {
        let paths = [];
        if (!ast.body) return paths;
        for (let i = 0; i < ast.body.size(); ++i) {
            let stmt = ast.body[i];
            if (stmt.type == "ImportStatement") {
                paths.push(stmt.path.value);
            }
        }
        return paths;
    }

    // Biến đổi AST của 1 module
    fn _transformModule(ast, currentAbsPath, compiler) {
        let newStatements = [];

        // 1. let __exports__ = {};
        newStatements.push({
            "type": "LetStatement",
            "name": { "type": "Identifier", "name": "__exports__" },
            "value": { "type": "ObjectLiteral", "properties": [] }
        });

        let currentDir = compiler._getDirectoryPath(currentAbsPath);

        for (let i = 0; i < ast.body.size(); ++i) {
            let stmt = ast.body[i];

            if (stmt.type == "ImportStatement") {
                // Xử lý Import: import ... from "path"
                // Phải resolve lại path để lấy đúng ID đã cấp ở Phase 1
                let rawPath = stmt.path.value;
                let absPath = compiler._resolvePath(rawPath, currentDir);
                let moduleId = this.pathToId[absPath];
                
                // Assert chắc chắn có ID (vì Phase 1 đã quét hết rồi)
                if (moduleId == null) {
                    print("[Linker Logic Error] Không tìm thấy ID cho path: " + absPath);
                    System.exit(1);
                }

                // Tạo biến tạm: let __mod_X_Y = __loader__(ID);
                let tempVarName = "__mod_" + str(moduleId) + "_" + str(i);
                
                newStatements.push({
                    "type": "LetStatement",
                    "name": { "type": "Identifier", "name": tempVarName },
                    "value": {
                        "type": "CallExpression",
                        "callee": { "type": "Identifier", "name": "__loader__" },
                        "args": [{ "type": "IntegerLiteral", "value": moduleId }]
                    }
                });

                // Xử lý Named Imports: import { A, B }
                if (stmt.namedImports) {
                    for (let j = 0; j < stmt.namedImports.size(); ++j) {
                        let importSpecifier = stmt.namedImports[j];
                        let localName = importSpecifier.resolution ? importSpecifier.resolution.name : importSpecifier.name.name; // Fallback name
                        let exportName = importSpecifier.name.name; 

                        // let localName = __mod_X_Y.exportName;
                        newStatements.push({
                            "type": "LetStatement",
                            "name": { "type": "Identifier", "name": localName },
                            "value": {
                                "type": "PropertyAccess",
                                "object": { "type": "Identifier", "name": tempVarName },
                                "property": { "type": "Identifier", "name": exportName }
                            }
                        });
                    }
                }

                // Xử lý Namespace Import: import * as M
                if (stmt.namespaceImport) {
                    // let M = __mod_X_Y;
                    newStatements.push({
                        "type": "LetStatement",
                        "name": { "type": "Identifier", "name": stmt.namespaceImport.name },
                        "value": { "type": "Identifier", "name": tempVarName }
                    });
                }
                
                // ImportAll (nếu có logic riêng) hoặc Import side-effect (chỉ chạy loader) -> Đã xong.

            } else if (stmt.type == "ExportStatement") {
                // Xử lý Export: export let x = ...
                // Unwraps declaration
                let decl = stmt.declaration;
                newStatements.push(decl); // Đẩy declaration gốc vào body

                // Tìm tên biến được export
                let name = null;
                if (decl.type == "LetStatement") name = decl.name.name;
                else if (decl.type == "FunctionStatement") name = decl.name.name;
                else if (decl.type == "ClassStatement") name = decl.name.name;
                
                if (name != null) {
                    // __exports__.name = name;
                    newStatements.push({
                        "type": "ExpressionStatement",
                        "expression": {
                            "type": "AssignmentExpression",
                            "target": {
                                "type": "PropertyAccess",
                                "object": { "type": "Identifier", "name": "__exports__" },
                                "property": { "type": "Identifier", "name": name }
                            },
                            "value": { "type": "Identifier", "name": name }
                        }
                    });
                }

            } else {
                // Giữ nguyên các statement khác
                newStatements.push(stmt);
            }
        }

        // return __exports__;
        newStatements.push({
            "type": "ReturnStatement",
            "value": { "type": "Identifier", "name": "__exports__" }
        });

        // Bọc code vào FunctionLiteral
        return {
            "type": "FunctionLiteral",
            "parameters": [], 
            "body": {
                "type": "BlockStatement",
                "statements": newStatements
            }
        };
    }

    fn _createBundleProgram(entryAbsPath) {
        let entryId = this.pathToId[entryAbsPath];
        let body = [];

        // 1. let __modules__ = [ func_0, func_1, ... ];
        body.push({
            "type": "LetStatement",
            "name": { "type": "Identifier", "name": "__modules__" },
            "value": {
                "type": "ArrayLiteral",
                "elements": this.modulesList
            }
        });

        // 2. let __cache__ = []; (Cache kết quả exports)
        body.push({
            "type": "LetStatement",
            "name": { "type": "Identifier", "name": "__cache__" },
            "value": { "type": "ArrayLiteral", "elements": [] } // Empty array, sẽ auto grow hoặc dùng NEW_ARRAY nếu cần size
        });

        // 3. fn __loader__(id) { ... }
        body.push(this._createLoaderFunction());

        // 4. __loader__(entryId); (Entry point execution)
        body.push({
            "type": "ExpressionStatement",
            "expression": {
                "type": "CallExpression",
                "callee": { "type": "Identifier", "name": "__loader__" },
                "args": [{ "type": "IntegerLiteral", "value": entryId }]
            }
        });

        return {
            "type": "Program",
            "body": body
        };
    }

    // Tạo node FunctionStatement cho Loader
    fn _createLoaderFunction() {
        /*
        fn __loader__(id) {
            // Check cache
            if (__cache__[id] != null) {
                return __cache__[id];
            }
            // Execute module
            let modFunc = __modules__[id];
            let exported = modFunc();
            
            // Save cache
            __cache__[id] = exported;
            return exported;
        }
        */
        
        let statements = [];

        // if (__cache__[id] != null) return __cache__[id];
        statements.push({
            "type": "IfStatement",
            "condition": {
                "type": "BinaryExpression",
                "op": "NEQ", // CodeGen map string "NEQ" -> OpCodes.NEQ [cite: 467]
                "left": {
                    "type": "IndexExpression",
                    "object": { "type": "Identifier", "name": "__cache__" },
                    "index": { "type": "Identifier", "name": "id" }
                },
                "right": { "type": "NullLiteral" }
            },
            "thenBranch": {
                "type": "ReturnStatement",
                "value": {
                    "type": "IndexExpression",
                    "object": { "type": "Identifier", "name": "__cache__" },
                    "index": { "type": "Identifier", "name": "id" }
                }
            },
            "elseBranch": null
        });

        // let modFunc = __modules__[id];
        statements.push({
            "type": "LetStatement",
            "name": { "type": "Identifier", "name": "modFunc" },
            "value": {
                "type": "IndexExpression",
                "object": { "type": "Identifier", "name": "__modules__" },
                "index": { "type": "Identifier", "name": "id" }
            }
        });

        // let exported = modFunc();
        statements.push({
            "type": "LetStatement",
            "name": { "type": "Identifier", "name": "exported" },
            "value": {
                "type": "CallExpression",
                "callee": { "type": "Identifier", "name": "modFunc" },
                "args": []
            }
        });

        // __cache__[id] = exported;
        statements.push({
            "type": "ExpressionStatement",
            "expression": {
                "type": "AssignmentExpression",
                "target": {
                    "type": "IndexExpression",
                    "object": { "type": "Identifier", "name": "__cache__" },
                    "index": { "type": "Identifier", "name": "id" }
                },
                "value": { "type": "Identifier", "name": "exported" }
            }
        });

        // return exported;
        statements.push({
            "type": "ReturnStatement",
            "value": { "type": "Identifier", "name": "exported" }
        });

        return {
            "type": "FunctionStatement",
            "name": { "type": "Identifier", "name": "__loader__" },
            "func": {
                "type": "FunctionLiteral",
                "parameters": [{ "type": "Identifier", "name": "id" }], // Parameter node
                "body": {
                    "type": "BlockStatement",
                    "statements": statements
                }
            }
        };
    }
}