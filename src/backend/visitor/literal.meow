import * as String from "string";
import * as Emitter from "backend/emitter.meow";
import { OpCodes } from "backend/opCodes.meow";

fn _emitConst(cg, value) {
    let constIdx = cg.currentState.pool.add(value);

    let reg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_CONST, [reg, constIdx]);
    return reg;
}

export fn visitIntegerLiteral(cg, node) {
    let reg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [reg, node.value]);
    return reg;
}

export fn visitStringLiteral(cg, node) {
    return _emitConst(cg, node.value);
}

export fn visitRealLiteral(cg, node) {
    return _emitConst(cg, node.value);
}

export fn visitBooleanLiteral(cg, node) {
    let reg = cg.currentState.allocator.ralloc();
    let opcode = node.value ? OpCodes.LOAD_TRUE : OpCodes.LOAD_FALSE;
    Emitter.emit(cg.currentState.proto, opcode, [reg]);
    return reg;
}

export fn visitNullLiteral(cg, node) {
    let reg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_NULL, [reg]);
    return reg;
}

export fn visitArrayLiteral(cg, node) {
    let count = node.elements.size();
    if (count == 0) {
        let dst = cg.currentState.allocator.ralloc();
        Emitter.emit(cg.currentState.proto, OpCodes.NEW_ARRAY, [dst, 0, 0]);
        return dst;
    }

    let startReg = cg.currentState.allocator.rallocBlock(count);
    
    for (let i = 0; i < count; ++i) {
        let elemReg = cg.visitExpression(node.elements[i]);
        let targetReg = startReg + i;
        if (elemReg != targetReg) {
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, elemReg]);
        }
    }

    let dstReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.NEW_ARRAY, [dstReg, startReg, count]);
    
    return dstReg;
}

export let visitObjectLiteral = fn(cg, node) {
    let count = node.properties.size();
    if (count == 0) {
        let dst = cg.currentState.allocator.ralloc();
        Emitter.emit(cg.currentState.proto, OpCodes.NEW_HASH, [dst, 0, 0]);
        return dst;
    }

    let startReg = cg.currentState.allocator.rallocBlock(count * 2);
    let targetKeyReg = 0;
    let targetValReg = 0;

    for (let i = 0; i < count; ++i) {
        let pair = node.properties[i];
        let keyNode = pair.key;
        let valNode = pair.value;

        targetKeyReg = startReg + i * 2;
        targetValReg = startReg + i * 2 + 1;

        if (keyNode.type == 'StringLiteral') {
            let constIdx = cg.currentState.pool.add(keyNode.value);
            cg.currentState.allocator.withTemp(fn(tempReg) {
                Emitter.emit(cg.currentState.proto, OpCodes.LOAD_CONST, [tempReg, constIdx]);
                if (tempReg != targetKeyReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetKeyReg, tempReg]);
                }
            });
        } else if (keyNode.type == 'Identifier') {
            let constIdx = cg.currentState.pool.add(keyNode.name);
            cg.currentState.allocator.withTemp(fn(tempReg) {
                Emitter.emit(cg.currentState.proto, OpCodes.LOAD_CONST, [tempReg, constIdx]);
                if (tempReg != targetKeyReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetKeyReg, tempReg]);
                }
            });
        } else {
            let keyReg = cg.visitExpression(keyNode);
            if (keyReg != targetKeyReg) {
                Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetKeyReg, keyReg]);
            }
        }

        let valReg = cg.visitExpression(valNode);
        if (valReg != targetValReg) {
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetValReg, valReg]);
        }
    }

    let dstReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.NEW_HASH, [dstReg, startReg, count]);
    return dstReg;
};

export let visitFunctionLiteral = fn(cg, node) {
    let descriptiveName;
    if (node.name) { 
        let safeName = String.replace(node.name, "@", "_");
        safeName = String.replace(safeName, " ", "_");
        descriptiveName = safeName;
    } else { 
        descriptiveName = Emitter.createAnonymousFunctionName();
    }
    
    let parentSource = (cg.currentState && cg.currentState.proto && cg.currentState.proto.sourceName) ? cg.currentState.proto.sourceName : "anon_parent";
    let funcName = '@' + descriptiveName + '_' + parentSource + '_' + str(cg.currentState ? cg.currentState.proto.code.size() : 0);
    
    cg.enterState(funcName);
    let paramScope = cg.currentState.scope[0];
    
    if (cg.isInsideClass) {
        cg.currentState.allocator.ralloc(); 
    }

    let wasInsideClass = cg.isInsideClass;
    cg.isInsideClass = false;

    for (paramNode in node.parameters) {
        assert(paramNode.resolution && paramNode.resolution.type == "local", "Lỗi: Tham số " + paramNode.name + " không được resolve là local");
        
        let localSlot = paramNode.resolution.symbol.index;
        
        let reg = cg.currentState.allocator.ralloc();
        
        cg.currentState.localIndexToReg[localSlot] = reg;
        cg.currentState.regToLocalIndex[str(reg)] = localSlot;
        
        paramScope[paramNode.name] = localSlot;
    }

    cg.visitStatement(node.body);
    
    let childProto = cg.exitState();

    cg.isInsideClass = wasInsideClass;

    let upvalues = node.resolved_upvalues;
    if (upvalues && upvalues.size() > 0) {
        childProto.upvalueDescs = []; 
        childProto.numUpvalues = upvalues.size();

        for (up in upvalues) {
            if (up.isLocal) {
                let localSlot = up.index; 
                
                let registerToCapture = cg.currentState.localIndexToReg[localSlot];
                
                assert(registerToCapture != null, "Lỗi CodeGen: Không thể map upvalue local slot " + str(localSlot) + " sang register.");
                
                cg.currentState.capturedLocals[localSlot] = true;
                
                childProto.upvalueDescs.push({ "isLocal": true, "index": registerToCapture });
            } else {
                childProto.upvalueDescs.push({ "isLocal": false, "index": up.index });
            }
        }
    }

    assert(childProto.sourceName && childProto.sourceName.size() > 3, "Bad childProto.sourceName after visitFunctionLiteral");

    cg.protos[childProto.sourceName] = childProto;
    let parentPool = cg.currentState.pool;
    let protoIdx = parentPool.add(childProto);

    let destReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.CLOSURE, [destReg, protoIdx]);

    return destReg;
};

export fn visitTemplateLiteral(cg, node) {
    if (node.parts.size() == 0) {
        return _emitConst(cg, "");
    }

    let resultReg = cg.visitExpression(node.parts[0]);

    for (let i = 1; i < node.parts.size(); ++i) {
        let partReg = cg.visitExpression(node.parts[i]);
        Emitter.emit(cg.currentState.proto, OpCodes.ADD, [resultReg, resultReg, partReg]);

    }

    return resultReg;
}