import * as Emitter from "backend/emitter.meow";
import { OpCodes } from "backend/opCodes.meow";
import { TokenType, tokenTypeToString, stringToTokenType } from "frontend/token.meow";

export fn visitIdentifier(cg, node) {
    assert(node.resolution, "Lỗi: visitIdentifier không tìm thấy 'resolution' cho '" + node.name + "'!");
    let resolution = node.resolution;
    
    let destReg = cg.currentState.allocator.ralloc();

    if (resolution.type == "local") {
        let localSlot = resolution.symbol.index;
        
        let reg = cg.currentState.localIndexToReg[localSlot];
        
        assert(reg != null, "Lỗi CodeGen: Không tìm thấy thanh ghi cho local slot " + str(localSlot) + " (biến '" + node.name + "')");
        
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, reg]);
        
    } else if (resolution.type == "upvalue") {
        Emitter.emit(cg.currentState.proto, OpCodes.GET_UPVALUE, [destReg, resolution.index]);
        
    } else { 
        let constIdx = cg.currentState.pool.add(resolution.name);
        Emitter.emit(cg.currentState.proto, OpCodes.GET_GLOBAL, [destReg, constIdx]);
    }
    
    return destReg;
}

export fn visitBinaryExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    if (node.op == TokenType.OP_LOGICAL_AND) {
        let endLabel = Emitter.createLabel("L_AND_END");
        let destReg = cg.currentState.allocator.ralloc();
        let leftReg = cg.visitExpression(node.left);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, leftReg]);
        Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [leftReg, {"label": endLabel}]);
        let rightReg = cg.visitExpression(node.right);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, rightReg]);
        Emitter.defineLabel(cg.currentState.proto, endLabel);
        return destReg;
    }

    if (node.op == TokenType.OP_LOGICAL_OR) {
        let endLabel = Emitter.createLabel("L_OR_END");
        let destReg = cg.currentState.allocator.ralloc();
        let leftReg = cg.visitExpression(node.left);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, leftReg]);
        Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_TRUE, [leftReg, {"label": endLabel}]);
        let rightReg = cg.visitExpression(node.right);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, rightReg]);
        Emitter.defineLabel(cg.currentState.proto, endLabel);
        return destReg;
    }
    
    let opMap = {
        [TokenType.OP_PLUS]: OpCodes.ADD,
        [TokenType.OP_MINUS]: OpCodes.SUB,
        [TokenType.OP_MULTIPLY]: OpCodes.MUL,
        [TokenType.OP_DIVIDE]: OpCodes.DIV,
        [TokenType.OP_MODULO]: OpCodes.MOD,
        [TokenType.OP_EXPONENT]: OpCodes.POW,
        [TokenType.OP_EQ]: OpCodes.EQ,
        [TokenType.OP_NEQ]: OpCodes.NEQ,
        [TokenType.OP_LT]: OpCodes.LT,
        [TokenType.OP_GT]: OpCodes.GT,
        [TokenType.OP_LE]: OpCodes.LE,
        [TokenType.OP_GE]: OpCodes.GE,
        [TokenType.OP_BIT_AND]: OpCodes.BIT_AND,
        [TokenType.OP_BIT_OR]: OpCodes.BIT_OR,
        [TokenType.OP_BIT_XOR]: OpCodes.BIT_XOR,
        [TokenType.OP_LSHIFT]: OpCodes.LSHIFT,
        [TokenType.OP_RSHIFT]: OpCodes.RSHIFT
    };
    let opcode = opMap[node.op];
    assert(opcode, "Lỗi: Toán tử nhị phân không được hỗ trợ: " + node.op);

    let destReg = cg.currentState.allocator.ralloc();
    let leftReg = cg.visitExpression(node.left);
    let rightReg = cg.visitExpression(node.right);
    Emitter.emit(cg.currentState.proto, opcode, [destReg, leftReg, rightReg]);
    return destReg;
}

export fn visitUnaryExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let opMap = { 
        [TokenType.OP_MINUS]: OpCodes.NEG,
        [TokenType.OP_LOGICAL_NOT]: OpCodes.NOT,
        [TokenType.OP_BIT_NOT]: OpCodes.BIT_NOT
    };
    let opcode = opMap[node.op];
    assert(opcode, "Lỗi: Toán tử một ngôi không được hỗ trợ: " + node.op);

    let destReg = cg.currentState.allocator.ralloc();
    let operandReg = cg.visitExpression(node.operand);
    Emitter.emit(cg.currentState.proto, opcode, [destReg, operandReg]);
    return destReg;
}

export fn visitCallExpression(cg, node) {

    let destReg = cg.currentState.allocator.ralloc();


    let savedCalleeReg = cg.currentState.allocator.ralloc();

    let calleeTempReg = cg.visitExpression(node.callee);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [savedCalleeReg, calleeTempReg]);

    let argc = node.args.size();
    let tempArgRegs = [];

    for (let i = 0; i < argc; ++i) {
        let tempReg = cg.visitExpression(node.args[i]);
        tempArgRegs.push(tempReg);
    }

    let argStartReg = cg.currentState.allocator.rallocBlock(argc > 0 ? argc : 1);

    if (argc > 0) {
        let minSrc = tempArgRegs[0];
        let maxSrc = tempArgRegs[0];
        for (let k = 1; k < tempArgRegs.size(); ++k) {
            if (tempArgRegs[k] < minSrc) minSrc = tempArgRegs[k];
            if (tempArgRegs[k] > maxSrc) maxSrc = tempArgRegs[k];
        }

        let destStart = argStartReg;
        let destEnd = argStartReg + argc - 1;
        let overlap = !(destEnd < minSrc || destStart > maxSrc);

        if (overlap && destStart > minSrc) {
            for (let i = argc - 1; i >= 0; --i) {
                let targetReg = argStartReg + i;
                let sourceReg = tempArgRegs[i];
                if (targetReg != sourceReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, sourceReg]);
                }
            }
        } else {
            for (let i = 0; i < argc; ++i) {
                let targetReg = argStartReg + i;
                let sourceReg = tempArgRegs[i];
                if (targetReg != sourceReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, sourceReg]);
                }
            }
        }
    }

    Emitter.emit(cg.currentState.proto, OpCodes.CALL, [destReg, savedCalleeReg, argStartReg, argc]);

    return destReg;
}

export fn visitAssignmentExpression(cg, node) {
    let targetNode = node.target;
    
    if (targetNode.type == "Identifier") {
        
        assert(targetNode.resolution, "Lỗi: visitAssignment không tìm thấy 'resolution' cho '" + targetNode.name + "'!");
        let resolution = targetNode.resolution;
        
        let valueReg = cg.visitExpression(node.value);

        if (resolution.type == "local") {
            let localSlot = resolution.symbol.index;
            
            let reg = cg.currentState.localIndexToReg[localSlot];
            assert(reg != null, "Lỗi CodeGen: Gán cho local slot " + str(localSlot) + " không tìm thấy thanh ghi");
            
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [reg, valueReg]);
            
        } else if (resolution.type == "upvalue") {
            Emitter.emit(cg.currentState.proto, OpCodes.SET_UPVALUE, [resolution.index, valueReg]);
            
        } else { 
            let constIdx = cg.currentState.pool.add(resolution.name);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [constIdx, valueReg]);
        }
        
        return valueReg;
        
    } else if (targetNode.type == "PropertyAccess") {
        let objReg = cg.visitExpression(targetNode.object);
        let valueReg = cg.visitExpression(node.value);
        let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, valueReg]);
        return valueReg;
        
    } else if (targetNode.type == "IndexExpression") {
        let objReg = cg.visitExpression(targetNode.object);
        let indexReg = cg.visitExpression(targetNode.index);
        let valueReg = cg.visitExpression(node.value);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_INDEX, [objReg, indexReg, valueReg]);
        return valueReg;
        
    } else {
        assert(false, "Lỗi: Đích của phép gán không được hỗ trợ: " + targetNode.type);
    }
    
    return -1;
}

export fn visitPrefixUpdateExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let destReg = cg.currentState.allocator.ralloc();
    let targetNode = node.operand;
    let op = (node.op == TokenType.OP_INCREMENT) ? OpCodes.ADD : OpCodes.SUB;

    cg.currentState.allocator.withTemp(fn(oneReg) {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [oneReg, 1]);
        if (targetNode.type == "Identifier") {
            assert(targetNode.resolution, "Lỗi: visitPrefixUpdateExpression không tìm thấy 'resolution' cho '" + targetNode.name + "'!");
            let resolution = targetNode.resolution;
            assert(resolution.type == "local", "Toán tử ++/-- chỉ hỗ trợ biến local.");
            
            let localSlot = resolution.symbol.index;
            let targetReg = cg.currentState.localIndexToReg[localSlot];
            assert(targetReg != null, "Lỗi CodeGen: Không tìm thấy thanh ghi cho local slot " + str(localSlot));

            Emitter.emit(cg.currentState.proto, op, [targetReg, targetReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, targetReg]);
        } else if (targetNode.type == "PropertyAccess") {            let objReg = cg.visitExpression(targetNode.object);
            let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
            let currentValReg = cg.currentState.allocator.ralloc();
            Emitter.emit(cg.currentState.proto, OpCodes.GET_PROP, [currentValReg, objReg, propNameIdx]);
            Emitter.emit(cg.currentState.proto, op, [currentValReg, currentValReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, currentValReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, currentValReg]);
        }
    });
    return destReg;
}

export fn visitPostfixUpdateExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let destReg = cg.currentState.allocator.ralloc();
    let targetNode = node.operand;
    let op = (node.op == TokenType.OP_INCREMENT) ? OpCodes.ADD : OpCodes.SUB;

    cg.currentState.allocator.withTemp(fn(oneReg) {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [oneReg, 1]);
        if (targetNode.type == "Identifier") {
            assert(targetNode.resolution, "Lỗi: visitPostfixUpdateExpression không tìm thấy 'resolution' cho '" + targetNode.name + "'!");
            let resolution = targetNode.resolution;
            assert(resolution.type == "local", "Toán tử ++/-- chỉ hỗ trợ biến local.");
            
            let localSlot = resolution.symbol.index;
            let targetReg = cg.currentState.localIndexToReg[localSlot];
            assert(targetReg != null, "Lỗi CodeGen: Không tìm thấy thanh ghi cho local slot " + str(localSlot));

            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, targetReg]);
            Emitter.emit(cg.currentState.proto, op, [targetReg, targetReg, oneReg]);
        } else if (targetNode.type == "PropertyAccess") {            let objReg = cg.visitExpression(targetNode.object);
            let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
            Emitter.emit(cg.currentState.proto, OpCodes.GET_PROP, [destReg, objReg, propNameIdx]);
            let newValReg = cg.currentState.allocator.ralloc();
            Emitter.emit(cg.currentState.proto, op, [newValReg, destReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, newValReg]);
        }
    });
    return destReg;
}

export fn visitIndexExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    let objReg = cg.visitExpression(node.object);
    let indexReg = cg.visitExpression(node.index);
    Emitter.emit(cg.currentState.proto, OpCodes.GET_INDEX, [destReg, objReg, indexReg]);
    return destReg;
}

export fn visitPropertyAccess(cg, node) {

    let savedObjReg = cg.currentState.allocator.ralloc();

    let objTempReg = cg.visitExpression(node.object);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [savedObjReg, objTempReg]);


    let destReg = cg.currentState.allocator.ralloc();
    let propNameIdx = cg.currentState.pool.add(node.property.name);
    let opcode = OpCodes.GET_PROP;
    if (node.object.type == "Identifier" && (cg.currentState.moduleVariables[node.object.name] != null)) {
        opcode = OpCodes.GET_EXPORT;
    }

    Emitter.emit(cg.currentState.proto, opcode, [destReg, savedObjReg, propNameIdx]);


    return destReg;
}


export fn visitThisExpression(cg, node) {
    let thisReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [thisReg, 0]);
    return thisReg;
}

export fn visitSuperExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    let nameIdx = cg.currentState.pool.add(node.method.name);
    Emitter.emit(cg.currentState.proto, OpCodes.GET_SUPER, [destReg, nameIdx]);
    return destReg;
}

export fn visitNewExpression(cg, node) {
    return cg.visitExpression(node.expression);
}

export fn visitTernaryExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    let elseLabel = Emitter.createLabel("L_TERNARY_ELSE");
    let endLabel = Emitter.createLabel("L_TERNARY_END");

    let condReg = cg.visitExpression(node.condition);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": elseLabel}]);

    let thenReg = cg.visitExpression(node.thenBranch);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, thenReg]);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": endLabel}]);

    Emitter.defineLabel(cg.currentState.proto, elseLabel);
    let elseReg = cg.visitExpression(node.elseBranch);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, elseReg]);

    Emitter.defineLabel(cg.currentState.proto, endLabel);
    return destReg;
}

export fn visitPropertyAssignment(cg, node) {
    let valueReg = cg.visitExpression(node.value);
        
    let objReg = cg.visitExpression(node.targetObj);
    
    let propNameIdx = cg.currentState.pool.add(node.property.name);
    
    Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, valueReg]);
        
    return valueReg;
}