import * as Emitter from "../emitter.meow";
import { OpCodes } from "../opCodes.meow";
import { TokenType, tokenTypeToString, stringToTokenType } from "../../frontend/token.meow";

let binaryOps = {
    [TokenType.OP_PLUS]:      fn(l, r) { return l + r; }, [TokenType.OP_MINUS]:     fn(l, r) { return l - r; },
    [TokenType.OP_MULTIPLY]:  fn(l, r) { return l * r; }, [TokenType.OP_DIVIDE]:    fn(l, r) { return l / r; },
    [TokenType.OP_MODULO]:    fn(l, r) { return l % r; }, [TokenType.OP_EXPONENT]:  fn(l, r) { return l ** r; },
    [TokenType.OP_EQ]:        fn(l, r) { return l == r; }, [TokenType.OP_NEQ]:      fn(l, r) { return l != r; },
    [TokenType.OP_LT]:        fn(l, r) { return l < r; }, [TokenType.OP_GT]:       fn(l, r) { return l > r; },
    [TokenType.OP_LE]:        fn(l, r) { return l <= r; }, [TokenType.OP_GE]:      fn(l, r) { return l >= r; },
    [TokenType.OP_BIT_AND]:   fn(l, r) { return l & r; }, [TokenType.OP_BIT_OR]:    fn(l, r) { return l | r; },
    [TokenType.OP_BIT_XOR]:   fn(l, r) { return l ^ r; }, [TokenType.OP_LSHIFT]:    fn(l, r) { return l << r; },
    [TokenType.OP_RSHIFT]:    fn(l, r) { return l >> r; },
};
let unaryOps = {
    [TokenType.OP_MINUS]:       fn(r) { return -r; }, [TokenType.OP_LOGICAL_NOT]: fn(r) { return !r; },
    [TokenType.OP_BIT_NOT]:     fn(r) { return ~r; },
};
fn isLiteral(type) { return type == "IntegerLiteral" || type == "RealLiteral" || type == "StringLiteral" || type == "BooleanLiteral" || type == "NullLiteral"; }
fn toNode(value) {
    let t = typeof(value);
    if (t == "int") return { "type": "IntegerLiteral", "value": value };
    if (t == "real") return { "type": "RealLiteral", "value": value };
    if (t == "string") return { "type": "StringLiteral", "value": value };
    if (t == "bool") return { "type": "BooleanLiteral", "value": value };
    if (t == "null") return { "type": "NullLiteral" };
    return null;
}
fn handleBinary(node) {
    if (!node || node.type != "BinaryExpression") return node;
    node.left = handleBinary(node.left); node.right = handleBinary(node.right);
    if (isLiteral(node.left.type) && isLiteral(node.right.type)) {
        let func = binaryOps[node.op];
        if (func) return toNode(func(node.left.value, node.right.value));
    }
    return node;
}
fn handleUnary(node) {
    if (!node || node.type != "UnaryExpression") return node;
    node.right = handleUnary(node.right);
    if (isLiteral(node.right.type)) {
        let func = unaryOps[node.op];
        if (func) return toNode(func(node.right.value));
    }
    return node;
}


export fn visitIdentifier(cg, node) {
    let resolution = cg.findVariable(node.name);
    let destReg = cg.currentState.allocator.ralloc();

    if (resolution.type == "local") {
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, resolution.index]);
    } else if (resolution.type == "upvalue") {
        Emitter.emit(cg.currentState.proto, OpCodes.GET_UPVALUE, [destReg, resolution.index]);
    } else {
        let constIdx = cg.currentState.pool.add(resolution.name);
        Emitter.emit(cg.currentState.proto, OpCodes.GET_GLOBAL, [destReg, constIdx]);
    }
    return destReg;
}

export fn visitBinaryExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    if (node.op == TokenType.OP_LOGICAL_AND) {
        let endLabel = Emitter.createLabel("L_AND_END");
        let destReg = cg.currentState.allocator.ralloc();
        cg.currentState.allocator.beginScope();
        let leftReg = cg.visitExpression(node.left);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, leftReg]);
        Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [leftReg, {"label": endLabel}]);
        let rightReg = cg.visitExpression(node.right);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, rightReg]);
        cg.currentState.allocator.endScope();
        Emitter.defineLabel(cg.currentState.proto, endLabel);
        return destReg;
    }

    if (node.op == TokenType.OP_LOGICAL_OR) {
        let endLabel = Emitter.createLabel("L_OR_END");
        let destReg = cg.currentState.allocator.ralloc();
        cg.currentState.allocator.beginScope();
        let leftReg = cg.visitExpression(node.left);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, leftReg]);
        Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_TRUE, [leftReg, {"label": endLabel}]);
        let rightReg = cg.visitExpression(node.right);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, rightReg]);
        cg.currentState.allocator.endScope();
        Emitter.defineLabel(cg.currentState.proto, endLabel);
        return destReg;
    }
    
    let opMap = {
        [TokenType.OP_PLUS]: OpCodes.ADD, [TokenType.OP_MINUS]: OpCodes.SUB, [TokenType.OP_MULTIPLY]: OpCodes.MUL,
        [TokenType.OP_DIVIDE]: OpCodes.DIV, [TokenType.OP_MODULO]: OpCodes.MOD, [TokenType.OP_EXPONENT]: OpCodes.POW,
        [TokenType.OP_EQ]: OpCodes.EQ, [TokenType.OP_NEQ]: OpCodes.NEQ, [TokenType.OP_LT]: OpCodes.LT,
        [TokenType.OP_GT]: OpCodes.GT, [TokenType.OP_LE]: OpCodes.LE, [TokenType.OP_GE]: OpCodes.GE,
        [TokenType.OP_BIT_AND]: OpCodes.BIT_AND, [TokenType.OP_BIT_OR]: OpCodes.BIT_OR,
        [TokenType.OP_BIT_XOR]: OpCodes.BIT_XOR, [TokenType.OP_LSHIFT]: OpCodes.LSHIFT, [TokenType.OP_RSHIFT]: OpCodes.RSHIFT
    };
    let opcode = opMap[node.op];
    assert(opcode, "Lỗi: Toán tử nhị phân không được hỗ trợ: " + node.op);

    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let leftReg = cg.visitExpression(node.left);
    let rightReg = cg.visitExpression(node.right);
    Emitter.emit(cg.currentState.proto, opcode, [destReg, leftReg, rightReg]);
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitUnaryExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let opMap = { [TokenType.OP_MINUS]: OpCodes.NEG, [TokenType.OP_LOGICAL_NOT]: OpCodes.NOT, [TokenType.OP_BIT_NOT]: OpCodes.BIT_NOT };
    let opcode = opMap[node.op];
    assert(opcode, "Lỗi: Toán tử một ngôi không được hỗ trợ: " + node.op);

    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let operandReg = cg.visitExpression(node.operand);
    Emitter.emit(cg.currentState.proto, opcode, [destReg, operandReg]);
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitCallExpression(cg, node) {

    let destReg = cg.currentState.allocator.ralloc();


    let savedCalleeReg = cg.currentState.allocator.ralloc();

    cg.currentState.allocator.beginScope();

    let calleeTempReg = cg.visitExpression(node.callee);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [savedCalleeReg, calleeTempReg]);

    let argc = node.args.length;
    let tempArgRegs = [];

    for (let i = 0; i < argc; ++i) {
        let tempReg = cg.visitExpression(node.args[i]);
        tempArgRegs.push(tempReg);
    }

    let argStartReg = cg.currentState.allocator.rallocBlock(argc > 0 ? argc : 1);

    if (argc > 0) {
        let minSrc = tempArgRegs[0];
        let maxSrc = tempArgRegs[0];
        for (let k = 1; k < tempArgRegs.length; ++k) {
            if (tempArgRegs[k] < minSrc) minSrc = tempArgRegs[k];
            if (tempArgRegs[k] > maxSrc) maxSrc = tempArgRegs[k];
        }

        let destStart = argStartReg;
        let destEnd = argStartReg + argc - 1;
        let overlap = !(destEnd < minSrc || destStart > maxSrc);

        if (overlap && destStart > minSrc) {
            for (let i = argc - 1; i >= 0; --i) {
                let targetReg = argStartReg + i;
                let sourceReg = tempArgRegs[i];
                if (targetReg != sourceReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, sourceReg]);
                }
            }
        } else {
            for (let i = 0; i < argc; ++i) {
                let targetReg = argStartReg + i;
                let sourceReg = tempArgRegs[i];
                if (targetReg != sourceReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, sourceReg]);
                }
            }
        }
    }

    Emitter.emit(cg.currentState.proto, OpCodes.CALL, [destReg, savedCalleeReg, argStartReg, argc]);

    cg.currentState.allocator.endScope();

    cg.currentState.allocator.free(savedCalleeReg);

    return destReg;
}


export fn visitAssignmentExpression(cg, node) {
    let targetNode = node.target;
    cg.currentState.allocator.beginScope();



    if (targetNode.type == "Identifier") {


        let valueReg = cg.visitExpression(node.value);
        let resolution = cg.findVariable(targetNode.name);

        if (resolution.type == "local") {
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [resolution.index, valueReg]);
        } else if (resolution.type == "upvalue") {
            Emitter.emit(cg.currentState.proto, OpCodes.SET_UPVALUE, [resolution.index, valueReg]);
        } else {
            let constIdx = cg.currentState.pool.add(resolution.name);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [constIdx, valueReg]);
        }
        cg.currentState.allocator.endScope();
        return valueReg;

    } else if (targetNode.type == "PropertyAccess") {

        let objReg = cg.visitExpression(targetNode.object);
        

        let valueReg = cg.visitExpression(node.value);

        let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, valueReg]);
        
        cg.currentState.allocator.endScope();
        return valueReg;

    } else if (targetNode.type == "IndexExpression") {

        let objReg = cg.visitExpression(targetNode.object);
        let indexReg = cg.visitExpression(targetNode.index);

        let valueReg = cg.visitExpression(node.value);

        Emitter.emit(cg.currentState.proto, OpCodes.SET_INDEX, [objReg, indexReg, valueReg]);
        
        cg.currentState.allocator.endScope();
        return valueReg;

    } else {
        assert(false, "Lỗi: Đích của phép gán không được hỗ trợ: " + targetNode.type);
    }
    

    cg.currentState.allocator.endScope();
    return -1; 
}

export fn visitPrefixUpdateExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let targetNode = node.operand;
    let op = (node.op == TokenType.OP_INCREMENT) ? OpCodes.ADD : OpCodes.SUB;

    cg.currentState.allocator.withTemp(fn(oneReg) {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [oneReg, 1]);
        if (targetNode.type == "Identifier") {
            let resolution = cg.findVariable(targetNode.name);
            assert(resolution.type == "local", "Toán tử ++/-- chỉ hỗ trợ biến local.");
            let targetReg = resolution.index;
            Emitter.emit(cg.currentState.proto, op, [targetReg, targetReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, targetReg]);
        } else if (targetNode.type == "PropertyAccess") {
            let objReg = cg.visitExpression(targetNode.object);
            let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
            let currentValReg = cg.currentState.allocator.ralloc();
            Emitter.emit(cg.currentState.proto, OpCodes.GET_PROP, [currentValReg, objReg, propNameIdx]);
            Emitter.emit(cg.currentState.proto, op, [currentValReg, currentValReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, currentValReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, currentValReg]);
        }
    });
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitPostfixUpdateExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let targetNode = node.operand;
    let op = (node.op == TokenType.OP_INCREMENT) ? OpCodes.ADD : OpCodes.SUB;

    cg.currentState.allocator.withTemp(fn(oneReg) {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [oneReg, 1]);
        if (targetNode.type == "Identifier") {
            let resolution = cg.findVariable(targetNode.name);
            assert(resolution.type == "local", "Toán tử ++/-- chỉ hỗ trợ biến local.");
            let targetReg = resolution.index;
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, targetReg]);
            Emitter.emit(cg.currentState.proto, op, [targetReg, targetReg, oneReg]);
        } else if (targetNode.type == "PropertyAccess") {
            let objReg = cg.visitExpression(targetNode.object);
            let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
            Emitter.emit(cg.currentState.proto, OpCodes.GET_PROP, [destReg, objReg, propNameIdx]);
            let newValReg = cg.currentState.allocator.ralloc();
            Emitter.emit(cg.currentState.proto, op, [newValReg, destReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, newValReg]);
        }
    });
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitIndexExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let objReg = cg.visitExpression(node.object);
    let indexReg = cg.visitExpression(node.index);
    Emitter.emit(cg.currentState.proto, OpCodes.GET_INDEX, [destReg, objReg, indexReg]);
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitPropertyAccess(cg, node) {

    let savedObjReg = cg.currentState.allocator.ralloc();


    cg.currentState.allocator.beginScope();
    let objTempReg = cg.visitExpression(node.object);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [savedObjReg, objTempReg]);
    cg.currentState.allocator.endScope();


    let destReg = cg.currentState.allocator.ralloc();
    let propNameIdx = cg.currentState.pool.add(node.property.name);
    let opcode = OpCodes.GET_PROP;
    if (node.object.type == "Identifier" && (cg.currentState.moduleVariables[node.object.name] != null)) {
        opcode = OpCodes.GET_EXPORT;
    }

    Emitter.emit(cg.currentState.proto, opcode, [destReg, savedObjReg, propNameIdx]);

    cg.currentState.allocator.free(savedObjReg);

    return destReg;
}


export fn visitThisExpression(cg, node) {
    let thisReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [thisReg, 0]);
    return thisReg;
}

export fn visitSuperExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    let nameIdx = cg.currentState.pool.add(node.method.name);
    Emitter.emit(cg.currentState.proto, OpCodes.GET_SUPER, [destReg, nameIdx]);
    return destReg;
}



    



    



        




        





    



export fn visitNewExpression(cg, node) {
    return cg.visitExpression(node.expression);
}

export fn visitTernaryExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    let elseLabel = Emitter.createLabel("L_TERNARY_ELSE");
    let endLabel = Emitter.createLabel("L_TERNARY_END");

    cg.currentState.allocator.beginScope();
    let condReg = cg.visitExpression(node.condition);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": elseLabel}]);
    cg.currentState.allocator.endScope();

    cg.currentState.allocator.beginScope();
    let thenReg = cg.visitExpression(node.thenBranch);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, thenReg]);
    cg.currentState.allocator.endScope();
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": endLabel}]);

    Emitter.defineLabel(cg.currentState.proto, elseLabel);
    cg.currentState.allocator.beginScope();
    let elseReg = cg.visitExpression(node.elseBranch);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, elseReg]);
    cg.currentState.allocator.endScope();

    Emitter.defineLabel(cg.currentState.proto, endLabel);
    return destReg;
}

export fn visitPropertyAssignment(cg, node) {
    let valueReg = cg.visitExpression(node.value);
    
    cg.currentState.allocator.beginScope();
    
    let objReg = cg.visitExpression(node.targetObj);
    
    let propNameIdx = cg.currentState.pool.add(node.property.name);
    
    Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, valueReg]);
    
    cg.currentState.allocator.endScope(); 
    
    return valueReg;
}