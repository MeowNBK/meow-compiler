===== FILE: ./codeGenerator.meow =====

import * as RegisterAllocator from "./registerAllocator.meow";
import * as ConstantPool from "./constantPool.meow";
import * as Emitter from "./emitter.meow";
import * as RegisterOptimizer from "./registerOptimizer.meow";
import { OpCodes } from "./opCodes.meow";
import { Visitor } from "./visitor/visitor.meow";

class CompilerState {
    fn init(name) {
        this.proto = Emitter.createProto(name, 256);
        this.pool = ConstantPool.ConstantPool(this.proto.constantPool);
        this.allocator = RegisterAllocator.RegisterAllocator(256);
        this.scope = [{}];
        this.loopLabels = [];
        this.moduleVariables = {};
        this.importedVariables = {};
        this.capturedLocals = {};
        this.regToLocalIndex = {};
        this.localIndexToReg = {};
        this.localCount = 0;
    }
}

export class CodeGenerator {
    fn init(ast, compiler, sourceName) {
        this.ast = ast;
        this.compiler = compiler;
        this.sourceName = sourceName;
        this.protos = {};
        this.states = [];
        this.currentState = null;
        this.isInsideClass = false;

    }

    fn compile() {
        let mainStr = "@main";
        this.enterState("@main");
        this.currentState.proto.sourceName = this.sourceName;
        
        for (let i = 0; i < this.ast.body.length; ++i) {
            this.visitStatement(this.ast.body[i]);
        }
        
        let mainProto = this.exitState();
        this.protos["@main"] = mainProto;

        // this.protos = RegisterOptimizer.optimizeRegisters(this.protos);

        return this.protos;
    }

    fn enterState(name) {
        let parentState = this.currentState;
        let newState = new CompilerState(name);

        if (parentState) {
            for (key in parentState.moduleVariables.keys()) {
                newState.moduleVariables[key] = parentState.moduleVariables[key];
            }
            for (key in parentState.importedVariables.keys()) {
                newState.importedVariables[key] = parentState.importedVariables[key];
            }
        }

        this.states.push(newState);
        this.currentState = newState;
    }

    fn exitState() {
        let finishedState = this.states.pop();
        let proto = finishedState.proto;

        let lastIdx = proto.code.length - 1;
        if (lastIdx < 0 || proto.code[lastIdx].op != OpCodes.RETURN) {

            finishedState.allocator.withTemp(fn(r) {
                Emitter.emit(proto, OpCodes.LOAD_NULL, [r]);
                Emitter.emit(proto, OpCodes.RETURN, [r]);
            });
        }
        
        proto.numRegisters = finishedState.allocator.usedRegisters();
        let recomputed = Emitter.computeMaxRegister(proto) + 1;
        if (recomputed > proto.numRegisters) proto.numRegisters = recomputed;

        if (!proto.upvalueDescs) proto.upvalueDescs = [];
        proto.numUpvalues = proto.upvalueDescs.length;

        Emitter.patchPendingJumps(proto);
        
        if (this.states.length > 0) {
            this.currentState = this.states[this.states.length - 1];
        } else {
            this.currentState = null;
        }
        return proto;
    }
    
    fn visitStatement(node) {
        if (node == null) return;
        let handler = Visitor.statements[node.type];
        assert(handler, `Lỗi: Không hỗ trợ kiểu statement '%{node.type}'`);
        handler(this, node);
    }

    fn visitExpression(node) {
        if (node == null) return -1;
        let handler = Visitor.expressions[node.type];
        assert(handler, `Lỗi: Không hỗ trợ kiểu expression '%{node.type}'`);
        return handler(this, node);
    }
    
    fn findVariable(name) {
        let localResult = this._findLocalInCurrentState(name);
        if (localResult != null) {
            return localResult;
        }

        if (this.states.length > 1) {

            let upvalueResult = this._findUpvalueRecursive(name, this.states.length - 2);
            if (upvalueResult != null) {
                return upvalueResult;
            }
        }

        return { "type": "global", "name": name };
    }

    fn _findLocalInCurrentState(name) {

        for (let i = this.currentState.scope.length - 1; i >= 0; --i) {
            let scope = this.currentState.scope[i];
            if (scope[name] != null) {

                let localIndex = scope[name];

                let reg = this.currentState.localIndexToReg[localIndex];

                assert(reg != null, `Lỗi nghiêm trọng: Không tìm thấy register cho localIndex=${localIndex} của biến '${name}'`);


                return {'type': 'local', 'index': reg, 'localIndex': localIndex};
            }
        }
        return null;

    }

    fn _findUpvalueRecursive(name, parentStateIndex) {
        if (parentStateIndex < 0) {
            return null;
        }

        let parentState = this.states[parentStateIndex];
        let childState = this.states[parentStateIndex + 1];


        for (let i = parentState.scope.length - 1; i >= 0; --i) {
            let scope = parentState.scope[i];
            if (scope[name] != null) {

                let localIndex = scope[name];
                let registerToCapture = parentState.localIndexToReg[localIndex];
                assert(registerToCapture != null, `Lỗi nghiêm trọng: Không tìm thấy thanh ghi cho local '${name}'`);

                parentState.capturedLocals[localIndex] = true;


                return this._addUpvalueToState({'isLocal': true, 'index': registerToCapture}, childState);
            }
        }

        if (parentStateIndex > 0) {
            let resultFromGrandparent = this._findUpvalueRecursive(name, parentStateIndex - 1);

            if (resultFromGrandparent != null) {



                return this._addUpvalueToState({'isLocal': false, 'index': resultFromGrandparent.index}, childState);
            }
        }

        return null;
    }

    fn _addUpvalue(desc) {
        return this._addUpvalueToState(desc, this.currentState);
    }
    
    fn _addUpvalueToState(desc, state) {

        let proto = state.proto;
        if (!proto.upvalueDescs) proto.upvalueDescs = [];

        assert(typeof(desc.isLocal) == 'bool' || typeof(desc.isLocal) == 'boolean', 'upvalue desc phải có isLocal boolean');
        assert(typeof(desc.index) == 'int' || typeof(desc.index) == 'real' || typeof(desc.index) == 'number', 'upvalue desc.index phải là số (int)');

        for (let i = 0; i < proto.upvalueDescs.length; ++i) {
            let d = proto.upvalueDescs[i];
            if (d.index == desc.index && d.isLocal == desc.isLocal) {
                return {'type': 'upvalue', 'index': i};
            }
        }
        let newIndex = proto.upvalueDescs.length;
        proto.upvalueDescs.push(desc);
        return {'type': 'upvalue', 'index': newIndex};

    }
}

===== FILE: ./constantPool.meow =====
export class ConstantPool {
    fn init(pool) {
        this.pool = pool; 
        this.lookup = {};
    }

    fn add(value) {
        if (typeof(value) == "object" && value != null && (value["sourceName"] != null)) {
             let key = "proto:" + value.sourceName;
             if (this.lookup[key] != null) {
                 return this.lookup[key];
             }
             let index = this.pool.length;
             this.pool.push(value);
             this.lookup[key] = index;
             return index;
        }

        let valueStr = str(value);

        let key = "meow:" + valueStr;
        
        if (this.lookup[key]) {
            return this.lookup[key];
        }

        let index = this.pool.length;
        this.pool.push(value);
        this.lookup[key] = index;
        
        return index;
    }

    fn get(index) {
        if (index >= 0 && index < this.pool.length) {
            return this.pool[index];
        }
        assert(false, "Lỗi: Index hằng số nằm ngoài giới hạn!");
        return null;
    }
}


===== FILE: ./emitter.meow =====

import { OpCodes } from "./opCodes.meow";

let __PROTO_ID_COUNTER = 0;

let __LABEL_COUNTER = 0;
let __ANONYMOUS_FN_COUNTER = 0;

export fn createLabel(prefix) {
    __LABEL_COUNTER += 1;

    let label = prefix + "_" + __LABEL_COUNTER;

    return label;
}

export fn createAnonymousFunctionName() {
    __ANONYMOUS_FN_COUNTER += 1;
    return "__fn_" + str(__ANONYMOUS_FN_COUNTER);
}

export fn createProto(name, numRegisters) {
    let id = __PROTO_ID_COUNTER;
    __PROTO_ID_COUNTER = __PROTO_ID_COUNTER + 1;
    
    return {
        "id": id,
        "numRegisters": numRegisters,
        "sourceName": name,
        "code": [],
        "constantPool": [],
        "upvalueDescs": [],
        "labels": {},
        "pendingJumps": [],
        "numUpvalues": 0
    };
}

export fn emit(proto, opcode, args) {
    let inst = {"op": opcode, "args": [] };
    let ip = proto.code.length;
    for (a in args) {
        if (typeof(a) == "object" && a != null && (a["label"] != null)) {
            inst.args.push(-1);
            proto.pendingJumps.push({"ip": ip, "argIndex": inst.args.length - 1, "label": a.label});
        } else {
            inst.args.push(a);
        }
    }
    proto.code.push(inst);
}

export fn defineLabel(proto, label) {
    proto.labels[label] = proto.code.length;
}

export fn patchPendingJumps(proto) {
    for (p in proto.pendingJumps) {
        assert(proto.labels[p.label] != null, "Lỗi: Không tìm thấy label '" + p.label + "'!");
        let targetIp = proto.labels[p.label];
        proto.code[p.ip].args[p.argIndex] = targetIp;
    }
    proto.pendingJumps = [];
}

let __REG_ARGS = {
    [OpCodes.MOVE]: [0, 1],
    [OpCodes.LOAD_CONST]: [0],
    [OpCodes.LOAD_NULL]: [0],
    [OpCodes.LOAD_TRUE]: [0],
    [OpCodes.LOAD_FALSE]: [0],
    [OpCodes.LOAD_INT]: [0],
    [OpCodes.NOT]: [0, 1],
    [OpCodes.NEG]: [0, 1],
    [OpCodes.ADD]: [0, 1, 2],
    [OpCodes.SUB]: [0, 1, 2],
    [OpCodes.MUL]: [0, 1, 2],
    [OpCodes.DIV]: [0, 1, 2],
    [OpCodes.EQ]: [0, 1, 2],
    [OpCodes.NEQ]: [0, 1, 2],
    [OpCodes.LT]: [0, 1, 2],
    [OpCodes.LE]: [0, 1, 2],
    [OpCodes.GT]: [0, 1, 2],
    [OpCodes.GE]: [0, 1, 2],
    [OpCodes.BIT_AND]: [0, 1, 2],
    [OpCodes.BIT_OR]: [0, 1, 2],
    [OpCodes.BIT_XOR]: [0, 1, 2],
    [OpCodes.LSHIFT]: [0, 1, 2],
    [OpCodes.RSHIFT]: [0, 1, 2],
    [OpCodes.JUMP_IF_FALSE]: [0],
    [OpCodes.JUMP_IF_TRUE]: [0],
    [OpCodes.JUMP]: [],
    [OpCodes.GET_PROP]: [0, 1],
    [OpCodes.SET_PROP]: [0, 2],
    [OpCodes.GET_INDEX]: [0, 1, 2],
    [OpCodes.SET_INDEX]: [0, 1, 2],
    [OpCodes.NEW_ARRAY]: [0, 1],
    [OpCodes.NEW_HASH]: [0, 1],
    [OpCodes.CALL]: [0, 1, 2],
    [OpCodes.RETURN]: [0],
    [OpCodes.GET_UPVALUE]: [0],
    [OpCodes.SET_UPVALUE]: [1],
    [OpCodes.CLOSE_UPVALUES]: [],
    [OpCodes.CLOSURE]: [0],
    [OpCodes.IMPORT_MODULE]: [0],
    [OpCodes.GET_EXPORT]: [0, 1],
    // [OpCodes.GET_MODULE_EXPORT]: [0, 1],
    [OpCodes.GET_GLOBAL]: [0],
    [OpCodes.SET_GLOBAL]: [1],
    [OpCodes.EXPORT]: [1],
    [OpCodes.NEW_CLASS]: [0],
    // [OpCodes.NEW_INSTANCE]: [0, 1],
    [OpCodes.SET_METHOD]: [0, 2],
    [OpCodes.INHERIT]: [0, 1],
    [OpCodes.GET_SUPER]: [0],
    [OpCodes.THROW]: [0],
    [OpCodes.SETUP_TRY]: [],
    [OpCodes.POP_TRY]: []
};

export fn getRegArgIndices(opcode) {
    return __REG_ARGS[opcode];
}

export fn computeMaxRegister(proto) {
    let maxR = -1;
    for (inst in proto.code) {
        let regIdxs = __REG_ARGS[inst.op];
        if (regIdxs != null) {
            for (idx in regIdxs) {
                if (idx < inst.args.length) {
                    let v = inst.args[idx];
                    if (typeof(v) == "int" && v > maxR) maxR = v;
                }
            }
        }
    }
    return maxR;
}

===== FILE: ./opCodes.meow =====
export let OpCodes = {
    LOAD_CONST: "LOAD_CONST", 
    LOAD_NULL: "LOAD_NULL", 
    LOAD_TRUE: "LOAD_TRUE",
    LOAD_FALSE: "LOAD_FALSE", 
    LOAD_INT: "LOAD_INT", 
    MOVE: "MOVE",

    ADD: "ADD", 
    SUB: "SUB", 
    MUL: "MUL", 
    DIV: "DIV", 
    MOD: "MOD", 
    POW: "POW",

    EQ: "EQ", 
    NEQ: "NEQ", 
    GT: "GT", 
    GE: "GE", 
    LT: "LT", 
    LE: "LE",

    NEG: "NEG", 
    NOT: "NOT",

    GET_GLOBAL: "GET_GLOBAL", 
    SET_GLOBAL: "SET_GLOBAL", 
    GET_UPVALUE: "GET_UPVALUE",
    SET_UPVALUE: "SET_UPVALUE", 
    CLOSURE: "CLOSURE", 
    CLOSE_UPVALUES: "CLOSE_UPVALUES",
    JUMP: "JUMP", 
    JUMP_IF_FALSE: "JUMP_IF_FALSE",
    JUMP_IF_TRUE: "JUMP_IF_TRUE",
    CALL: "CALL", 
    RETURN: "RETURN", 
    HALT: "HALT",

    NEW_ARRAY: "NEW_ARRAY", 
    NEW_HASH: "NEW_HASH", 
    GET_INDEX: "GET_INDEX", 
    SET_INDEX: "SET_INDEX",
    GET_KEYS: "GET_KEYS",
    GET_VALUES: "GET_VALUES",

    NEW_CLASS: "NEW_CLASS", 
    // NEW_INSTANCE: "NEW_INSTANCE", 
    GET_PROP: "GET_PROP", 
    SET_PROP: "SET_PROP",
    SET_METHOD: "SET_METHOD", 
    INHERIT: "INHERIT",
    GET_SUPER: "GET_SUPER",

    BIT_AND: "BIT_AND", 
    BIT_OR: "BIT_OR", 
    BIT_XOR: "BIT_XOR", 
    BIT_NOT: "BIT_NOT",
    LSHIFT: "LSHIFT", 
    RSHIFT: "RSHIFT",
    
    THROW: "THROW", 
    SETUP_TRY: "SETUP_TRY", 
    POP_TRY: "POP_TRY",
    IMPORT_MODULE: "IMPORT_MODULE",
    
    EXPORT: "EXPORT", 
    GET_EXPORT: "GET_EXPORT",
    // GET_MODULE_EXPORT: "GET_MODULE_EXPORT",
    IMPORT_ALL: "IMPORT_ALL",
};


===== FILE: ./registerAllocator.meow =====
export class RegisterAllocator {
    fn init(numRegisters) {
        // Mặc dù không dùng numRegisters, cứ để đây cho vui, 
        // biết đâu sau này lại cần 🤣
        this._numRegisters = (numRegisters > 0) ? numRegisters : 256;
        this.reset();
    }

    fn reset() {
        this._nextRegister = 0; // Bắt đầu từ thanh ghi 0
    }

    // Không cần hàm _grow nữa, vì ta cấp phát vô hạn 🚀

    fn ralloc() {
        // Cứ lấy thanh ghi tiếp theo và tăng biến đếm. Ez game!
        let r = this._nextRegister;
        this._nextRegister++;
        return r;
    }

    fn rallocBlock(n) {
        assert(n > 0, "RegisterAllocator.rallocBlock: n phải > 0");
        // Lấy một khối và tăng biến đếm lên n. Quá đơn giản!
        let startReg = this._nextRegister;
        this._nextRegister += n;
        return startReg;
    }

    fn free(reg) {
        // "Tôi không quan tâm." - RegisterAllocator said. 😼
        // Hàm này giờ không làm gì cả.
    }

    fn beginScope() { 
        // Scope là gì? Có ăn được không? 🤔
    }

    fn endScope() {
        // Kết thúc scope? Kệ nó đi. 🤣
    }

    fn take() {
        // take() giờ cũng như ralloc() thôi
        return this.ralloc();
    }

    fn withTemp(fnUse) {
        let r = this.ralloc();
        let out = fnUse(r);
        // Không free nữa nhé. Cứ để đó.
        return out;
    }

    fn usedRegisters() { 
        // Số thanh ghi đã dùng chính là giá trị của biến đếm
        return this._nextRegister;
    }

    fn numRegisters() { 
        // Về mặt lý thuyết là "vô hạn", nhưng ta cứ trả về cái này cho nó có 🤓
        return this._nextRegister; 
    }
}


===== FILE: ./registerOptimizer.meow =====
// File: src/backend/registerOptimizer.meow (phiên bản hoàn chỉnh)

import * as Emitter from "./emitter.meow";
import { OpCodes } from "./opCodes.meow";

fn getRegArgIndices(opcode) {
    return Emitter.getRegArgIndices(opcode);
}

// Hàm này sẽ tối ưu hóa một proto và trả về bảng ánh xạ vReg -> pReg
fn optimizeProtoAndGetMapping(proto) {
    let code = proto.code;
    if (code.length == 0) {
        proto.numRegisters = 0;
        return {}; // Trả về map rỗng
    }
    
    // Bước 1: Phân tích Live Range (tìm lần sử dụng cuối cùng)
    let vRegLastUse = {};
    let allVRegs = {};
    
    for (let ip = 0; ip < code.length; ++ip) {
        let inst = code[ip];
        let regIdxs = getRegArgIndices(inst.op);
        if (regIdxs == null) continue;

        let args = inst.args;
        for (let i = 0; i < regIdxs.length; ++i) {
            let argIndex = regIdxs[i];
            if (argIndex >= args.length) continue;
            let vReg = args[argIndex];

            if (typeof(vReg) != "int") continue;
            
            let sReg = str(vReg);
            allVRegs[sReg] = true;
            let isDestinationReg = (i == 0) && (inst.op != OpCodes.JUMP_IF_FALSE) && (inst.op != OpCodes.JUMP_IF_TRUE) && (inst.op != OpCodes.SETUP_TRY) && (inst.op != OpCodes.SET_GLOBAL) && (inst.op != OpCodes.SET_UPVALUE) && (inst.op != OpCodes.SET_PROP) && (inst.op != OpCodes.SET_INDEX) && (inst.op != OpCodes.EXPORT) && (inst.op != OpCodes.RETURN);

            if (!isDestinationReg) {
                vRegLastUse[sReg] = ip;
            }
        }
    }
    
    // Bước 2: Chuẩn bị cho Linear Scan (Sắp xếp các khoảng sống)
    let intervals = [];
    let vRegs = allVRegs.keys();
    vRegs.sort(fn(a, b) { return int(a) - int(b); });
    
    for (let i = 0; i < vRegs.length; ++i) {
        let sReg = vRegs[i];
        intervals.push({ 
            vReg: int(sReg), 
            sReg: sReg,
            start: i,
            end: vRegLastUse[sReg] != null ? vRegLastUse[sReg] : i,
        });
    }

    // Bước 3: Linear Scan
    let active = [];
    let vToNewReg = {};
    let freeRegs = [];
    let nextNewReg = 0;

    for (let i = 0; i < intervals.length; ++i) {
        let interval = intervals[i];
        let newActive = [];
        for (let j = 0; j < active.length; ++j) {
            let activeInterval = active[j];
            if (activeInterval.end < interval.start) { 
                freeRegs.push(vToNewReg[activeInterval.sReg]);
            } else {
                newActive.push(activeInterval);
            }
        }
        active = newActive;
        
        let newReg;
        if (freeRegs.length > 0) {
            freeRegs.sort(fn(a, b) { return a - b; });
            newReg = freeRegs[0];
            let newFreeRegs = [];
            for (let k = 1; k < freeRegs.length; ++k) newFreeRegs.push(freeRegs[k]);
            freeRegs = newFreeRegs;
        } else {
            newReg = nextNewReg++;
        }
        
        vToNewReg[interval.sReg] = newReg;
        active.push(interval);
        active.sort(fn(a, b) { return a.end - b.end; });
    }
    
    // Bước 4: Áp dụng ánh xạ lên Bytecode
    for (inst in code) {
        let regIdxs = getRegArgIndices(inst.op);
        if (regIdxs == null) continue;

        for (argIndex in regIdxs) {
            if (argIndex >= inst.args.length) continue;
            let vReg = inst.args[argIndex];

            if (typeof(vReg) == "int") {
                let sReg = str(vReg);
                let newReg = vToNewReg[sReg];
                if (newReg != null) {
                    inst.args[argIndex] = newReg;
                }
            }
        }
    }
    
    // Bước 5: Cập nhật thông tin Proto
    proto.numRegisters = Emitter.computeMaxRegister(proto) + 1;
    return vToNewReg;
}

// Hàm chính được export, điều phối 2 giai đoạn
export fn optimizeRegisters(protos) {
    let allMappings = {};
    let protoNames = protos.keys();
    protoNames.sort(); // Sắp xếp để đảm bảo thứ tự xử lý nhất quán

    // GIAI ĐOẠN 1: Tối ưu hóa bytecode và thu thập bảng ánh xạ
    for (pName in protoNames) {
        let proto = protos[pName];
        allMappings[pName] = optimizeProtoAndGetMapping(proto);
    }

    // GIAI ĐOẠN 2: Dùng các bảng ánh xạ để vá lại upvalueDescs
    for (pName in protoNames) {
        let parentProto = protos[pName];
        if (!parentProto || !parentProto.constantPool) continue;

        let parentMap = allMappings[pName];
        if (!parentMap) continue;

        for (constant in parentProto.constantPool) {
            // Kiểm tra xem hằng số có phải là một hàm con không
            if (typeof(constant) == "object" && constant != null && constant.sourceName) {
                let childProto = protos[constant.sourceName];

                if (childProto && childProto.upvalueDescs) {
                    for (desc in childProto.upvalueDescs) {
                        // Nếu upvalue này là một biến local của hàm cha
                        if (desc.isLocal) {
                            let oldVirtualReg = desc.index;
                            let newPhysicalReg = parentMap[str(oldVirtualReg)];

                            if (newPhysicalReg != null) {
                                // Cập nhật lại chỉ số thành số hiệu thanh ghi vật lý mới
                                desc.index = newPhysicalReg;
                            } else {
                                print("[WARN] Optimizer: Không tìm thấy ánh xạ cho upvalue vReg " + str(oldVirtualReg) + " từ hàm " + pName);
                            }
                        }
                    }
                }
            }
        }
    }

    return protos;
}

===== FILE: ./visitor/expression.meow =====
import * as Emitter from "../emitter.meow";
import { OpCodes } from "../opCodes.meow";
import { TokenType, tokenTypeToString, stringToTokenType } from "../../frontend/token.meow";

let binaryOps = {
    [TokenType.OP_PLUS]:      fn(l, r) { return l + r; }, [TokenType.OP_MINUS]:     fn(l, r) { return l - r; },
    [TokenType.OP_MULTIPLY]:  fn(l, r) { return l * r; }, [TokenType.OP_DIVIDE]:    fn(l, r) { return l / r; },
    [TokenType.OP_MODULO]:    fn(l, r) { return l % r; }, [TokenType.OP_EXPONENT]:  fn(l, r) { return l ** r; },
    [TokenType.OP_EQ]:        fn(l, r) { return l == r; }, [TokenType.OP_NEQ]:      fn(l, r) { return l != r; },
    [TokenType.OP_LT]:        fn(l, r) { return l < r; }, [TokenType.OP_GT]:       fn(l, r) { return l > r; },
    [TokenType.OP_LE]:        fn(l, r) { return l <= r; }, [TokenType.OP_GE]:      fn(l, r) { return l >= r; },
    [TokenType.OP_BIT_AND]:   fn(l, r) { return l & r; }, [TokenType.OP_BIT_OR]:    fn(l, r) { return l | r; },
    [TokenType.OP_BIT_XOR]:   fn(l, r) { return l ^ r; }, [TokenType.OP_LSHIFT]:    fn(l, r) { return l << r; },
    [TokenType.OP_RSHIFT]:    fn(l, r) { return l >> r; },
};
let unaryOps = {
    [TokenType.OP_MINUS]:       fn(r) { return -r; }, [TokenType.OP_LOGICAL_NOT]: fn(r) { return !r; },
    [TokenType.OP_BIT_NOT]:     fn(r) { return ~r; },
};
fn isLiteral(type) { return type == "IntegerLiteral" || type == "RealLiteral" || type == "StringLiteral" || type == "BooleanLiteral" || type == "NullLiteral"; }
fn toNode(value) {
    let t = typeof(value);
    if (t == "int") return { "type": "IntegerLiteral", "value": value };
    if (t == "real") return { "type": "RealLiteral", "value": value };
    if (t == "string") return { "type": "StringLiteral", "value": value };
    if (t == "bool") return { "type": "BooleanLiteral", "value": value };
    if (t == "null") return { "type": "NullLiteral" };
    return null;
}
fn handleBinary(node) {
    if (!node || node.type != "BinaryExpression") return node;
    node.left = handleBinary(node.left); node.right = handleBinary(node.right);
    if (isLiteral(node.left.type) && isLiteral(node.right.type)) {
        let func = binaryOps[node.op];
        if (func) return toNode(func(node.left.value, node.right.value));
    }
    return node;
}
fn handleUnary(node) {
    if (!node || node.type != "UnaryExpression") return node;
    node.right = handleUnary(node.right);
    if (isLiteral(node.right.type)) {
        let func = unaryOps[node.op];
        if (func) return toNode(func(node.right.value));
    }
    return node;
}


export fn visitIdentifier(cg, node) {
    let resolution = cg.findVariable(node.name);
    let destReg = cg.currentState.allocator.ralloc();

    if (resolution.type == "local") {
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, resolution.index]);
    } else if (resolution.type == "upvalue") {
        Emitter.emit(cg.currentState.proto, OpCodes.GET_UPVALUE, [destReg, resolution.index]);
    } else {
        let constIdx = cg.currentState.pool.add(resolution.name);
        Emitter.emit(cg.currentState.proto, OpCodes.GET_GLOBAL, [destReg, constIdx]);
    }
    return destReg;
}

export fn visitBinaryExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    if (node.op == TokenType.OP_LOGICAL_AND) {
        let endLabel = Emitter.createLabel("L_AND_END");
        let destReg = cg.currentState.allocator.ralloc();
        cg.currentState.allocator.beginScope();
        let leftReg = cg.visitExpression(node.left);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, leftReg]);
        Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [leftReg, {"label": endLabel}]);
        let rightReg = cg.visitExpression(node.right);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, rightReg]);
        cg.currentState.allocator.endScope();
        Emitter.defineLabel(cg.currentState.proto, endLabel);
        return destReg;
    }

    if (node.op == TokenType.OP_LOGICAL_OR) {
        let endLabel = Emitter.createLabel("L_OR_END");
        let destReg = cg.currentState.allocator.ralloc();
        cg.currentState.allocator.beginScope();
        let leftReg = cg.visitExpression(node.left);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, leftReg]);
        Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_TRUE, [leftReg, {"label": endLabel}]);
        let rightReg = cg.visitExpression(node.right);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, rightReg]);
        cg.currentState.allocator.endScope();
        Emitter.defineLabel(cg.currentState.proto, endLabel);
        return destReg;
    }
    
    let opMap = {
        [TokenType.OP_PLUS]: OpCodes.ADD, [TokenType.OP_MINUS]: OpCodes.SUB, [TokenType.OP_MULTIPLY]: OpCodes.MUL,
        [TokenType.OP_DIVIDE]: OpCodes.DIV, [TokenType.OP_MODULO]: OpCodes.MOD, [TokenType.OP_EXPONENT]: OpCodes.POW,
        [TokenType.OP_EQ]: OpCodes.EQ, [TokenType.OP_NEQ]: OpCodes.NEQ, [TokenType.OP_LT]: OpCodes.LT,
        [TokenType.OP_GT]: OpCodes.GT, [TokenType.OP_LE]: OpCodes.LE, [TokenType.OP_GE]: OpCodes.GE,
        [TokenType.OP_BIT_AND]: OpCodes.BIT_AND, [TokenType.OP_BIT_OR]: OpCodes.BIT_OR,
        [TokenType.OP_BIT_XOR]: OpCodes.BIT_XOR, [TokenType.OP_LSHIFT]: OpCodes.LSHIFT, [TokenType.OP_RSHIFT]: OpCodes.RSHIFT
    };
    let opcode = opMap[node.op];
    assert(opcode, "Lỗi: Toán tử nhị phân không được hỗ trợ: " + node.op);

    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let leftReg = cg.visitExpression(node.left);
    let rightReg = cg.visitExpression(node.right);
    Emitter.emit(cg.currentState.proto, opcode, [destReg, leftReg, rightReg]);
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitUnaryExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let opMap = { [TokenType.OP_MINUS]: OpCodes.NEG, [TokenType.OP_LOGICAL_NOT]: OpCodes.NOT, [TokenType.OP_BIT_NOT]: OpCodes.BIT_NOT };
    let opcode = opMap[node.op];
    assert(opcode, "Lỗi: Toán tử một ngôi không được hỗ trợ: " + node.op);

    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let operandReg = cg.visitExpression(node.operand);
    Emitter.emit(cg.currentState.proto, opcode, [destReg, operandReg]);
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitCallExpression(cg, node) {

    let destReg = cg.currentState.allocator.ralloc();


    let savedCalleeReg = cg.currentState.allocator.ralloc();

    cg.currentState.allocator.beginScope();

    let calleeTempReg = cg.visitExpression(node.callee);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [savedCalleeReg, calleeTempReg]);

    let argc = node.args.length;
    let tempArgRegs = [];

    for (let i = 0; i < argc; ++i) {
        let tempReg = cg.visitExpression(node.args[i]);
        tempArgRegs.push(tempReg);
    }

    let argStartReg = cg.currentState.allocator.rallocBlock(argc > 0 ? argc : 1);

    if (argc > 0) {
        let minSrc = tempArgRegs[0];
        let maxSrc = tempArgRegs[0];
        for (let k = 1; k < tempArgRegs.length; ++k) {
            if (tempArgRegs[k] < minSrc) minSrc = tempArgRegs[k];
            if (tempArgRegs[k] > maxSrc) maxSrc = tempArgRegs[k];
        }

        let destStart = argStartReg;
        let destEnd = argStartReg + argc - 1;
        let overlap = !(destEnd < minSrc || destStart > maxSrc);

        if (overlap && destStart > minSrc) {
            for (let i = argc - 1; i >= 0; --i) {
                let targetReg = argStartReg + i;
                let sourceReg = tempArgRegs[i];
                if (targetReg != sourceReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, sourceReg]);
                }
            }
        } else {
            for (let i = 0; i < argc; ++i) {
                let targetReg = argStartReg + i;
                let sourceReg = tempArgRegs[i];
                if (targetReg != sourceReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, sourceReg]);
                }
            }
        }
    }

    Emitter.emit(cg.currentState.proto, OpCodes.CALL, [destReg, savedCalleeReg, argStartReg, argc]);

    cg.currentState.allocator.endScope();

    cg.currentState.allocator.free(savedCalleeReg);

    return destReg;
}


export fn visitAssignmentExpression(cg, node) {
    let targetNode = node.target;
    cg.currentState.allocator.beginScope();



    if (targetNode.type == "Identifier") {


        let valueReg = cg.visitExpression(node.value);
        let resolution = cg.findVariable(targetNode.name);

        if (resolution.type == "local") {
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [resolution.index, valueReg]);
        } else if (resolution.type == "upvalue") {
            Emitter.emit(cg.currentState.proto, OpCodes.SET_UPVALUE, [resolution.index, valueReg]);
        } else {
            let constIdx = cg.currentState.pool.add(resolution.name);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [constIdx, valueReg]);
        }
        cg.currentState.allocator.endScope();
        return valueReg;

    } else if (targetNode.type == "PropertyAccess") {

        let objReg = cg.visitExpression(targetNode.object);
        

        let valueReg = cg.visitExpression(node.value);

        let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, valueReg]);
        
        cg.currentState.allocator.endScope();
        return valueReg;

    } else if (targetNode.type == "IndexExpression") {

        let objReg = cg.visitExpression(targetNode.object);
        let indexReg = cg.visitExpression(targetNode.index);

        let valueReg = cg.visitExpression(node.value);

        Emitter.emit(cg.currentState.proto, OpCodes.SET_INDEX, [objReg, indexReg, valueReg]);
        
        cg.currentState.allocator.endScope();
        return valueReg;

    } else {
        assert(false, "Lỗi: Đích của phép gán không được hỗ trợ: " + targetNode.type);
    }
    

    cg.currentState.allocator.endScope();
    return -1; 
}

export fn visitPrefixUpdateExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let targetNode = node.operand;
    let op = (node.op == TokenType.OP_INCREMENT) ? OpCodes.ADD : OpCodes.SUB;

    cg.currentState.allocator.withTemp(fn(oneReg) {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [oneReg, 1]);
        if (targetNode.type == "Identifier") {
            let resolution = cg.findVariable(targetNode.name);
            assert(resolution.type == "local", "Toán tử ++/-- chỉ hỗ trợ biến local.");
            let targetReg = resolution.index;
            Emitter.emit(cg.currentState.proto, op, [targetReg, targetReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, targetReg]);
        } else if (targetNode.type == "PropertyAccess") {
            let objReg = cg.visitExpression(targetNode.object);
            let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
            let currentValReg = cg.currentState.allocator.ralloc();
            Emitter.emit(cg.currentState.proto, OpCodes.GET_PROP, [currentValReg, objReg, propNameIdx]);
            Emitter.emit(cg.currentState.proto, op, [currentValReg, currentValReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, currentValReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, currentValReg]);
        }
    });
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitPostfixUpdateExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let targetNode = node.operand;
    let op = (node.op == TokenType.OP_INCREMENT) ? OpCodes.ADD : OpCodes.SUB;

    cg.currentState.allocator.withTemp(fn(oneReg) {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [oneReg, 1]);
        if (targetNode.type == "Identifier") {
            let resolution = cg.findVariable(targetNode.name);
            assert(resolution.type == "local", "Toán tử ++/-- chỉ hỗ trợ biến local.");
            let targetReg = resolution.index;
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, targetReg]);
            Emitter.emit(cg.currentState.proto, op, [targetReg, targetReg, oneReg]);
        } else if (targetNode.type == "PropertyAccess") {
            let objReg = cg.visitExpression(targetNode.object);
            let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
            Emitter.emit(cg.currentState.proto, OpCodes.GET_PROP, [destReg, objReg, propNameIdx]);
            let newValReg = cg.currentState.allocator.ralloc();
            Emitter.emit(cg.currentState.proto, op, [newValReg, destReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, newValReg]);
        }
    });
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitIndexExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let objReg = cg.visitExpression(node.object);
    let indexReg = cg.visitExpression(node.index);
    Emitter.emit(cg.currentState.proto, OpCodes.GET_INDEX, [destReg, objReg, indexReg]);
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitPropertyAccess(cg, node) {

    let savedObjReg = cg.currentState.allocator.ralloc();


    cg.currentState.allocator.beginScope();
    let objTempReg = cg.visitExpression(node.object);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [savedObjReg, objTempReg]);
    cg.currentState.allocator.endScope();


    let destReg = cg.currentState.allocator.ralloc();
    let propNameIdx = cg.currentState.pool.add(node.property.name);
    let opcode = OpCodes.GET_PROP;
    if (node.object.type == "Identifier" && (cg.currentState.moduleVariables[node.object.name] != null)) {
        opcode = OpCodes.GET_EXPORT;
    }

    Emitter.emit(cg.currentState.proto, opcode, [destReg, savedObjReg, propNameIdx]);

    cg.currentState.allocator.free(savedObjReg);

    return destReg;
}


export fn visitThisExpression(cg, node) {
    let thisReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [thisReg, 0]);
    return thisReg;
}

export fn visitSuperExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    let nameIdx = cg.currentState.pool.add(node.method.name);
    Emitter.emit(cg.currentState.proto, OpCodes.GET_SUPER, [destReg, nameIdx]);
    return destReg;
}



    



    



        




        





    



export fn visitNewExpression(cg, node) {
    return cg.visitExpression(node.expression);
}

export fn visitTernaryExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    let elseLabel = Emitter.createLabel("L_TERNARY_ELSE");
    let endLabel = Emitter.createLabel("L_TERNARY_END");

    cg.currentState.allocator.beginScope();
    let condReg = cg.visitExpression(node.condition);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": elseLabel}]);
    cg.currentState.allocator.endScope();

    cg.currentState.allocator.beginScope();
    let thenReg = cg.visitExpression(node.thenBranch);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, thenReg]);
    cg.currentState.allocator.endScope();
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": endLabel}]);

    Emitter.defineLabel(cg.currentState.proto, elseLabel);
    cg.currentState.allocator.beginScope();
    let elseReg = cg.visitExpression(node.elseBranch);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, elseReg]);
    cg.currentState.allocator.endScope();

    Emitter.defineLabel(cg.currentState.proto, endLabel);
    return destReg;
}

export fn visitPropertyAssignment(cg, node) {
    let valueReg = cg.visitExpression(node.value);
    
    cg.currentState.allocator.beginScope();
    
    let objReg = cg.visitExpression(node.targetObj);
    
    let propNameIdx = cg.currentState.pool.add(node.property.name);
    
    Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, valueReg]);
    
    cg.currentState.allocator.endScope(); 
    
    return valueReg;
}


===== FILE: ./visitor/literal.meow =====
import * as Emitter from "../emitter.meow";
import * as String from "string";
import { OpCodes } from "../opCodes.meow";

fn _emitConst(cg, value) {
    let constIdx = cg.currentState.pool.add(value);

    let reg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_CONST, [reg, constIdx]);
    return reg;
}

export fn visitIntegerLiteral(cg, node) {
    let reg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [reg, node.value]);
    return reg;
}

export fn visitStringLiteral(cg, node) {
    return _emitConst(cg, node.value);
}

export fn visitRealLiteral(cg, node) {
    return _emitConst(cg, node.value);
}

export fn visitBooleanLiteral(cg, node) {
    let reg = cg.currentState.allocator.ralloc();
    let opcode = node.value ? OpCodes.LOAD_TRUE : OpCodes.LOAD_FALSE;
    Emitter.emit(cg.currentState.proto, opcode, [reg]);
    return reg;
}

export fn visitNullLiteral(cg, node) {
    let reg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_NULL, [reg]);
    return reg;
}

export fn visitArrayLiteral(cg, node) {
    let count = node.elements.length;
    if (count == 0) {
        let dst = cg.currentState.allocator.ralloc();
        Emitter.emit(cg.currentState.proto, OpCodes.NEW_ARRAY, [dst, 0, 0]);
        return dst;
    }

    cg.currentState.allocator.beginScope();
    let startReg = cg.currentState.allocator.rallocBlock(count);
    
    for (let i = 0; i < count; ++i) {
        let elemReg = cg.visitExpression(node.elements[i]);
        let targetReg = startReg + i;
        if (elemReg != targetReg) {
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, elemReg]);
        }
    }

    let dstReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.NEW_ARRAY, [dstReg, startReg, count]);

    
    cg.currentState.allocator.endScope();
    return dstReg;
}

export let visitObjectLiteral = fn(cg, node) {
    let count = node.properties.length;
    if (count == 0) {
        let dst = cg.currentState.allocator.ralloc();
        Emitter.emit(cg.currentState.proto, OpCodes.NEW_HASH, [dst, 0, 0]);
        return dst;
    }

    cg.currentState.allocator.beginScope();

    let startReg = cg.currentState.allocator.rallocBlock(count * 2);

    for (let i = 0; i < count; ++i) {
        let pair = node.properties[i];
        let keyNode = pair.key;
        let valNode = pair.value;

        let targetKeyReg = startReg + i * 2;
        let targetValReg = startReg + i * 2 + 1;


        if (keyNode.type == 'StringLiteral') {
            let constIdx = cg.currentState.pool.add(keyNode.value);
            cg.currentState.allocator.withTemp(fn(tempReg) {
                Emitter.emit(cg.currentState.proto, OpCodes.LOAD_CONST, [tempReg, constIdx]);
                if (tempReg != targetKeyReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetKeyReg, tempReg]);
                }
            });
        } else if (keyNode.type == 'Identifier') {
            let constIdx = cg.currentState.pool.add(keyNode.name);
            cg.currentState.allocator.withTemp(fn(tempReg) {
                Emitter.emit(cg.currentState.proto, OpCodes.LOAD_CONST, [tempReg, constIdx]);
                if (tempReg != targetKeyReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetKeyReg, tempReg]);
                }
            });
        } else {

            let keyReg = cg.visitExpression(keyNode);
            if (keyReg != targetKeyReg) {
                Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetKeyReg, keyReg]);
            }
        }

        let valReg = cg.visitExpression(valNode);
        if (valReg != targetValReg) {
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetValReg, valReg]);
        }
    }

    let dstReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.NEW_HASH, [dstReg, startReg, count]);
    cg.currentState.allocator.endScope();
    return dstReg;
};

export let visitFunctionLiteral = fn(cg, node) {
    let descriptiveName;
    if (node.name) { 
        let safeName = String.replace(node.name, "@", "_");
        safeName = String.replace(safeName, " ", "_");
        descriptiveName = safeName;
    } else { 
        descriptiveName = Emitter.createAnonymousFunctionName();
    }
    
    let parentSource = (cg.currentState && cg.currentState.proto && cg.currentState.proto.sourceName) ? cg.currentState.proto.sourceName : "anon_parent";
    
    // **Sửa lỗi quan trọng:** Luôn bắt đầu tên proto bằng '@' để VM có thể phân tích cú pháp.
    // Tên mới sẽ có dạng @<tên_hàm>_<tên_file_cha>_<vị_trí>
    let funcName = '@' + descriptiveName + '_' + parentSource + '_' + str(cg.currentState ? cg.currentState.proto.code.length : 0);

    cg.enterState(funcName);
    let paramScope = cg.currentState.scope[0];
    if (cg.isInsideClass) {
        cg.currentState.allocator.ralloc();
    }

    let wasInsideClass = cg.isInsideClass;
    cg.isInsideClass = false;
    for (param in node.parameters) {
        let reg = cg.currentState.allocator.ralloc();
        let localIdx = cg.currentState.localCount;
        cg.currentState.localCount = localIdx + 1;
        cg.currentState.regToLocalIndex[str(reg)] = localIdx;
        cg.currentState.localIndexToReg[localIdx] = reg;
        paramScope[param.name] = localIdx;
    }

    cg.visitStatement(node.body);
    let childProto = cg.exitState();

    cg.isInsideClass = wasInsideClass;

    assert(childProto.sourceName && childProto.sourceName.length > 3, "Bad childProto.sourceName after visitFunctionLiteral");

    cg.protos[childProto.sourceName] = childProto;
    let parentPool = cg.currentState.pool;
    let protoIdx = parentPool.add(childProto);

    let destReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.CLOSURE, [destReg, protoIdx]);

    return destReg;
};


export fn visitTemplateLiteral(cg, node) {
    if (node.parts.length == 0) {
        return _emitConst(cg, "");
    }

    let resultReg = cg.visitExpression(node.parts[0]);

    cg.currentState.allocator.beginScope();
    for (let i = 1; i < node.parts.length; ++i) {
        let partReg = cg.visitExpression(node.parts[i]);
        Emitter.emit(cg.currentState.proto, OpCodes.ADD, [resultReg, resultReg, partReg]);

    }
    cg.currentState.allocator.endScope();

    return resultReg;
}


===== FILE: ./visitor/statement.meow =====
import * as Emitter from "../emitter.meow";
import { OpCodes } from "../opCodes.meow";
import * as Io from "io";
import * as Json from "json";

fn _endScopeAndCloseUpvalues(cg) {
    let scopeToEnd = cg.currentState.scope[cg.currentState.scope.length - 1];
    let lowestRegisterToClose = -1;

    for (varName in scopeToEnd.keys()) {
        let localIndex = scopeToEnd[varName];

        if (localIndex != null && cg.currentState.capturedLocals[localIndex]) {
            let register = cg.currentState.localIndexToReg[localIndex];
            if (register != null) {

                if (lowestRegisterToClose == -1 || register < lowestRegisterToClose) {
                    lowestRegisterToClose = register;
                }
            }
        }

        let register = cg.currentState.localIndexToReg[localIndex];
        if (register != null) {
            cg.currentState.localIndexToReg[localIndex] = null;
            cg.currentState.regToLocalIndex[str(register)] = null;
        }
    }

    if (lowestRegisterToClose != -1) {
        Emitter.emit(cg.currentState.proto, OpCodes.CLOSE_UPVALUES, [lowestRegisterToClose]);
    }

    cg.currentState.scope.pop();
    cg.currentState.allocator.endScope();
}

export let visitLetStatement = fn(cg, node) {
    let name = node.name.name;
    let scopeLevel = cg.currentState.scope.length - 1;
    let currentScope = cg.currentState.scope[scopeLevel];

    let destReg;
    if (scopeLevel > 0) {
        destReg = cg.currentState.allocator.take();
    } else {
        destReg = cg.currentState.allocator.ralloc();
    }

    let localIdx = cg.currentState.localCount++;
    cg.currentState.regToLocalIndex[str(destReg)] = localIdx;
    cg.currentState.localIndexToReg[localIdx] = destReg;
    currentScope[name] = localIdx;

    if (node.value != null) {
        cg.currentState.allocator.beginScope();
        let valueReg = cg.visitExpression(node.value);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, valueReg]);
        cg.currentState.allocator.endScope();
    } else {

        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_NULL, [destReg]);
    }

    if (scopeLevel == 0 && cg.states.length == 1) {
        let constIdx = cg.currentState.pool.add(name);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [constIdx, destReg]);
    }
};

export let visitFunctionStatement = fn(cg, node) {
    let name = node.name.name;
    node.func.name = name;

    let valueReg = cg.visitExpression(node.func);

    let scopeLevel = cg.currentState.scope.length - 1;
    let currentScope = cg.currentState.scope[scopeLevel];

    let destReg;
    if (scopeLevel > 0) {
        destReg = cg.currentState.allocator.take();
    } else {
        destReg = cg.currentState.allocator.ralloc();
    }

    let localIdx = cg.currentState.localCount++;
    cg.currentState.regToLocalIndex[str(destReg)] = localIdx;
    cg.currentState.localIndexToReg[localIdx] = destReg;
    currentScope[name] = localIdx;
    
    // Di chuyển closure đã được tạo vào thanh ghi của biến
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, valueReg]);

    // Nếu ở scope toàn cục, set global
    if (scopeLevel == 0 && cg.states.length == 1) {
        let constIdx = cg.currentState.pool.add(name);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [constIdx, destReg]);
    }
};


export fn visitClassStatement(cg, node) {
    let className = node.name.name;
    let classNameIdx = cg.currentState.pool.add(className);

    let classReg = cg.currentState.allocator.take();
    let localIdx = cg.currentState.localCount++;
    
    cg.currentState.regToLocalIndex[str(classReg)] = localIdx;
    cg.currentState.localIndexToReg[localIdx] = classReg;
    let currentScope = cg.currentState.scope[cg.currentState.scope.length - 1];
    currentScope[className] = localIdx;

    Emitter.emit(cg.currentState.proto, OpCodes.NEW_CLASS, [classReg, classNameIdx]);
    
    cg.currentState.allocator.beginScope();
    if (node.superclass != null) {
        let parentClassReg = cg.visitExpression(node.superclass);
        Emitter.emit(cg.currentState.proto, OpCodes.INHERIT, [classReg, parentClassReg]);
    }

    cg.isInsideClass = true;
    for (methodNode in node.methods) {
        // methodNode giờ là một FunctionStatement
        let methodName = methodNode.name.name;
        // Gán tên phương thức vào FunctionLiteral
        methodNode.func.name = className + "." + methodName;
        let methodClosureReg = cg.visitExpression(methodNode.func);
        let methodNameIdx = cg.currentState.pool.add(methodName);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_METHOD, [classReg, methodNameIdx, methodClosureReg]);
    }
    cg.isInsideClass = false;
    cg.currentState.allocator.endScope();

    if (cg.currentState.scope.length == 1) {
        Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [classNameIdx, classReg]);
    }
}


export fn visitReturnStatement(cg, node) {
    let reg;
    if (node.value != null) {
        reg = cg.visitExpression(node.value);
    } else {
        reg = cg.currentState.allocator.take();
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_NULL, [reg]);
    }
    Emitter.emit(cg.currentState.proto, OpCodes.RETURN, [reg]);
}

export fn visitIfStatement(cg, node) {
    let elseLabel = Emitter.createLabel("L_ELSE");
    let endLabel = Emitter.createLabel("L_ENDIF");

    cg.currentState.allocator.beginScope();
    let condReg = cg.visitExpression(node.condition);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": node.elseBranch ? elseLabel : endLabel}]);
    cg.currentState.allocator.endScope();

    cg.visitStatement(node.thenBranch);

    if (node.elseBranch != null) {
        Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": endLabel}]);
        Emitter.defineLabel(cg.currentState.proto, elseLabel);
        cg.visitStatement(node.elseBranch);
    }

    Emitter.defineLabel(cg.currentState.proto, endLabel);
}

export fn visitWhileStatement(cg, node) {
    let startLabel = Emitter.createLabel("L_WHILE_START");
    let endLabel = Emitter.createLabel("L_WHILE_END");

    cg.currentState.loopLabels.push({ "continueTarget": startLabel, "breakTarget": endLabel });

    Emitter.defineLabel(cg.currentState.proto, startLabel);

    cg.currentState.allocator.beginScope();
    let condReg = cg.visitExpression(node.condition);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": endLabel}]);
    cg.currentState.allocator.endScope();

    cg.visitStatement(node.body);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": startLabel}]);
    Emitter.defineLabel(cg.currentState.proto, endLabel);

    cg.currentState.loopLabels.pop();
}

export fn visitBreakStatement(cg, node) {
    assert(cg.currentState.loopLabels.length > 0, "Lỗi: 'break' chỉ có thể được dùng trong vòng lặp!");
    let labels = cg.currentState.loopLabels[cg.currentState.loopLabels.length - 1];
    
    assert(labels.breakTarget, "Lỗi logic: Vòng lặp không có nhãn 'break'.");
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": labels.breakTarget}]);
}

export fn visitContinueStatement(cg, node) {
    assert(cg.currentState.loopLabels.length > 0, "Lỗi: 'continue' chỉ có thể được dùng trong vòng lặp!");
    let labels = cg.currentState.loopLabels[cg.currentState.loopLabels.length - 1];

    assert(labels.continueTarget, "Lỗi logic: Vòng lặp không hỗ trợ 'continue'.");
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": labels.continueTarget}]);
}

export fn visitBlockStatement(cg, node) {
    cg.currentState.allocator.beginScope();
    cg.currentState.scope.push({});

    for (statement in node.statements) {
        cg.visitStatement(statement);
    }

    _endScopeAndCloseUpvalues(cg);
}

export fn visitExpressionStatement(cg, node) {
    cg.currentState.allocator.beginScope();
    cg.visitExpression(node.expression);
    cg.currentState.allocator.endScope();
}

export fn visitForStatement(cg, node) {

    cg.currentState.allocator.beginScope();
    cg.currentState.scope.push({});
    
    if (node.init != null) {
        cg.visitStatement(node.init);
    }

    let conditionLabel = Emitter.createLabel("L_FOR_COND");
    let updateLabel = Emitter.createLabel("L_FOR_UPDATE");
    let endLabel = Emitter.createLabel("L_FOR_END");
    cg.currentState.loopLabels.push({ "continueTarget": updateLabel, "breakTarget": endLabel });

    Emitter.defineLabel(cg.currentState.proto, conditionLabel);

    if (node.condition != null) {
        cg.currentState.allocator.withTemp(fn(condReg) {
             let tempReg = cg.visitExpression(node.condition);
             Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [condReg, tempReg]);
             Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": endLabel}]);
        });
    }

    cg.visitStatement(node.body);

    Emitter.defineLabel(cg.currentState.proto, updateLabel);
    if (node.update != null) {
        cg.currentState.allocator.beginScope();
        cg.visitExpression(node.update);
        cg.currentState.allocator.endScope();
    }

    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": conditionLabel}]);
    Emitter.defineLabel(cg.currentState.proto, endLabel);

    cg.currentState.loopLabels.pop();

    _endScopeAndCloseUpvalues(cg);
}

export fn visitForInStatement(cg, node) {
    cg.currentState.allocator.beginScope();
    cg.currentState.scope.push({});

    let collectionReg = cg.visitExpression(node.collection);
    let keysArrayReg = cg.currentState.allocator.take();
    Emitter.emit(cg.currentState.proto, OpCodes.GET_VALUES, [keysArrayReg, collectionReg]);

    let indexReg = cg.currentState.allocator.take();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [indexReg, 0]);

    let lengthReg = cg.currentState.allocator.take();
    let lengthNameIdx = cg.currentState.pool.add("length");
    Emitter.emit(cg.currentState.proto, OpCodes.GET_PROP, [lengthReg, keysArrayReg, lengthNameIdx]);
    
    let startLabel = Emitter.createLabel("L_FORIN_START");
    let endLabel = Emitter.createLabel("L_FORIN_END");
    
    cg.currentState.loopLabels.push({ "continueTarget": startLabel, "breakTarget": endLabel });
    Emitter.defineLabel(cg.currentState.proto, startLabel);
    
    let condReg = cg.currentState.allocator.take();
    Emitter.emit(cg.currentState.proto, OpCodes.LT, [condReg, indexReg, lengthReg]);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": endLabel}]);

    let keyReg = cg.currentState.allocator.take();
    Emitter.emit(cg.currentState.proto, OpCodes.GET_INDEX, [keyReg, keysArrayReg, indexReg]);

    let varName = node.variable.name;
    let localIdx = cg.currentState.localCount++;
    cg.currentState.regToLocalIndex[str(keyReg)] = localIdx;
    cg.currentState.localIndexToReg[localIdx] = keyReg;
    cg.currentState.scope[cg.currentState.scope.length - 1][varName] = localIdx;
    
    cg.visitStatement(node.body);
    
    cg.currentState.allocator.withTemp(fn(oneReg) {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [oneReg, 1]);
        Emitter.emit(cg.currentState.proto, OpCodes.ADD, [indexReg, indexReg, oneReg]);
    });
    
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": startLabel}]);
    Emitter.defineLabel(cg.currentState.proto, endLabel);
    
    cg.currentState.loopLabels.pop();

    let scopeToEnd = cg.currentState.scope[cg.currentState.scope.length - 1];
    let lowestRegisterToClose = -1;

    for (varName in scopeToEnd.keys()) {
        let localIndex = scopeToEnd[varName];
        if (localIndex != null) {
            if (cg.currentState.capturedLocals[localIndex]) {
                let register = cg.currentState.localIndexToReg[localIndex];
                if (register != null) {
                    if (lowestRegisterToClose == -1 || register < lowestRegisterToClose) {
                        lowestRegisterToClose = register;
                    }
                }
            }
            let register = cg.currentState.localIndexToReg[localIndex];
            if (register != null) {
                cg.currentState.localIndexToReg[localIndex] = null;
                cg.currentState.regToLocalIndex[str(register)] = null;
            }
        }
    }
    
    if (lowestRegisterToClose != -1) {
        Emitter.emit(cg.currentState.proto, OpCodes.CLOSE_UPVALUES, [lowestRegisterToClose]);
    }
    
    cg.currentState.scope.pop();
    cg.currentState.allocator.endScope(); 
}

export fn visitThrowStatement(cg, node) {
    cg.currentState.allocator.beginScope();
    let errorReg = cg.visitExpression(node.argument);
    Emitter.emit(cg.currentState.proto, OpCodes.THROW, [errorReg]);
    cg.currentState.allocator.endScope();
}

export fn visitTryStatement(cg, node) {
    let catchLabel = Emitter.createLabel("L_CATCH");
    let endLabel = Emitter.createLabel("L_END_TRY");

    Emitter.emit(cg.currentState.proto, OpCodes.SETUP_TRY, [{"label": catchLabel}]);
    cg.visitStatement(node.tryBlock);
    Emitter.emit(cg.currentState.proto, OpCodes.POP_TRY, []);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": endLabel}]);

    Emitter.defineLabel(cg.currentState.proto, catchLabel);
    

    cg.currentState.allocator.beginScope();
    cg.currentState.scope.push({});
    
    if (node.catchVariable != null) {
        let errorVarName = node.catchVariable.name;

        let errorReg = 0;
        let localIdx = cg.currentState.localCount++;
        cg.currentState.regToLocalIndex[str(errorReg)] = localIdx;
        cg.currentState.localIndexToReg[localIdx] = errorReg;
        cg.currentState.scope[cg.currentState.scope.length - 1][errorVarName] = localIdx;
    }
    
    cg.visitStatement(node.catchBlock);

    _endScopeAndCloseUpvalues(cg);
    Emitter.defineLabel(cg.currentState.proto, endLabel);
}

export fn visitExportStatement(cg, node) {
    cg.visitStatement(node.declaration);
    let name = node.declaration.name.name;
    let currentScope = cg.currentState.scope[cg.currentState.scope.length - 1];
    assert(currentScope[name] != null, "Lỗi logic: Biến '" + name + "' không có trong scope sau khi khai báo.");

    let localIndex = currentScope[name];
    let regIndex = cg.currentState.localIndexToReg[localIndex];
    assert(regIndex != null, "Lỗi nghiêm trọng: Không tìm thấy thanh ghi cho biến được export '" + name + "'");

    let nameIdx = cg.currentState.pool.add(name);
    Emitter.emit(cg.currentState.proto, OpCodes.EXPORT, [nameIdx, regIndex]);
}

export let stdlib = { "io": true, "array": true, "json": true, "object": true, "string": true, "system": true };
fn _getDirectoryPath(fullPath) {
    let filename = Io.getFileName(fullPath);
    if (filename.length >= fullPath.length) return "";
    return fullPath.slice(0, fullPath.length - filename.length);
}

export fn visitImportStatement(cg, node) {
    let sourcePath = node.path.value;
    let pathIdx;

    if (stdlib[sourcePath] != null || sourcePath.endsWith(".meowb")) {
        pathIdx = cg.currentState.pool.add(sourcePath);
    } else if (sourcePath.endsWith(".meow")) {
        let currentFileDir = _getDirectoryPath(cg.currentState.proto.sourceName);
        let importAbsolutePath = Io.getAbsolutePath(currentFileDir + "/" + sourcePath);
        let cachePath = cg.compiler.compiledModules[importAbsolutePath];
        assert(cachePath, "Lỗi logic: Module " + importAbsolutePath + " lẽ ra phải được biên dịch rồi!");
        pathIdx = cg.currentState.pool.add(cachePath);
    } else {

        pathIdx = cg.currentState.pool.add(sourcePath);
    }

    if (node.namespaceImport != null) {

        let moduleName = node.namespaceImport.name;
        let moduleReg = cg.currentState.allocator.ralloc();
        Emitter.emit(cg.currentState.proto, OpCodes.IMPORT_MODULE, [moduleReg, pathIdx]);

        let localIdx = cg.currentState.localCount++;
        cg.currentState.regToLocalIndex[str(moduleReg)] = localIdx;
        cg.currentState.localIndexToReg[localIdx] = moduleReg;
        cg.currentState.scope[cg.currentState.scope.length - 1][moduleName] = localIdx;

        if (cg.currentState.scope.length == 1 && cg.states.length == 1) {
            let nameIdx = cg.currentState.pool.add(moduleName);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [nameIdx, moduleReg]);
        }

        cg.currentState.moduleVariables[moduleName] = true;

    } else if (node.namedImports.length > 0) {

        cg.currentState.allocator.withTemp(fn(tempModuleReg) {
            Emitter.emit(cg.currentState.proto, OpCodes.IMPORT_MODULE, [tempModuleReg, pathIdx]);
            
            for (importId in node.namedImports) {
                let importName = importId.name;
                let nameIdx = cg.currentState.pool.add(importName);
                

                let localReg = cg.currentState.allocator.ralloc(); 
                Emitter.emit(cg.currentState.proto, OpCodes.GET_EXPORT, [localReg, tempModuleReg, nameIdx]);

                let localIdx = cg.currentState.localCount++;
                cg.currentState.regToLocalIndex[str(localReg)] = localIdx;
                cg.currentState.localIndexToReg[localIdx] = localReg;

                cg.currentState.scope[cg.currentState.scope.length - 1][importName] = localIdx;

                if (cg.currentState.scope.length == 1 && cg.states.length == 1) {
                    Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [nameIdx, localReg]);
                }
                
                cg.currentState.importedVariables[importName] = true;
            }
        });

    } else {

        cg.currentState.allocator.withTemp(fn(tempModuleReg) {
            Emitter.emit(cg.currentState.proto, OpCodes.IMPORT_MODULE, [tempModuleReg, pathIdx]);
        });
    }
}

export fn visitDoWhileStatement(cg, node) {
    let startLabel = Emitter.createLabel("L_DOWHILE_START");
    let endLabel = Emitter.createLabel("L_DOWHILE_END");
    
    cg.currentState.loopLabels.push({ "continueTarget": startLabel, "breakTarget": endLabel });
    Emitter.defineLabel(cg.currentState.proto, startLabel);
    
    cg.visitStatement(node.body);

    cg.currentState.allocator.beginScope();
    let condReg = cg.visitExpression(node.condition);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_TRUE, [condReg, {"label": startLabel}]);
    cg.currentState.allocator.endScope();

    Emitter.defineLabel(cg.currentState.proto, endLabel);
    cg.currentState.loopLabels.pop();
}

export fn visitSwitchStatement(cg, node) {
    cg.currentState.allocator.beginScope();
    cg.currentState.scope.push({});

    let switchValueReg = cg.visitExpression(node.value);
    let bodyLabels = [];
    let testChainLabels = [];
    let defaultBodyLabel = null;
    let endLabel = Emitter.createLabel("L_SWITCH_END");
    
    for (i in range(0, node.cases.length)) {
        bodyLabels.push(Emitter.createLabel("L_CASE_BODY"));
        testChainLabels.push(Emitter.createLabel("L_NEXT_TEST"));
    }
    cg.currentState.loopLabels.push({ "continueTarget": null, "breakTarget": endLabel });

    for (i in range(0, node.cases.length)) {
        let cas = node.cases[i];
        if (i > 0) {
            Emitter.defineLabel(cg.currentState.proto, testChainLabels[i-1]);
        }

        if (cas.value != null) {
            let caseValueReg = cg.visitExpression(cas.value);
            let eqReg = cg.currentState.allocator.take();
            Emitter.emit(cg.currentState.proto, OpCodes.EQ, [eqReg, switchValueReg, caseValueReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [eqReg, {"label": testChainLabels[i]}]);
            Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": bodyLabels[i]}]);
        } else {
            defaultBodyLabel = bodyLabels[i];
            Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": testChainLabels[i]}]);
        }
    }
    
    Emitter.defineLabel(cg.currentState.proto, testChainLabels[testChainLabels.length - 1]);
    let finalJumpTarget = defaultBodyLabel ? defaultBodyLabel : endLabel;
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": finalJumpTarget}]);

    for (i in range(0, node.cases.length)) {
        Emitter.defineLabel(cg.currentState.proto, bodyLabels[i]);
        for (stmt in node.cases[i].statements) {
            cg.visitStatement(stmt);
        }
        
        let bodyStmts = node.cases[i].statements;
        if (bodyStmts.length == 0 || (bodyStmts[bodyStmts.length-1].type != "ReturnStatement" && bodyStmts[bodyStmts.length-1].type != "BreakStatement" && bodyStmts[bodyStmts.length-1].type != "ContinueStatement" && bodyStmts[bodyStmts.length-1].type != "ThrowStatement")) {
             Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": endLabel}]);
        }
    }

    Emitter.defineLabel(cg.currentState.proto, endLabel);
    cg.currentState.loopLabels.pop();

    _endScopeAndCloseUpvalues(cg);
}


===== FILE: ./visitor/visitor.meow =====
import * as Expression from "./expression.meow";
import * as Statement from "./statement.meow";
import * as Literal from "./literal.meow";

export let Visitor = {
    statements: {
        "LetStatement": Statement.visitLetStatement,
        "FunctionStatement": Statement.visitFunctionStatement,
        "ClassStatement": Statement.visitClassStatement,
        "ReturnStatement": Statement.visitReturnStatement,
        "IfStatement": Statement.visitIfStatement,
        "WhileStatement": Statement.visitWhileStatement,
        "BreakStatement": Statement.visitBreakStatement,
        "ContinueStatement": Statement.visitContinueStatement,
        "BlockStatement": Statement.visitBlockStatement, 
        "ForStatement": Statement.visitForStatement,
        "ForInStatement": Statement.visitForInStatement,
        "ThrowStatement": Statement.visitThrowStatement,
        "TryStatement": Statement.visitTryStatement,
        "ExpressionStatement": Statement.visitExpressionStatement,
        "ExportStatement": Statement.visitExportStatement,
        "ImportStatement": Statement.visitImportStatement,
        "DoWhileStatement": Statement.visitDoWhileStatement,
        "SwitchStatement": Statement.visitSwitchStatement,
    },
    expressions: {
        "IntegerLiteral": Literal.visitIntegerLiteral,
        "StringLiteral": Literal.visitStringLiteral,
        "RealLiteral": Literal.visitRealLiteral,
        "BooleanLiteral": Literal.visitBooleanLiteral,
        "NullLiteral": Literal.visitNullLiteral, 
        "ArrayLiteral": Literal.visitArrayLiteral,
        "ObjectLiteral": Literal.visitObjectLiteral,
        "FunctionLiteral": Literal.visitFunctionLiteral,
        "TemplateLiteral": Literal.visitTemplateLiteral,

        "Identifier": Expression.visitIdentifier,
        "BinaryExpression": Expression.visitBinaryExpression,
        "UnaryExpression": Expression.visitUnaryExpression,
        "CallExpression": Expression.visitCallExpression,
        "AssignmentExpression": Expression.visitAssignmentExpression,
        "PrefixUpdateExpression": Expression.visitPrefixUpdateExpression,
        "PostfixUpdateExpression": Expression.visitPostfixUpdateExpression,
        "IndexExpression": Expression.visitIndexExpression,
        "PropertyAccess": Expression.visitPropertyAccess,
        "NewExpression": Expression.visitNewExpression,
        "ThisExpression": Expression.visitThisExpression,
        "SuperExpression": Expression.visitSuperExpression,
        "TernaryExpression": Expression.visitTernaryExpression,
    }
};


