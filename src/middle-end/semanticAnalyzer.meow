import * as System from "system";
import { ScopedSymbolTable, Symbol } from "frontend/symbolTable.meow";
import { Diagnostic, ErrorCodes } from "frontend/diagnostic.meow";

fn typesAreEqual(typeA, typeB) {
    if (!typeA || !typeB) return false;
    return typeA.name == typeB.name && typeA.pointerLevel == typeB.pointerLevel;
}

fn typeToString(typeNode) { 
    return typeNode.name + "*".repeat(typeNode.pointerLevel);
}

fn getLiteralType(node) {
    if (node.type == "IntegerLiteral") return { name: "int32", pointerLevel: 0, isConst: true };
    if (node.type == "RealLiteral") return { name: "float32", pointerLevel: 0, isConst: true };
    if (node.type == "BooleanLiteral") return { name: "bool", pointerLevel: 0, isConst: true };
    if (node.type == "NullLiteral") return { name: "null", pointerLevel: 0, isConst: true };

    if (node.type == "CharLiteral") return { name: "char", pointerLevel: 0, isConst: true };
    if (node.type == "StringLiteral") return { name: "char", pointerLevel: 1, isConst: true };
    return null;
}

export class SemanticAnalyzer {
    fn init(ast) {
        this.ast = ast;
        this.currentScope = null;

        this.validBaseTypes = { "int32": true, "char": true, "float32": true, "bool": true, "null": true };
    }
    
    fn analyze() {
        try {
            this.currentScope = new ScopedSymbolTable("global", 1, null);
            this.visit(this.ast);
        } catch (e) {
            print(e);
            System.exit(42);
        }
    }
    
    fn throwSemanticError(code, node, replacements) {
        throw (Diagnostic.SemanticErr(code, node, replacements));
    }

    fn visit(node) {
        if (node == null) return null;
        let visitorFn = this["visit" + node.type];
        if (visitorFn) {
            return visitorFn(node);
        }
        
        for (childKey in node.keys()) {
            let child = node[childKey];
            if (typeof(child) == "object" && child != null && child.type) {
                this.visit(child);
            } else if (typeof(child) == "array") {
                for (item in child) this.visit(item);
            }
        }
        
        return null;
    }

    fn visitProgram(node) {
        for (statement in node.body) {
            this.visit(statement);
        }
    }

    fn visitLetStatement(node) {
        let valueType = null;
        if (node.value) {
            valueType = this.visit(node.value);
        }
        if (node.typeAnnotation.pointerLevel == 0 && !this.validBaseTypes[node.typeAnnotation.name]) {
            this.throwSemanticError(ErrorCodes.ERR_INVALID_BASE_TYPE, node, {
                typeName: node.typeAnnotation.name,
                validTypes: this.validBaseTypes.keys().join(", ")
            });
        }

        if (valueType && !typesAreEqual(node.typeAnnotation, valueType)) {
            let declaredTypeStr = typeToString(node.typeAnnotation);
            let valueTypeStr = typeToString(valueType);
            this.throwSemanticError(ErrorCodes.ERR_TYPE_MISMATCH_DECLARATION, node, {
                valueType: valueTypeStr,
                declaredType: declaredTypeStr
            });
        }
        let symbolName = node.name.name;
        let symbol = new Symbol(symbolName, node.typeAnnotation, "variable", node.isConstant);

        if (!this.currentScope.define(symbol)) {
            this.throwSemanticError(ErrorCodes.ERR_VARIABLE_REDEFINITION, node, {
                variableName: symbolName
            });
        }
    }


    fn visitAssignmentExpression(node) {
        if (node.target.type == "Identifier") {
            let symbol = this.currentScope.lookup(node.target.name, false);
            if (symbol && symbol.isConstant) {
                this.throwSemanticError(ErrorCodes.ERR_ASSIGNMENT_TO_CONST, node, {
                    variableName: node.target.name
                });
            }
        }

        let targetType = this.visit(node.target);
        let valueType = this.visit(node.value);

        if (!typesAreEqual(targetType, valueType)) {
              let targetTypeStr = typeToString(targetType);
              let valueTypeStr = typeToString(valueType);
              this.throwSemanticError(ErrorCodes.ERR_TYPE_MISMATCH_ASSIGNMENT, node, {
                targetType: targetTypeStr,
                valueType: valueTypeStr
              });
        }
        return targetType;
    }

    fn visitBinaryExpression(node) {
        let leftType = this.visit(node.left);
        let rightType = this.visit(node.right);
        
        if (!typesAreEqual(leftType, rightType)) {
            this.throwSemanticError(ErrorCodes.ERR_BINARY_OP_TYPE_MISMATCH, node, {});
        }
        
        if (leftType.pointerLevel > 0) {
             this.throwSemanticError(ErrorCodes.ERR_OP_ON_POINTER, node, {});
        }
        
        return leftType;
    }

    fn visitDereferenceExpression(node) {
        let operandType = this.visit(node.operand);
        if (operandType.pointerLevel == 0) {
            let typeStr = typeToString(operandType);
            this.throwSemanticError(ErrorCodes.ERR_DEREFERENCE_NON_POINTER, node, {
                typeStr: typeStr
            });
        }
        return { name: operandType.name, pointerLevel: operandType.pointerLevel - 1 }; 
    }

    fn visitAddressOfExpression(node) {
        let operandType = this.visit(node.operand);
        if (node.operand.type != "Identifier" && node.operand.type != "DereferenceExpression" && node.operand.type != "IndexExpression") {
            this.throwSemanticError(ErrorCodes.ERR_ADDRESSOF_NON_LVALUE, node, {});
        }
        
        return { name: operandType.name, pointerLevel: operandType.pointerLevel + 1 };
    }


    fn visitIdentifier(node) {
        let symbol = this.currentScope.lookup(node.name, false);
        if (!symbol) {
            this.throwSemanticError(ErrorCodes.ERR_UNDECLARED_VARIABLE, node, {
                variableName: node.name
            });
        }
        return symbol.type; 
    }
    
    fn visitIntegerLiteral(node) { return getLiteralType(node); }
    fn visitRealLiteral(node) { return getLiteralType(node); }
    fn visitBooleanLiteral(node) { return getLiteralType(node); }
    fn visitNullLiteral(node) { return getLiteralType(node); }
    fn visitCharLiteral(node) { return getLiteralType(node); }
    fn visitStringLiteral(node) { return getLiteralType(node); }

    fn visitBlockStatement(node) {
        let newScope = new ScopedSymbolTable("block", this.currentScope.scopeLevel + 1, this.currentScope);
        let savedScope = this.currentScope;
        this.currentScope = newScope;
        
        for (statement in node.statements) {
            this.visit(statement);
        }
        
        this.currentScope = savedScope;
        return null;
    }

    fn visitParameter(node) {
        if (node.typeAnnotation.pointerLevel == 0 && !this.validBaseTypes[node.typeAnnotation.name]) {
             this.throwSemanticError(ErrorCodes.ERR_INVALID_BASE_TYPE, node, {
                typeName: node.typeAnnotation.name,
                validTypes: this.validBaseTypes.keys().join(", ")
            });
        }

        let symbolName = node.name.name;
        let symbol = new Symbol(symbolName, node.typeAnnotation, "parameter", false); 
        
        if (!this.currentScope.define(symbol)) {
             this.throwSemanticError(ErrorCodes.ERR_VARIABLE_REDEFINITION, node, {
                variableName: symbolName
            });
        }
        
        return null; 
    }
    
    fn visitFunctionLiteral(node) {
        let newScope = new ScopedSymbolTable("function", this.currentScope.scopeLevel + 1, this.currentScope);
        let savedScope = this.currentScope;
        this.currentScope = newScope;
        
        for (param in node.parameters) {
            this.visit(param);
        }
        
        this.visit(node.body);
        
        this.currentScope = savedScope;
        
        return null; 
    }
    
    fn visitFunctionStatement(node) {
        let symbol = new Symbol(node.name.name, { name: "function", pointerLevel: 0 }, "function", true);
        if (!this.currentScope.define(symbol)) {
             this.throwSemanticError(ErrorCodes.ERR_VARIABLE_REDEFINITION, node, {
                variableName: node.name.name
            });
        }

        this.visit(node.func);
    }
}