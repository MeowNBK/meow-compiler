import { ScopedSymbolTable, Symbol } from "middle-end/symbolTable.meow";
import { Diagnostic, ErrorCodes } from "frontend/diagnostic.meow";
import * as System from "system"; // Để exit khi có lỗi

/**
 * Quản lý trạng thái cho *một* cấp độ hàm (function).
 * Mỗi khi 'enter' một FunctionLiteral, một AnalyzerState mới sẽ được tạo.
 * Nó tương tự như 'CompilerState' cũ, nhưng chỉ tập trung vào scope.
 */
class AnalyzerState {
    fn init() {
        // scope_stack là một stack các Bảng Ký hiệu (SymbolTable) 
        // cho các block lồng nhau bên trong *một* hàm.
        this.scope_stack = [];
        this.current_scope = null; // Trỏ đến scope_stack[scope_stack.size() - 1]

        // Dùng để gán một ID (slot) duy nhất cho mỗi biến local TRONG HÀM NÀY.
        // Tương đương với 'localCount' trong CodeGenerator cũ.
        this.local_count = 0; 
        
        // Danh sách các upvalue mà hàm này "bắt" được từ bên ngoài
        // Cấu trúc: [ { index: int, isLocal: bool, name: string }, ... ]
        // 'index': 
        //    - Nếu isLocal=true: là 'local_index' (slot) của biến ở HÀM CHA.
        //    - Nếu isLocal=false: là 'upvalue_index' của HÀM CHA.
        // 'isLocal':
        //    true = "bắt" một BIẾN LOCAL của HÀM CHA TRỰC TIẾP
        //    false = "bắt" một UPVALUE của HÀM CHA TRỰC TIẾP
        this.upvalues = [];
    }
}

/**
 * ScopeAnalyzer
 * Nhiệm vụ:
 * 1. Đi qua (walk) cây AST (từ parser).
 * 2. Xây dựng các SymbolTable cho mọi scope.
 * 3. Giải quyết (Resolve) *mọi* Identifier (biến).
 * 4. "Trang trí" (Annotate) các nút AST với thông tin giải quyết (resolution).
 *
 * Chạy SAU Parser, TRƯỚC CodeGenerator.
 */
export class ScopeAnalyzer {
    fn init(ast) {
        this.ast = ast;
        this.states = [];
        this.currentState = null;
        this.currentClassScope = null;
    }

    fn throwError(code, node, replacements) {
        // Dùng lại ErrorCodes của SemanticAnalyzer cũ
        print(Diagnostic.SemanticErr(code, node, replacements));
        System.exit(42);
    }


    fn enterState() {
        let newState = new AnalyzerState();
        this.states.push(newState);
        this.currentState = newState;
    }

    fn exitState() {
        let finishedState = this.states.pop();
        if (this.states.size() > 0) {
            this.currentState = this.states[this.states.size() - 1];
        } else {
            this.currentState = null;
        }
        return finishedState.upvalues;
    }
    fn enterScope() {
        let parentScope = null;
        if (this.currentState.scope_stack.size() > 0) {
            parentScope = this.currentState.scope_stack[this.currentState.scope_stack.size() - 1];
        }
        let newScope = new ScopedSymbolTable(
            "block", // Tên scope (chỉ để debug)
            parentScope ? parentScope.scopeLevel + 1 : 1,
            parentScope
        );
        this.currentState.scope_stack.push(newScope);
        this.currentState.current_scope = newScope;
        return newScope;
    }

    fn exitScope() {
        this.currentState.scope_stack.pop();
        if (this.currentState.scope_stack.size() > 0) {
            this.currentState.current_scope = this.currentState.scope_stack[this.currentState.scope_stack.size() - 1];
        } else {
            this.currentState.current_scope = null;
        }
    }

    fn _findLocalInCurrentState(name) {
        for (let i = this.currentState.scope_stack.size() - 1; i >= 0; --i) {
            let scope = this.currentState.scope_stack[i];
            let symbol = scope.lookup(name, true);
            if (symbol) {
                return {
                    "type": "local",
                    "symbol": symbol
                };
            }
        }
        return null;
    }

    fn _findUpvalueRecursive(name, parentStateIndex) {
        if (parentStateIndex < 0) {
            return null;
        }

        let parentState = this.states[parentStateIndex];
        let childState = this.states[parentStateIndex + 1];
        for (let i = parentState.scope_stack.size() - 1; i >= 0; --i) {
            let scope = parentState.scope_stack[i];
            let symbol = scope.lookup(name, true);
            if (symbol) {
                symbol.isCaptured = true;
                return this._addUpvalueToState(
                    { "isLocal": true, "index": symbol.index, "name": symbol.name }, 
                    childState
                );
            }
        }

        if (parentStateIndex > 0) {
            let resultFromGrandparent = this._findUpvalueRecursive(name, parentStateIndex - 1);
            if (resultFromGrandparent != null) {
                return this._addUpvalueToState(
                    { "isLocal": false, "index": resultFromGrandparent.index, "name": name }, 
                    childState
                );
            }
        }

        return null;
    }

    fn _addUpvalueToState(desc, state) {
        for (let i = 0; i < state.upvalues.size(); ++i) {
            let d = state.upvalues[i];
            if (d.index == desc.index && d.isLocal == desc.isLocal) {
                return { "type": "upvalue", "index": i, "name": desc.name };
            }
        }
        
        let newIndex = state.upvalues.size();
        state.upvalues.push(desc); 
        return { "type": "upvalue", "index": newIndex, "name": desc.name };
    }

    fn _resolveVariable(name) {
        let localResult = this._findLocalInCurrentState(name);
        if (localResult) {
            return localResult;
        }

        if (this.states.size() > 1) {
            let upvalueResult = this._findUpvalueRecursive(name, this.states.size() - 2);
            if (upvalueResult) {
                return upvalueResult;
            }
        }
        return { "type": "global", "name": name };
    }

    fn analyze() {
        this.visit(this.ast);
    }

    fn visit(node) {
        if (node == null) return;
        let visitorFnName = "visit" + node.type; 
        let visitorFn = this[visitorFnName];
        
        if (visitorFn) {
            return visitorFn(node);
        }
        for (childKey in node.keys()) {
            let child = node[childKey];
            if (typeof(child) == "object" && child != null && child.type) {
                this.visit(child);
            } else if (typeof(child) == "array") {
                for (item in child) this.visit(item);
            }
        }
    }

    fn visitProgram(node) {
        this.enterState();
        this.enterScope();
        
        for (statement in node.body) {
            this.visit(statement);
        }
        
        this.exitScope();
        this.exitState();
    }

    fn visitBlockStatement(node) {
        this.enterScope();
        for (statement in node.statements) {
            this.visit(statement);
        }
        this.exitScope();
    }

    fn _defineAndAnnotate(nameNode, isConstant, kind) {
        let name = nameNode.name;
        
        if (this.currentState.current_scope.lookup(name, true)) {
            this.throwError(ErrorCodes.ERR_VARIABLE_REDEFINITION, nameNode, {
                variableName: name
            });
        }
        
        let symbol = new Symbol(name, null, kind, isConstant);
        
        symbol.index = this.currentState.local_count;
        this.currentState.local_count = this.currentState.local_count + 1;
        
        this.currentState.current_scope.define(symbol);
        
        nameNode.resolution = {
            "type": "local",
            "symbol": symbol
        };
    }

    fn visitLetStatement(node) {
        if (node.value) {
            this.visit(node.value);
        }
        
        this._defineAndAnnotate(node.name, node.isConstant, "variable");
    }

    fn visitFunctionStatement(node) {
        this._defineAndAnnotate(node.name, true, "function");
        
        this.visit(node.func);
    }
    
    fn visitClassStatement(node) {
        this._defineAndAnnotate(node.name, true, "class");

        if (node.superclass) {
            this.visit(node.superclass);
        }
        let classScope = new ScopedSymbolTable(
            "class:" + node.name.name,
            this.currentState.current_scope.scopeLevel + 1,
            this.currentState.current_scope 
        );
        let savedScope = this.currentState.current_scope;
        let savedClassScope = this.currentClassScope;

        this.currentState.current_scope = classScope;
        this.currentClassScope = classScope;
        for (method in node.methods) {
            this._defineAndAnnotate(method.name, true, "function");
        }
        
        for (method in node.methods) {
            this.visit(method.func); 
        }

        this.currentState.current_scope = savedScope;
        this.currentClassScope = savedClassScope;
    }

    fn visitFunctionLiteral(node) {
        this.enterState();
        let paramScope = this.enterScope();
        for (paramNode in node.parameters) {
            this._defineAndAnnotate(paramNode, false, "parameter");
        }
        this.visit(node.body);
        this.exitScope();
        
        let upvalues = this.exitState();
        node.resolved_upvalues = upvalues;
    }

    fn visitIdentifier(node) {
        if (node.resolution != null) {
            return;
        }
        
        node.resolution = this._resolveVariable(node.name);
    }
    
    fn visitAssignmentExpression(node) {
        this.visit(node.value);
        
        this.visit(node.target);
        
        let target = node.target;
        if (target.type == "Identifier") {
            if (target.resolution == null) {
                this.throwError(ErrorCodes.ERR_UNDECLARED_VARIABLE, target, {
                    variableName: target.name
                });
            }
            
            if (target.resolution.type == "local" && target.resolution.symbol.isConstant) {
                this.throwError(ErrorCodes.ERR_ASSIGNMENT_TO_CONST, node, {
                    variableName: target.name
                });
            }
        }
    }
    
    fn visitForStatement(node) {
        this.enterScope();
        if (node.init) this.visit(node.init);
        if (node.condition) this.visit(node.condition);
        if (node.update) this.visit(node.update);
        this.visit(node.body); 
        
        this.exitScope();
    }
    
    fn visitForInStatement(node) {
        this.visit(node.collection);
        
        this.enterScope();
        this._defineAndAnnotate(node.variable, false, "variable");
        
        this.visit(node.body);
        this.exitScope();
    }
    
    fn visitWhileStatement(node) {
        this.visit(node.condition);
        this.visit(node.body);
    }
    
    fn visitDoWhileStatement(node) {
        this.visit(node.body);
        this.visit(node.condition);
    }

    fn visitIfStatement(node) {
        this.visit(node.condition);
        this.visit(node.thenBranch);
        if (node.elseBranch) this.visit(node.elseBranch);
    }
    
    fn visitTryStatement(node) {
        this.visit(node.tryBlock);
        
        this.enterScope();
        if (node.catchVariable) {
            this._defineAndAnnotate(node.catchVariable, false, "variable");
        }
        this.visit(node.catchBlock);
        this.exitScope();
    }
    
    fn visitSwitchStatement(node) {
        this.visit(node.value);
        
        this.enterScope();
        for (cas in node.cases) {
            this.visit(cas);
        }
        this.exitScope();
    }
    
    fn visitSwitchCase(node) {
        if (node.value) {
            this.visit(node.value);
        }
        for (stmt in node.statements) {
            this.visit(stmt);
        }
    }
        
    fn visitReturnStatement(node) {
        if (node.value) this.visit(node.value);
    }

    fn visitThrowStatement(node) {
        if (node.argument) this.visit(node.argument);
    }
    
    fn visitImportStatement(node) {
        this.visit(node.path);
        
        if (node.namespaceImport != null) {
            this._defineAndAnnotate(node.namespaceImport, true, "module");
        } else if (node.namedImports.size() > 0) {
            for (importId in node.namedImports) {
                this._defineAndAnnotate(importId, true, "import");
            }
        }
    }

    fn visitExportStatement(node) {
        if (node.declaration) {
            this.visit(node.declaration);
        }
        // (Nếu là 'export { var }' thì cần visit specifiers,
        // nhưng AST cũ không hỗ trợ rõ ràng)
    }

    fn visitExpressionStatement(node) {
        this.visit(node.expression);
    }

    fn visitBinaryExpression(node) {
        this.visit(node.left);
        this.visit(node.right);
    }
    
    fn visitUnaryExpression(node) {
        this.visit(node.operand);
    }
    
    fn visitCallExpression(node) {
        this.visit(node.callee);
        for (arg in node.args) {
            this.visit(arg);
        }
    }
    
    fn visitIndexExpression(node) {
        this.visit(node.object);
        this.visit(node.index);
    }
    
    fn visitTernaryExpression(node) {
        this.visit(node.condition);
        this.visit(node.thenBranch);
        this.visit(node.elseBranch);
    }
    
    fn visitPropertyAccess(node) {
        if (node.object.type == "ThisExpression") {
            if (this.currentClassScope) {
                let propName = node.property.name;
                
                let symbol = this.currentClassScope.lookup(propName, false);
                
                if (!symbol) {
                    symbol = new Symbol(propName, null, "property", false); 
                    
                    this.currentClassScope.define(symbol);
                }
                
                node.property.resolution = {
                    "type": "class_member",
                    "symbol": symbol
                };
                
                // Không cần visit 'object' (là 'this')
                return;
            }
        }

        // --- Logic cũ ---
        // Nếu không phải 'this.something', chỉ visit 'object'
        this.visit(node.object);
        // Không visit(node.property) vì nó là 'lá'
    }

    fn visitNewExpression(node) {
        this.visit(node.expression);
    }
    
    fn visitSuperExpression(node) {
        // (Không visit 'method' vì nó giống 'property')
    }
    
    fn visitPrefixUpdateExpression(node) {
        this.visit(node.operand);
    }
    
    fn visitPostfixUpdateExpression(node) {
        this.visit(node.operand);
    }
    
    fn visitSpreadExpression(node) {
        this.visit(node.expression);
    }
    
    fn visitArrayLiteral(node) {
        for (elem in node.elements) {
            this.visit(elem);
        }
    }
    
    fn visitObjectLiteral(node) {
        for (prop in node.properties) {
            this.visit(prop.key);
            this.visit(prop.value);
        }
    }
    
    fn visitTemplateLiteral(node) {
        for (part in node.parts) {
            this.visit(part);
        }
    }
    
    fn visitIntegerLiteral(node) {}
    fn visitRealLiteral(node) {}
    fn visitStringLiteral(node) {}
    fn visitBooleanLiteral(node) {}
    fn visitNullLiteral(node) {}
    fn visitCharLiteral(node) {}
    fn visitThisExpression(node) {}
    fn visitBreakStatement(node) {}
    fn visitContinueStatement(node) {}

}