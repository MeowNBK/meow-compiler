import * as System from "system";

export class TypeInferrer {
    fn init(ast) {
        this.ast = ast;
        this.scopeStack = [{}]; 
        this.currentFuncSymbol = null;
        this.totalVariables = 0;
        this.inferredCount = 0;
        this.unknownVars = [];
        this.logs = [];
        
        this.paramHints = {}; 
        
        this.setupBuiltins();
    }

    fn getSafeType(node) {
        if (node == null) return "none";
        if (node.type == null) return "none"; 
        return node.type;
    }

    // [NEW] Ki·ªÉm tra xem type m·ªõi c√≥ c·ª• th·ªÉ h∆°n type c≈© kh√¥ng
    fn isMoreSpecific(oldType, newType) {
        if (oldType == newType) return false;
        if (oldType == "unknown" && newType != "unknown") return true;
        // array<unknown> < array<int>
        if (oldType == "array<unknown>" && newType.indexOf("array<") == 0) return true;
        // array < array<int>
        if (oldType == "array" && newType.indexOf("array<") == 0) return true;
        return false;
    }

    fn analyze() {
        print("--- üöÄ B·∫ÆT ƒê·∫¶U PH√ÇN T√çCH TYPE (V6 - ITERATIVE INFERENCE) ---");
        
        print("... [Pass 1] Qu√©t ƒë·ªãnh nghƒ©a...");
        this.scanDeclarations(this.ast);
        
        // Ch·∫°y 2 l·∫ßn Pass 2 ƒë·ªÉ hint lan truy·ªÅn
        // L·∫ßn 1: Thu th·∫≠p hint t·ª´ c√°c l·ªánh g·ªçi h√†m
        print("... [Pass 2A] Ph√¢n t√≠ch lu·ªìng & Thu th·∫≠p Hints...");
        this.logs = [];     // Clear log r√°c l·∫ßn 1
        this.unknownVars = [];
        this.inferredCount = 0;
        this.totalVariables = 0;
        this.visit(this.ast);

        // L·∫ßn 2: √Åp d·ª•ng hint v√†o ƒë·ªãnh nghƒ©a h√†m v√† t√≠nh to√°n l·∫°i
        print("... [Pass 2B] T·ªëi ∆∞u h√≥a d·ª±a tr√™n Hints...");
        // Reset counter ƒë·ªÉ t√≠nh ch√≠nh x√°c cho l·∫ßn ch·ªët h·∫°
        this.logs = [];
        this.unknownVars = [];
        this.inferredCount = 0;
        this.totalVariables = 0;
        this.visit(this.ast);

        this.printStats();
        print("--- K·∫æT TH√öC ---");
    }

    // --- SYMBOL TABLE & BUILTINS ---
    fn enterScope() { this.scopeStack.push({}); }
    fn exitScope() { this.scopeStack.pop(); }
    fn currentScope() { return this.scopeStack[this.scopeStack.size() - 1]; }

    fn defineSymbol(name, kind, type) {
        let info = { "kind": kind, "type": type, "returnType": "unknown", "props": {} };
        this.currentScope()[name] = info;
        return info;
    }

    fn resolveSymbol(name) {
        for (let i = this.scopeStack.size() - 1; i >= 0; --i) {
            let scope = this.scopeStack[i];
            if (scope[name]) return scope[name];
        }
        return null;
    }

    fn setupBuiltins() {
        let g = this.scopeStack[0];
        // 1. GLOBAL FUNCTIONS
        g["print"] = { "kind": "func", "type": "function", "returnType": "void" };
        g["typeof"] = { "kind": "func", "type": "function", "returnType": "string" };
        g["len"] = { "kind": "func", "type": "function", "returnType": "int" };
        g["int"] = { "kind": "func", "type": "function", "returnType": "int" };
        g["real"] = { "kind": "func", "type": "function", "returnType": "float" };
        g["bool"] = { "kind": "func", "type": "function", "returnType": "bool" };
        g["str"] = { "kind": "func", "type": "function", "returnType": "string" };
        g["assert"] = { "kind": "func", "type": "function", "returnType": "void" };
        g["ord"] = { "kind": "func", "type": "function", "returnType": "int" };
        g["char"] = { "kind": "func", "type": "function", "returnType": "string" };
        g["range"] = { "kind": "func", "type": "function", "returnType": "array<int>" };
        // 2. MODULE "io"
        let ioProps = {};
        ioProps["input"] = { "kind": "func", "type": "function", "returnType": "string" };
        ioProps["read"] = { "kind": "func", "type": "function", "returnType": "string" };
        ioProps["write"] = { "kind": "func", "type": "function", "returnType": "bool" };
        ioProps["fileExists"] = { "kind": "func", "type": "function", "returnType": "bool" };
        ioProps["isDirectory"] = { "kind": "func", "type": "function", "returnType": "bool" };
        ioProps["listDir"] = { "kind": "func", "type": "function", "returnType": "array<string>" };
        ioProps["createDir"] = { "kind": "func", "type": "function", "returnType": "bool" };
        ioProps["deleteFile"] = { "kind": "func", "type": "function", "returnType": "bool" };
        ioProps["getFileTimestamp"] = { "kind": "func", "type": "function", "returnType": "int" };
        ioProps["getFileSize"] = { "kind": "func", "type": "function", "returnType": "int" };
        ioProps["renameFile"] = { "kind": "func", "type": "function", "returnType": "bool" };
        ioProps["copyFile"] = { "kind": "func", "type": "function", "returnType": "bool" };
        ioProps["getFileName"] = { "kind": "func", "type": "function", "returnType": "string" };
        ioProps["getFileStem"] = { "kind": "func", "type": "function", "returnType": "string" };
        ioProps["getFileExtension"] = { "kind": "func", "type": "function", "returnType": "string" };
        ioProps["getAbsolutePath"] = { "kind": "func", "type": "function", "returnType": "string" };
        g["io"] = { "kind": "var", "type": "object", "props": ioProps };
        // 3. MODULE "system"
        let sysProps = {};
        sysProps["argv"] = { "kind": "func", "type": "function", "returnType": "array<string>" };
        sysProps["exit"] = { "kind": "func", "type": "function", "returnType": "void" };
        sysProps["exec"] = { "kind": "func", "type": "function", "returnType": "int" };
        g["system"] = { "kind": "var", "type": "object", "props": sysProps };
        g["System"] = { "kind": "var", "type": "object", "props": sysProps };
        // 4. MODULE "json"
        let jsonProps = {};
        jsonProps["parse"] = { "kind": "func", "type": "function", "returnType": "object" };
        jsonProps["stringify"] = { "kind": "func", "type": "function", "returnType": "string" };
        g["json"] = { "kind": "var", "type": "object", "props": jsonProps };
    }

    // --- PASS 1: SCAN ---
    fn scanDeclarations(node) {
        if (node == null) return;
        let type = this.getSafeType(node);

        if (type == "Program") {
            for (stmt in node.body) this.scanDeclarations(stmt);
        }
        else if (type == "BlockStatement") {
            if (node.statements) for (stmt in node.statements) this.scanDeclarations(stmt);
        }
        else if (type == "IfStatement") {
            this.scanDeclarations(node.thenBranch);
            if (node.elseBranch) this.scanDeclarations(node.elseBranch);
        }
        else if (type == "WhileStatement" || type == "DoWhileStatement") {
            this.scanDeclarations(node.body);
        }
        else if (type == "ForStatement") {
            this.scanDeclarations(node.init);
            this.scanDeclarations(node.body);
        }
        else if (type == "TryStatement") {
            this.scanDeclarations(node.block);
            if (node.handler) this.scanDeclarations(node.handler.body);
        }
        else if (type == "FunctionStatement") {
            if (node.name && node.name.name) {
                this.defineSymbol(node.name.name, "func", "function");
            }
        }
        else if (type == "ClassStatement") {
            // [NEW] H·ªó tr·ª£ khai b√°o Class
            if (node.name && node.name.name) {
                this.defineSymbol(node.name.name, "class", "class");
            }
        }
        else if (type == "LetStatement") {
            if (node.name && node.name.name) {
                this.defineSymbol(node.name.name, "var", "unknown");
            }
        }
    }

    // --- PASS 2: VISIT ---
    fn visit(node) {
        if (node == null) return "void";
        let type = this.getSafeType(node);

        // Statements
        if (type == "Program") return this.visitProgram(node);
        if (type == "BlockStatement") return this.visitBlockStatement(node);
        if (type == "FunctionStatement") return this.visitFunctionStatement(node);
        if (type == "ClassStatement") return this.visitClassStatement(node); // [NEW]
        if (type == "LetStatement") return this.visitLetStatement(node);
        if (type == "ReturnStatement") return this.visitReturnStatement(node);
        if (type == "IfStatement") return this.visitIfStatement(node);
        if (type == "WhileStatement") return this.visitWhileStatement(node);
        if (type == "ForStatement") return this.visitForStatement(node);
        if (type == "TryStatement") return this.visitTryStatement(node);
        // Expressions
        if (type == "BinaryExpression") return this.visitBinaryExpression(node);
        if (type == "UnaryExpression") return this.visitUnaryExpression(node);
        if (type == "CallExpression") return this.visitCallExpression(node);
        if (type == "NewExpression") return this.visitNewExpression(node);
        if (type == "Identifier") return this.visitIdentifier(node);
        if (type == "AssignmentExpression") return this.visitAssignment(node);
        if (type == "MemberExpression") return this.visitMemberExpression(node);
        // Literals
        if (type == "IntegerLiteral") return "int";
        if (type == "RealLiteral") return "float";
        if (type == "StringLiteral") return "string";
        if (type == "BooleanLiteral") return "bool";
        if (type == "NullLiteral") return "null";
        if (type == "ArrayLiteral") return this.visitArrayLiteral(node);
        if (type == "ObjectLiteral") return this.visitObjectLiteral(node);
        if (type == "FunctionLiteral") return this.visitFunctionLiteral(node);

        // Fallback traverse
        if (node.keys) {
            for (key in node.keys()) {
                let child = node[key];
                if (typeof(child) == "object" && child != null && child.type) this.visit(child);
                else if (typeof(child) == "array") for (item in child) this.visit(item);
            }
        }
        return "unknown";
    }

    fn visitProgram(node) {
        for (stmt in node.body) this.visit(stmt);
        return "void";
    }

    fn visitBlockStatement(node) {
        this.enterScope();
        if (node.statements) for (stmt in node.statements) this.visit(stmt);
        this.exitScope();
        return "void";
    }

    // [NEW] X·ª≠ l√Ω Class Body
    fn visitClassStatement(node) {
        if (node.name == null) return "void";
        let className = node.name.name;
        
        // V√†o scope m·ªõi ƒë·ªÉ duy·ªát method (gi·∫£ l·∫≠p class scope)
        this.enterScope();
        if (node.methods) {
            for (method in node.methods) {
                // X·ª≠ l√Ω methods (hi·ªán t·∫°i coi nh∆∞ function th∆∞·ªùng)
                this.visit(method);
            }
        }
        this.exitScope();
        
        this.logs.push("‚úÖ [Class] ƒê√£ duy·ªát class '" + className + "'");
        return "void";
    }
    
    fn visitTryStatement(node) {
        this.visit(node.block);
        if (node.handler) {
            this.enterScope();
            if (node.handler.param) this.defineSymbol(node.handler.param.name, "var", "object");
            this.visit(node.handler.body);
            this.exitScope();
        }
        return "void";
    }

fn visitFunctionStatement(node) {
        if (node.name == null) return "void";
        let funcName = node.name.name;
        let sym = this.resolveSymbol(funcName);
        if (sym == null) sym = this.defineSymbol(funcName, "func", "function");

        this.totalVariables += 1;
        this.inferredCount += 1;
        
        let prevFunc = this.currentFuncSymbol;
        this.currentFuncSymbol = sym;

        this.enterScope();
        if (node.func && node.func.parameters) {
            for (let i = 0; i < node.func.parameters.size(); ++i) {
                let param = node.func.parameters[i];
                this.totalVariables += 1;
                
                // [NEW] Check g·ª£i √Ω t·ª´ kho
                let hintKey = funcName + "::" + str(i);
                let paramType = "unknown";
                
                if (this.paramHints[hintKey]) {
                    paramType = this.paramHints[hintKey];
                    this.logs.push("üí° [Hint] Tham s·ªë '" + param.name + "' c·ªßa '" + funcName + "' -> " + paramType);
                }
                
                this.defineSymbol(param.name, "var", paramType);
                
                // Ch·ªâ b√°o l·ªói n·∫øu v·∫´n l√† unknown
                if (paramType == "unknown") {
                    this.unknownVars.push(funcName + "::" + param.name);
                } else {
                    this.inferredCount += 1; // T√≠nh ƒëi·ªÉm coverage
                }
            }
        }
        
        if (node.func && node.func.body) this.visit(node.func.body);
        
        if (sym.returnType != "unknown") {
            this.logs.push("‚úÖ [Def] H√†m '" + funcName + "' -> " + sym.returnType);
        }
        this.exitScope();
        this.currentFuncSymbol = prevFunc;
        return "void";
    }

    fn visitLetStatement(node) {
        this.totalVariables += 1;
        if (node.name == null) return "void";
        
        let name = node.name.name;
        let existing = this.resolveSymbol(name);
        if (existing == null) existing = this.defineSymbol(name, "var", "unknown");

        let inferred = "unknown";
        if (node.value) inferred = this.visit(node.value);
        existing.type = inferred;
        if (node.value && node.value.type == "ObjectLiteral") existing.props = node.value.inferredProps;
        if (inferred != "unknown") {
            this.inferredCount += 1;
            this.logs.push("‚úÖ [Var] " + name + " : " + inferred);
        } else {
            this.unknownVars.push(name);
        }
        return "void";
    }

    // [UPDATED] Logic g√°n th√¥ng minh h∆°n
    fn visitAssignment(node) {
        let rightType = this.visit(node.value);
        let targetType = this.getSafeType(node.target);

        if (targetType == "Identifier") {
            let name = node.target.name;
            let sym = this.resolveSymbol(name);
            if (sym) {
                // Check if new type is better (more specific) than old type
                if (this.isMoreSpecific(sym.type, rightType)) {
                    let oldType = sym.type;
                    sym.type = rightType;
                    this.inferredCount += 1;
                    this.logs.push("‚ö° [Late Bind] '" + name + "' (" + oldType + ") -> " + rightType);
                }
                
                // Merge properties if assigning a new object literal
                if (node.value.type == "ObjectLiteral" && node.value.inferredProps) {
                    if (sym.props == null) sym.props = {};
                    for (let i = 0; i < node.value.inferredProps.keys().size(); ++i) {
                         let k = node.value.inferredProps.keys()[i];
                         sym.props[k] = node.value.inferredProps[k];
                    }
                }
            }
        }
        else if (targetType == "MemberExpression") {
            let objName = null;
            if (node.target.object.type == "Identifier") objName = node.target.object.name;
            if (objName) {
                let sym = this.resolveSymbol(objName);
                if (sym && sym.props && node.target.property.type == "Identifier") {
                    sym.props[node.target.property.name] = { "type": rightType };
                }
            }
        }
        return rightType;
    }

    fn visitIdentifier(node) {
        if (node.name == null) return "unknown";
        let sym = this.resolveSymbol(node.name);
        if (sym) return sym.type;
        return "unknown";
    }

    fn visitMemberExpression(node) {
        let objType = this.visit(node.object);
        if (node.property && node.property.type == "Identifier") {
            let propName = node.property.name;
            // 1. Length/Size property
            if (propName == "length" || propName == "size") {
                if (objType == "string" || objType == "array" || objType.indexOf("array<") == 0) return "int";
            }
            // 2. Object property
            if (node.object.type == "Identifier") {
                let sym = this.resolveSymbol(node.object.name);
                if (sym && sym.props && sym.props[propName]) return sym.props[propName].type;
            }
        }
        return "unknown";
    }

    fn visitObjectLiteral(node) {
        let props = {};
        if (node.properties) {
            for (prop in node.properties) {
                let key = prop.key;
                let valType = this.visit(prop.value);
                props[key] = { "type": valType };
            }
        }
        node.inferredProps = props;
        return "object";
    }

    fn visitArrayLiteral(node) {
        if (node.elements == null || node.elements.size() == 0) return "array<unknown>";
        let firstType = null;
        let isConsistent = true;
        for (let i = 0; i < node.elements.size(); ++i) {
            let t = this.visit(node.elements[i]);
            if (firstType == null) firstType = t;
            else if (firstType != t) isConsistent = false;
        }
        if (isConsistent && firstType != "unknown") return "array<" + firstType + ">";
        return "array";
    }

    fn resolveMethodCall(objType, methodName) {
        // STRING methods
        if (objType == "string") {
            if (methodName == "split") return "array<string>";
            if (methodName == "upper" || methodName == "lower" || methodName == "trim" || 
                methodName == "replace" || methodName == "substring" || methodName == "slice" || 
                methodName == "repeat" || methodName == "padLeft" || methodName == "padRight" || 
                methodName == "join" || methodName == "charAt") return "string";
            if (methodName == "startsWith" || methodName == "endsWith" || 
                methodName == "contains" || methodName == "equalsIgnoreCase") return "bool";
            if (methodName == "indexOf" || methodName == "lastIndexOf" || 
                methodName == "charCodeAt" || methodName == "size" || methodName == "length") return "int";
        }
        
        // ARRAY methods
        if (objType.indexOf("array") == 0) {
            if (methodName == "push" || methodName == "findIndex" || methodName == "size") return "int";
            if (methodName == "pop" || methodName == "find") {
                 if (objType.indexOf("<") != -1) {
                     return objType.substring(objType.indexOf("<") + 1, objType.indexOf(">"));
                 }
                 return "unknown";
            }
            if (methodName == "slice" || methodName == "map" || methodName == "filter" || 
                methodName == "reverse" || methodName == "sort") return objType;
            if (methodName == "join") return "string";
            if (methodName == "forEach" || methodName == "reserve" || methodName == "resize") return "void";
        }

        // OBJECT methods
        if (objType == "object") {
            if (methodName == "keys") return "array<string>";
            if (methodName == "values") return "array<unknown>";
            if (methodName == "entries") return "array<array>";
            if (methodName == "has") return "bool";
            if (methodName == "merge") return "object";
        }
        return "unknown";
    }

    fn visitCallExpression(node) {
        let calleeType = this.getSafeType(node.callee);
        // 1. Direct Identifier Call

        if (calleeType == "Identifier") {
            let funcName = node.callee.name;
            if (node.arguments) {
                for (let i = 0; i < node.arguments.size(); ++i) {
                    let argType = this.visit(node.arguments[i]);
                    if (argType != "unknown") {
                        // L∆∞u g·ª£i √Ω: H√†m A, tham s·ªë th·ª© i nh·∫≠n ki·ªÉu T
                        // Key: "funcName::i"
                        let key = funcName + "::" + str(i);
                        
                        // ∆Øu ti√™n ki·ªÉu c·ª• th·ªÉ h∆°n
                        if (this.paramHints[key]) {
                             if (this.isMoreSpecific(this.paramHints[key], argType)) {
                                 this.paramHints[key] = argType;
                             }
                        } else {
                             this.paramHints[key] = argType;
                        }
                    }
                }
            }
        }

        if (calleeType == "Identifier") {
            let funcName = node.callee.name;
            let sym = this.resolveSymbol(funcName);
            if (sym && sym.kind == "func" && sym.returnType != "unknown") return sym.returnType;
        }
        // 2. Member Expression Call
        else if (calleeType == "MemberExpression") {
            let objType = this.visit(node.callee.object);
            let propName = node.callee.property.name;
            let methodRet = this.resolveMethodCall(objType, propName);
            if (methodRet != "unknown") return methodRet;

            if (node.callee.object.type == "Identifier") {
                let objName = node.callee.object.name;
                let sym = this.resolveSymbol(objName);
                if (sym && sym.props && sym.props[propName]) {
                    return sym.props[propName].returnType;
                }
            }
        }
        if (node.arguments) for (arg in node.arguments) this.visit(arg);
        return "unknown";
    }

    fn visitNewExpression(node) {
        if (this.getSafeType(node.callee) == "Identifier") {
            if (node.arguments) for (arg in node.arguments) this.visit(arg);
            return node.callee.name;
        }
        return "object";
    }

    // [UPDATED] Reverse Inference (Suy lu·∫≠n ng∆∞·ª£c t·ª´ ph√©p to√°n)
    fn visitBinaryExpression(node) {
        let left = this.visit(node.left);
        let right = this.visit(node.right);
        let op = node.operator;

        // 1. Reverse Inference: N·∫øu bi·∫øn ƒëang l√† unknown m√† b·ªã ƒëem ra c·ªông tr·ª´ nh√¢n chia -> √©p v·ªÅ int
        if (op == "-" || op == "*" || op == "/" || op == "%") {
             if (left == "unknown" && node.left.type == "Identifier") {
                 let sym = this.resolveSymbol(node.left.name);
                 if (sym) { sym.type = "int"; left = "int"; this.logs.push("üîç [Inferred] " + node.left.name + " -> int (do d√πng " + op + ")"); this.inferredCount += 1; }
             }
             if (right == "unknown" && node.right.type == "Identifier") {
                 let sym = this.resolveSymbol(node.right.name);
                 if (sym) { sym.type = "int"; right = "int"; this.logs.push("üîç [Inferred] " + node.right.name + " -> int (do d√πng " + op + ")"); this.inferredCount += 1; }
             }
        }
        // V·ªõi ph√©p c·ªông, c·∫©n th·∫≠n v√¨ c√≥ th·ªÉ l√† string
        if (op == "+") {
             // N·∫øu m·ªôt b√™n ƒë√£ l√† int/float, b√™n kia kh·∫£ nƒÉng cao c≈©ng v·∫≠y (n·∫øu ko ph·∫£i string)
             if (left == "int" && right == "unknown" && node.right.type == "Identifier") {
                 let sym = this.resolveSymbol(node.right.name);
                 if (sym) { sym.type = "int"; right = "int"; this.logs.push("üîç [Inferred] " + node.right.name + " -> int (do + v·ªõi int)"); this.inferredCount += 1; }
             }
             if (right == "int" && left == "unknown" && node.left.type == "Identifier") {
                 let sym = this.resolveSymbol(node.left.name);
                 if (sym) { sym.type = "int"; left = "int"; this.logs.push("üîç [Inferred] " + node.left.name + " -> int (do + v·ªõi int)"); this.inferredCount += 1; }
             }
        }

        if (op == "+") {
            if (left == "string" || right == "string") return "string";
        }
        if (op == "+" || op == "-" || op == "*" || op == "/" || op == "%") {
            if (left == "float" || right == "float") return "float";
            if (left == "int" && right == "int") return "int";
            // Fallback: n·∫øu c√≥ 1 c√°i l√† int th√¨ k·∫øt qu·∫£ t·∫°m coi l√† int
            if (left == "int" || right == "int") return "int";
            return "unknown";
        }
        if (op == "==" || op == "!=" || op == "<" || op == ">" || op == "<=" || op == ">=") return "bool";
        if (op == "&&" || op == "||") return "bool";
        return "unknown";
    }

    fn visitUnaryExpression(node) {
        let arg = this.visit(node.argument);
        let op = node.operator;
        if (op == "!") return "bool";
        if (op == "-") return arg;
        return "unknown";
    }

    fn visitFunctionLiteral(node) {
        let prevFunc = this.currentFuncSymbol;
        this.currentFuncSymbol = { "kind": "func", "type": "function", "returnType": "unknown" };
        this.enterScope();
        if (node.parameters) for (param in node.parameters) this.defineSymbol(param.name, "var", "unknown");
        if (node.body) this.visit(node.body);
        this.exitScope();
        this.currentFuncSymbol = prevFunc;
        return "function";
    }

    fn visitReturnStatement(node) {
        if (node.value) {
            let retType = this.visit(node.value);
            if (this.currentFuncSymbol != null) {
                if (this.currentFuncSymbol.returnType == "unknown" && retType != "unknown") {
                     this.currentFuncSymbol.returnType = retType;
                }
                else if (this.currentFuncSymbol.returnType != "unknown" && retType != "unknown" && this.currentFuncSymbol.returnType != retType) {
                    this.currentFuncSymbol.returnType = "any";
                }
            }
            return retType;
        }
        return "void";
    }

    fn visitIfStatement(node) {
        this.visit(node.condition);
        this.visit(node.thenBranch);
        if (node.elseBranch) this.visit(node.elseBranch);
        return "void";
    }

    fn visitWhileStatement(node) {
        this.visit(node.condition);
        this.visit(node.body);
        return "void";
    }

    fn visitForStatement(node) {
        this.enterScope();
        if (node.init) this.visit(node.init);
        if (node.test) this.visit(node.test);
        if (node.update) this.visit(node.update);
        if (node.body) this.visit(node.body);
        this.exitScope();
        return "void";
    }

    fn printStats() {
        print("\nüìä B√ÅO C√ÅO C√ÅC BI·∫æN KH√îNG SUY LU·∫¨N ƒê∆Ø·ª¢C (MISSING TYPES):");
        
        let limit = this.unknownVars.size();
        let displayLimit = 30; // Hi·ªÉn th·ªã t·ªëi ƒëa 30 l·ªói ƒë·ªÉ ƒë·ª° spam

        if (limit == 0) {
            print("‚ú® Tuy·ªát v·ªùi! Kh√¥ng c√≤n bi·∫øn n√†o l√† unknown.");
        } else {
            for (let i = 0; i < limit; ++i) {
                if (i < displayLimit) {
                    print("‚ùå [Unknown] " + this.unknownVars[i]);
                }
            }
            if (limit > displayLimit) {
                print("... v√† " + str(limit - displayLimit) + " bi·∫øn kh√°c ƒëang 'm√π' type.");
            }
        }

        let percentage = 0;
        if (this.totalVariables > 0) percentage = (this.inferredCount * 100) / this.totalVariables;

        print("-------------------------------------");
        print("ƒê·ªô ph·ªß (Coverage)     : " + str(percentage) + "% (" + str(this.inferredCount) + "/" + str(this.totalVariables) + ")");
        print("-------------------------------------");
        
        // Hint ƒë·ªÉ b·∫°n bi·∫øt l√Ω do
        print("üí° G·ª¢I √ù: ƒêa s·ªë [Unknown] th∆∞·ªùng l√† 'Tham s·ªë h√†m' (Function Parameters).");
        print("   Type Inferrer hi·ªán t·∫°i ch∆∞a nh√¨n v√†o n∆°i g·ªçi h√†m ƒë·ªÉ ƒëo√°n ki·ªÉu tham s·ªë.");
    }
}