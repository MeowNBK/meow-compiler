import * as System from "system";
import { setupBuiltins } from "middle-end/typeInferrer/builtins.meow";
import * as ExprVisitor from "middle-end/typeInferrer/visitors/expression.meow";
import * as StmtVisitor from "middle-end/typeInferrer/visitors/statement.meow";
import * as PathUtils from "backend/utils/pathUtils.meow";

export class TypeInferrer {
    fn init(ast) {
        this.ast = ast;
        this.scopeStack = [{}]; 
        this.currentFuncSymbol = null;
        this.currentClassName = null; 
        this.classRegistry = {};      
        this.totalVariables = 0;
        this.inferredCount = 0;
        this.unknownVars = [];
        this.logs = [];
        this.paramHints = {};

        // this.paramHints["Lexer::makeToken::0"] = "int";    // type l√† int
        // this.paramHints["Lexer::makeToken::1"] = "string"; // lexeme l√† string
        // this.paramHints["Lexer::makeToken::2"] = "int";    // startLine l√† int
        // this.paramHints["Lexer::makeToken::3"] = "int";    // startCol l√† int

        // // 2. G·ª£i √Ω cho Parser.consume(type, code)
        // this.paramHints["Parser::consume::0"] = "int"; // type l√† int
        // this.paramHints["Parser::consume::1"] = "string"; // code l·ªói (String)

        // // 3. G·ª£i √Ω cho Parser.throwParseErr(code, token)
        // this.paramHints["Parser::throwParseErr::0"] = "string"; 
        // this.paramHints["Parser::throwParseErr::1"] = "object"; // Token l√† object
        
        this.hasChanged = false; // Flag for fixed-point iteration
        
        setupBuiltins(this.scopeStack[0]);
    }

    fn getSafeType(node) {
        if (node == null) return "none";
        if (node.type == null) return "none"; 
        return node.type;
    }

    fn markChange() {
        this.hasChanged = true;
    }

    fn isMoreSpecific(oldType, newType) {
        if (oldType == newType) return false;
        if (newType == "unknown") return false; 
        
        if (oldType == "unknown" && newType != "unknown") return true;
        if (oldType == "null" && newType != "null") return true;
        if (oldType == "void" && newType != "void") return true;
        
        // Array refinement
        if (oldType == "array" && newType.indexOf("array<") == 0) return true;
        if (oldType == "array<unknown>" && newType.indexOf("array<") == 0) return true;
        
        // Number Promotion
        if (oldType == "int" && newType == "float") return true;
        
        return false;
    }

    fn addUnknown(name, node) {
        let info = { "name": name, "file": "?", "line": 0, "col": 0 };
        let token = null;
        if (node && node.token) token = node.token;
        else if (node && node.name && node.name.token) token = node.name.token;
        if (token) {
            info.file = token.file; info.line = token.line; info.col = token.col;
        }
        this.unknownVars.push(info);
    }

    fn analyze() {
        print("--- üöÄ B·∫ÆT ƒê·∫¶U PH√ÇN T√çCH TYPE (Optimized: Fixed-Point Iteration) ---");
        
        print("... [Phase 1] Qu√©t ƒë·ªãnh nghƒ©a (Symbol Discovery)...");
        this.scanDeclarations(this.ast);
        
        print("... [Phase 2] V√≤ng l·∫∑p suy lu·∫≠n (Inference Loop)...");
        let pass = 1;
        let maxPasses = 15; 
        let running = true;
        
        while (running && pass <= maxPasses) {
            this.hasChanged = false;
            this.inferredCount = 0;
            this.totalVariables = 0;
            
            // Ch·∫°y visitor
            this.visit(this.ast);
            
            if (this.hasChanged) {
                print("    Layer " + str(pass) + ": üîÑ Ph√°t hi·ªán thay ƒë·ªïi, ti·∫øp t·ª•c t·ªëi ∆∞u...");
                pass += 1;
            } else {
                print("    Layer " + str(pass) + ": ‚úÖ H·ªôi t·ª• (Stable). D·ª´ng.");
                running = false;
            }
        }

        // Final report pass (Clean run to count stats)
        this.unknownVars = [];
        this.inferredCount = 0;
        this.totalVariables = 0;
        this.visit(this.ast);

        this.printStats();
        print("--- K·∫æT TH√öC ---");
    }

    // --- SYMBOL TABLE ---
    fn enterScope() { this.scopeStack.push({}); }
    fn exitScope() { this.scopeStack.pop(); }
    fn currentScope() { return this.scopeStack[this.scopeStack.size() - 1]; }

    fn defineSymbol(name, kind, type) {
        let scope = this.currentScope();
        if (scope[name]) {
            if (scope[name].type == "unknown" && type != "unknown") {
                scope[name].type = type;
                scope[name].kind = kind;
                this.markChange();
            }
            return scope[name];
        }
        let info = { "kind": kind, "type": type, "returnType": "unknown", "props": {} };
        scope[name] = info;
        return info;
    }

    fn resolveSymbol(name) {
        for (let i = this.scopeStack.size() - 1; i >= 0; --i) {
            let scope = this.scopeStack[i];
            if (scope[name]) return scope[name];
        }
        return null;
    }

    fn scanDeclarations(node) {
        if (node == null) return;
        let type = this.getSafeType(node);
        if (type == "Program") { for (stmt in node.body) this.scanDeclarations(stmt); }
        else if (type == "BlockStatement") { if (node.statements) for (stmt in node.statements) this.scanDeclarations(stmt); }
        else if (type == "FunctionLiteral") { if (node.body) this.scanDeclarations(node.body); }
        else if (type == "ArrayLiteral") { if (node.elements) for (elem in node.elements) this.scanDeclarations(elem); }
        else if (type == "IfStatement") { this.scanDeclarations(node.thenBranch); if (node.elseBranch) this.scanDeclarations(node.elseBranch); }
        else if (type == "FunctionStatement") {
            if (node.name && node.name.name) this.defineSymbol(node.name.name, "func", "function");
            if (node.func && node.func.body) this.scanDeclarations(node.func.body);
        }
        else if (type == "ClassStatement") {
            if (node.name && node.name.name) this.defineSymbol(node.name.name, "class", "class");
        }
        else if (type == "LetStatement") {
            if (node.name && node.name.name) {
                let varType = "unknown";
                let kind = "var";
                if (node.value && node.value.type == "PropertyAccess") {
                     let propName = node.value.property.name;
                     if (node.name.name == propName) {
                         let firstChar = propName.substring(0, 1);
                         if (firstChar == firstChar.upper() && firstChar != firstChar.lower()) {
                             varType = "class";
                             kind = "class";
                         }
                     }
                }
                this.defineSymbol(node.name.name, kind, varType);
            }
            if (node.value) this.scanDeclarations(node.value);
        }
        else if (type == "ImportStatement") {
            if (node.namespaceImport) this.defineSymbol(node.namespaceImport.name, "module", "object");
            if (node.namedImports) for (let i = 0; i < node.namedImports.size(); ++i) this.defineSymbol(node.namedImports[i].name, "var", "unknown");
        }
    }

    fn resolveMethodCall(objType, methodName) {
        if (objType == "string") {
            if (methodName == "size" || methodName == "length" || methodName == "indexOf") return "int";
            if (methodName == "substring" || methodName == "trim" || methodName == "upper") return "string";
            return "unknown";
        }
        if (objType.indexOf("array") == 0) {
            if (methodName == "size" || methodName == "findIndex") return "int";
            if (methodName == "push") return "int";
            if (methodName == "slice" || methodName == "map") return objType;
            if (methodName == "join") return "string";
            if (methodName == "pop" || methodName == "find" || methodName == "shift") {
                 if (objType.indexOf("<") != -1) return objType.substring(objType.indexOf("<") + 1, objType.indexOf(">"));
                 return "unknown";
            }
            return "unknown";
        }
        if (objType == "object") {
             if (methodName == "keys") return "array<string>";
             return "unknown";
        }
        if (this.classRegistry[objType]) {
            let methods = this.classRegistry[objType].methods;
            if (methods && methods[methodName]) return methods[methodName];
        }
        return "unknown";
    }

fn visit(node) {
        if (node == null) return "void";
        let type = this.getSafeType(node);

        // Dispatch Statements
        if (type == "Program") return StmtVisitor.visitProgram(this, node);
        if (type == "BlockStatement") return StmtVisitor.visitBlockStatement(this, node);
        if (type == "FunctionStatement") return StmtVisitor.visitFunctionStatement(this, node);
        if (type == "ClassStatement") return StmtVisitor.visitClassStatement(this, node);
        if (type == "LetStatement") return StmtVisitor.visitLetStatement(this, node);
        if (type == "ReturnStatement") return StmtVisitor.visitReturnStatement(this, node);
        if (type == "IfStatement") return StmtVisitor.visitIfStatement(this, node);
        if (type == "WhileStatement") return StmtVisitor.visitWhileStatement(this, node);
        if (type == "ForStatement") return StmtVisitor.visitForStatement(this, node);
        if (type == "ForInStatement") return StmtVisitor.visitForInStatement(this, node); 
        if (type == "TryStatement") return StmtVisitor.visitTryStatement(this, node);
        if (type == "ImportStatement") return StmtVisitor.visitImportStatement(this, node); 

        // Dispatch Expressions
        if (type == "BinaryExpression") return ExprVisitor.visitBinaryExpression(this, node);
        if (type == "UnaryExpression") return ExprVisitor.visitUnaryExpression(this, node);
        if (type == "CallExpression") return ExprVisitor.visitCallExpression(this, node);
        if (type == "NewExpression") return ExprVisitor.visitNewExpression(this, node);
        if (type == "Identifier") return ExprVisitor.visitIdentifier(this, node);
        if (type == "AssignmentExpression") return ExprVisitor.visitAssignment(this, node);
        if (type == "PropertyAccess") return ExprVisitor.visitPropertyAccess(this, node);
        if (type == "IndexExpression") return ExprVisitor.visitIndexExpression(this, node);
        if (type == "PostfixUpdateExpression" || type == "PrefixUpdateExpression") return ExprVisitor.visitUpdateExpression(this, node);
        if (type == "ArrayLiteral") return ExprVisitor.visitArrayLiteral(this, node);
        if (type == "ObjectLiteral") return ExprVisitor.visitObjectLiteral(this, node);
        if (type == "FunctionLiteral") return ExprVisitor.visitFunctionLiteral(this, node);

        // --- TH√äM: Dispatch cho 'this' ---
        if (type == "ThisExpression") return ExprVisitor.visitThisExpression(this, node);
        // --------------------------------

        // Primitives
        if (type == "IntegerLiteral") return "int";
        if (type == "RealLiteral") return "float";
        if (type == "StringLiteral") return "string";
        if (type == "BooleanLiteral") return "bool";
        if (type == "NullLiteral") return "null";

        // Traverse children
        if (node.keys) {
            for (key in node.keys()) {
                let child = node[key];
                if (typeof(child) == "object" && child != null && child.type) this.visit(child);
                else if (typeof(child) == "array") for (item in child) this.visit(item);
            }
        }
        return "unknown";
    }

    fn printStats() {
        print("\nüìä B√ÅO C√ÅO C√ÅC BI·∫æN KH√îNG SUY LU·∫¨N ƒê∆Ø·ª¢C (MISSING TYPES):");
        let limit = this.unknownVars.size();
                let displayLimit = 100; 
                if (limit == 0) print("‚ú® Tuy·ªát v·ªùi! Kh√¥ng c√≤n bi·∫øn n√†o l√† unknown.");
        else {
                    for (let i = 0; i < limit; ++i) {
                        if (i < displayLimit) {
                            let u = this.unknownVars[i];
                            let shortFile = PathUtils.shorten(u.file);
        print("‚ùå [Unknown] " + u.name + " (t·∫°i " + shortFile + ":" + str(u.line) + ":" + str(u.col) + ")");
        }
                    }
                    if (limit > displayLimit) print("... v√† " + str(limit - displayLimit) + " bi·∫øn kh√°c ƒëang 'm√π' type.");
        }
                let percentage = 0;
        if (this.totalVariables > 0) percentage = (this.inferredCount * 100) / this.totalVariables;
                print("-------------------------------------");
        print("ƒê·ªô ph·ªß (Coverage)     : " + str(percentage) + "% (" + str(this.inferredCount) + "/" + str(this.totalVariables) + ")");
        print("-------------------------------------");
    }
}