import * as String from "string";
import * as Io from "io";

// should I use "__" like __preprocessor ?

export class Preprocessor {
    fn init() {
        this.macros = {};
        this.conditionalStackActive = [true];
        this.conditionalCondStack = [];
        this.includedFiles = {};
        this.inBlockComment = false;
        // Thêm trạng thái chuỗi vào thuộc tính của class
        this.inString = false;
        this.stringDelim = '';
    }

    fn isSkipping() {
        return this.conditionalStackActive[this.conditionalStackActive.size() - 1] == false;
    }

    fn process(sourceText, sourcePath) {
        if (!sourcePath) {
            sourcePath = "<anonymous>";
        }
        if (this.includedFiles[sourcePath]) { return ""; }
        this.includedFiles[sourcePath] = true;

        let lines = String.split(sourceText, "\n");
        let output = [];

        for (let i = 0; i < lines.size(); ++i) {
            let trimmedLine = String.trim(lines[i]);
            if (trimmedLine.startsWith("#")) {
                let directiveOutput = this._handleDirective(trimmedLine, sourcePath);
                if (directiveOutput != null && directiveOutput != "") {
                    output.push(directiveOutput);
                }
                continue;
            }
            
            if (!this.isSkipping()) {
                output.push(this._scanAndExpandLine(lines[i]));
            }
        }

        this.includedFiles[sourcePath] = null;
        return String.join("\n", output);
    }

    fn _handleDirective(line, sourcePath) {
        let parts = String.split(line, " ");
        let directive = parts[0];

        if (directive == "#define") {
            if (!this.isSkipping() && parts.size() >= 2) {
                let name = parts[1];
                // Tìm vị trí của name trong chuỗi gốc, bắt đầu tìm từ sau dấu cách đầu tiên.
                let nameStartIndex = String.indexOf(line, name, String.indexOf(line, " ") + 1);

                if (nameStartIndex != -1) {
                    // Replacement là tất cả mọi thứ sau 'name'
                    let replacementStartIndex = nameStartIndex + name.size();
                    if (replacementStartIndex < line.size()) {
                        // Lấy phần còn lại và trim đi dấu cách thừa ở đầu
                        let replacement = String.trim(line.slice(replacementStartIndex));
                        this.macros[name] = replacement;
                    } else {
                        // #define NAME (không có replacement)
                        this.macros[name] = "";
                    }
                }
            }
            return null;
        } else if (directive == "#undef") {
            if (!this.isSkipping() && parts.size() >= 2) {
                let name = parts[1];
                this.macros[name] = null;
            }
            return null;
        } else if (directive == "#ifdef") {
            let name = parts.size() >= 2 ? parts[1] : "";
            let conditionResult = (this.macros[name] != null && typeof(this.macros[name]) == "string");
            let parentActive = this.conditionalStackActive[this.conditionalStackActive.size() - 1];
            let active = parentActive && conditionResult;
            this.conditionalCondStack.push(conditionResult);
            this.conditionalStackActive.push(active);
            return null;
        } else if (directive == "#ifndef") {
            let name = parts.size() >= 2 ? parts[1] : "";
            let conditionResult = !(this.macros[name] != null && typeof(this.macros[name]) == "string");
            let parentActive = this.conditionalStackActive[this.conditionalStackActive.size() - 1];
            let active = parentActive && conditionResult;
            this.conditionalCondStack.push(conditionResult);
            this.conditionalStackActive.push(active);
            return null;
        } else if (directive == "#else") {
            if (this.conditionalCondStack.size() == 0) return null;
            let prevCond = this.conditionalCondStack.pop();
            this.conditionalStackActive.pop();
            let parentActive = this.conditionalStackActive[this.conditionalStackActive.size() - 1];
            let newCond = !prevCond;
            let newActive = parentActive && newCond;
            this.conditionalCondStack.push(newCond);
            this.conditionalStackActive.push(newActive);
            return null;
        } else if (directive == "#endif") {
            if (this.conditionalCondStack.size() > 0) {
                this.conditionalCondStack.pop();
                this.conditionalStackActive.pop();
            }
            return null;
        } else if (directive == "#include") {
            if (this.isSkipping()) return null;
            let includePath = this._extractIncludePath(line);
            if (includePath == null || includePath == "") return "";
            let baseDir = Io.getDirectoryPath(sourcePath);
            let absolutePath = Io.getAbsolutePath(baseDir + "/" + includePath);
            if (!Io.fileExists(absolutePath)) return "";
            let includedSource = Io.read(absolutePath);
            if (includedSource == null) return "";
            
            let subProcessor = new Preprocessor();
            subProcessor.macros = this.macros;
            subProcessor.includedFiles = this.includedFiles;
            subProcessor.conditionalStackActive = this.conditionalStackActive.slice();
            subProcessor.conditionalCondStack = this.conditionalCondStack.slice();
            subProcessor.inBlockComment = this.inBlockComment;
            // === THÊM VÀO ĐÂY: chia sẻ trạng thái chuỗi ===
            subProcessor.inString = this.inString;
            subProcessor.stringDelim = this.stringDelim;

            let res = subProcessor.process(includedSource, absolutePath);

            this.macros = subProcessor.macros;
            this.inBlockComment = subProcessor.inBlockComment;
            // === THÊM VÀO ĐÂY: cập nhật lại trạng thái chuỗi ===
            this.inString = subProcessor.inString;
            this.stringDelim = subProcessor.stringDelim;

            return res;
        }
        return null;
    }

    fn _extractIncludePath(line) {
        let firstQuote = String.indexOf(line, "\"");
        if (firstQuote >= 0) {
            let sub = line.slice(firstQuote + 1);
            let secondQuote = String.indexOf(sub, "\"");
            if (secondQuote >= 0) {
                return sub.slice(0, secondQuote);
            }
        }
        return null;
    }

    fn _scanAndExpandLine(line) {
        let result = "";
        let currentWord = "";
        let i = 0;
        let len = line.size();

        while (i < len) {
            let ch = line[i];

            if (this.inBlockComment) {
                if (ch == "*" && i + 1 < len && line[i + 1] == "/") {
                    result = result + "*/";
                    i = i + 1;
                    this.inBlockComment = false;
                } else {
                    result = result + ch;
                }
                i = i + 1;
                continue;
            }

            if (!this.inString) {
                if (ch == "/" && i + 1 < len && line[i + 1] == "/") {
                    if (currentWord.size() > 0) { result = result + this._expandMacroIfAny(currentWord); currentWord = ""; }
                    result = result + line.slice(i);
                    break;
                }
                if (ch == "/" && i + 1 < len && line[i + 1] == "*") {
                    if (currentWord.size() > 0) { result = result + this._expandMacroIfAny(currentWord); currentWord = ""; }
                    result = result + "/*";
                    i = i + 1;
                    this.inBlockComment = true;
                    i = i + 1;
                    continue;
                }
                if (ch == "\"" || ch == "'") {
                    if (currentWord.size() > 0) { result = result + this._expandMacroIfAny(currentWord); currentWord = ""; }
                    this.inString = true;
                    this.stringDelim = ch;
                    result = result + ch;
                    i = i + 1;
                    continue;
                }
                if (this._isIdentifierChar(ch)) {
                    currentWord = currentWord + ch;
                } else {
                    if (currentWord.size() > 0) { result = result + this._expandMacroIfAny(currentWord); currentWord = ""; }
                    result = result + ch;
                }
            } else {
                result = result + ch;
                if (ch == "\\" && i + 1 < len) {
                    result = result + line[i + 1];
                    i = i + 1;
                } else if (ch == this.stringDelim) {
                    this.inString = false;
                    this.stringDelim = '';
                }
            }
            i = i + 1;
        }

        if (currentWord.size() > 0) {
            result = result + this._expandMacroIfAny(currentWord);
        }
        return result;
    }

    fn _expandMacroIfAny(name) {
        if (this.macros[name] != null && typeof(this.macros[name]) == "string") {
            return this.macros[name];
        }
        return name;
    }

    fn _isIdentifierChar(ch) {
        return (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z") || (ch >= "0" && ch <= "9") || ch == "_";
    }
}