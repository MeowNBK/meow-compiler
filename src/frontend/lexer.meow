import { isalpha, isdigit, isxdigit, isalnum, isspace } from "./checkType.meow";
import { Token, TokenType } from "./token.meow";
import { keywords, symbols } from "./tokenTables.meow"

export class Lexer {
    fn init(source, filename) {
        this.src = source;
        this.pos = 0;
        this.line = 1;
        this.col = 1;
        this.currChar = this.src.size() == 0 ? '\0' : this.src[0];
        this.filename = filename;
        this.isInTemplateMode = false;
        this.isInExpression = false;

        this.Token = Token;
        this.TokenType = TokenType;

        this.keywords = keywords;
        this.symbols = symbols;
    }

    fn reset() {
        this.pos = 0;
        this.line = 1;
        this.col = 1;
        this.currChar = this.src.size() == 0 ? '\0' : this.src[0];
        this.isInTemplateMode = false;
        this.isInExpression = false;
    }

    fn advance() {
        if (this.currChar == '\n') {
            ++this.line;
            this.col = 1;
        } else {
            ++this.col;
        }
        ++this.pos;
        this.currChar = this.pos < this.src.size() ? this.src[this.pos] : '\0';
    }

    fn peek() {
        let next = this.pos + 1;
        return next < this.src.size() ? this.src[next] : '\0';
    }

    fn seeNext(range) {
        let next = this.pos + (range ? range : 1);
        return next < this.src.size() ? this.src[next] : '\0';
    }

    fn skipWhiteSpace() {
        while (isspace(this.currChar) && this.currChar != "\0") {
            this.advance();
        }
    }

    fn skipLineComment() {
        this.advance(); this.advance();
        while (this.currChar != '\n' && this.currChar != '\0') {
            this.advance();
        }
    }

    fn skipBlockComment() {

        this.advance(); this.advance();

        while (!(this.currChar == '*' && this.peek() == '/') && this.currChar != '\0') {
            this.advance();
        }

        if (this.currChar != '\0' && this.peek() != '\0') {
            this.advance(); this.advance();
        }
    }

    fn makeToken(type, lex, startLine, startCol) {
        if (typeof(type) == "function") {
            print(type());
        }
        return {
            type: type,
            lexeme: lex,
            file: this.filename,
            line: startLine,
            col: startCol
        };
    }

    fn identifier(startLine, startCol) {
        let lex = "";
        while (isalnum(this.currChar) || this.currChar == '_') {
            lex += this.currChar;
            this.advance();
        }

        let keyword = this.keywords[lex];
        if (keyword != null && (typeof(keyword) == typeof(this.TokenType._TOTAL_TOKENS))) {
            return this.makeToken(keyword, lex, startLine, startCol);
        }
        return this.makeToken(this.TokenType.IDENTIFIER, lex, startLine, startCol);
    }

    fn number(startLine, startCol) { 
        let lex = "";
        let isReal = false;

        if (this.currChar == '0') {
            lex += this.currChar;
            this.advance();

            if (this.currChar == 'x' || this.currChar == 'X') {
                lex += this.currChar;
                this.advance();
                while (isxdigit(this.currChar) || this.currChar == '_') {
                    if (this.currChar != '_') lex += this.currChar;
                    this.advance();
                }
                return this.makeToken(this.TokenType.INTEGER, lex, startLine, startCol);
            }
            else if (this.currChar == 'b' || this.currChar == 'B') {
                lex += this.currChar;
                this.advance();
                while (this.currChar == '0' || this.currChar == '1' || this.currChar == '_') {
                    if (this.currChar != '_') lex += this.currChar;
                    this.advance();
                }
                return this.makeToken(this.TokenType.INTEGER, lex, startLine, startCol);
            }
            else if (this.currChar == 'o' || this.currChar == 'O') {
                lex += this.currChar;
                this.advance();
                while ((this.currChar >= '0' && this.currChar <= '7') || this.currChar == '_') {
                    if (this.currChar != '_') lex += this.currChar;
                    this.advance();
                }
                return this.makeToken(this.TokenType.INTEGER, lex, startLine, startCol);
            }
        }

        while (isdigit(this.currChar) || this.currChar == '_' || this.currChar == '.') {
            if (this.currChar == '.') {
                if (isReal) break;
                isReal = true;
                if (!isdigit(this.peek())) break;
            }

            if (this.currChar != '_') lex += this.currChar;
            this.advance();
        }

        if (this.currChar == 'e' || this.currChar == 'E') {
            isReal = true;
            lex += this.currChar;
            this.advance();
            if (this.currChar == '+' || this.currChar == '-') {
                lex += this.currChar;
                this.advance();
            }
            while (isdigit(this.currChar) || this.currChar == '_') {
                if (this.currChar != '_') lex += this.currChar;
                this.advance();
            }
        }

        return this.makeToken(isReal ? this.TokenType.REAL : this.TokenType.INTEGER, lex, startLine, startCol);
    }

    fn stringLiteral(delimiter, startLine, startCol) {
        this.advance();

        let lex = "";

        while (this.currChar != delimiter && this.currChar != '\0') {
            if (this.currChar == '\\') {
                this.advance();
                switch (this.currChar) {
                    case '\\': lex += '\\'; break;
                    case '"': lex += (delimiter == '"') ? "\"" : "\\\""; break;
                    case '\'': lex += (delimiter == '\'') ? "'" : "\\'"; break;
                    case 'n': lex += '\n'; break;
                    case 't': lex += '\t'; break;
                    case 'r': lex += '\r'; break;
                    case '0': lex += '\0'; break;
                    default:
                        lex += '\\';
                        lex += this.currChar;
                }
            } else {
                lex += this.currChar;
            }

            this.advance();
        }

        if (this.currChar == delimiter) {
            this.advance();
        }

        return this.makeToken(this.TokenType.STRING, lex, startLine, startCol);
    }

    fn check(s) {
            return s != null && (typeof(s) == typeof(this.TokenType._TOTAL_TOKENS));
        }

    fn punctuator(startLine, startCol) {
        let lex1 = this.currChar;
        let lex2 = lex1 + this.seeNext(1);
        let lex3 = lex2 + this.seeNext(2);

        if (this.check(this.symbols[lex3])) {
            this.advance(); this.advance(); this.advance();
            return this.makeToken(this.symbols[lex3], lex3, startLine, startCol);
        }
        if (this.check(this.symbols[lex2])) {
            this.advance(); this.advance();
            return this.makeToken(this.symbols[lex2], lex2, startLine, startCol);
        }
        if (this.check(this.symbols[lex1])) {            
            this.advance();
            return this.makeToken(this.symbols[lex1], lex1, startLine, startCol);
        }

        this.advance();
        print("Warning token is...", lex1);
        return this.makeToken(this.TokenType.UNKNOWN, lex1, startLine, startCol);
    }

    fn templateStringLiteral(startLine, startCol) {
        let lex = "";
        while (this.currChar != '`' && this.currChar != '\0' && !(this.currChar == '%' && this.peek() == '{')) {
            if (this.currChar == '\\') {
                this.advance();
                switch (this.currChar) {
                    case '\\': lex += '\\'; break;
                    case '`': lex += '`'; break;
                    case 'n': lex += '\n'; break;
                    case 't': lex += '\t'; break;
                    case 'r': lex += '\r'; break;
                    case '0': lex += '\0'; break;
                    default:
                        lex += '\\';
                        lex += this.currChar;
                }
            } else {
                lex += this.currChar;
            }

            this.advance();
        }
        return this.makeToken(this.TokenType.STRING, lex, startLine, startCol);
    }

    fn rawStringLiteral(delimiter, startLine, startCol) {
        let lex = "";
        this.advance();
        while (this.currChar != delimiter && this.currChar != '\0') {
            lex += this.currChar;
            this.advance();
        }
        if (this.currChar == delimiter) {
            this.advance();
        }
        return this.makeToken(this.TokenType.STRING, lex, startLine, startCol);
    }

    fn nextToken() {
        let startLine;
        let startCol;
        let token = null;

        if (!this.isInTemplateMode) {
            this.skipWhiteSpace();
        }

        startLine = this.line;
        startCol = this.col;

        if (this.isInExpression && this.currChar == '}') {
            this.isInTemplateMode = true;
            this.isInExpression = false;
            token = this.makeToken(this.TokenType.PUNCT_RBRACE, "}", startLine, startCol);
            this.advance();
        } else if (this.isInTemplateMode) {

            if (this.currChar == '`') {
                this.isInTemplateMode = false;
                token = this.makeToken(this.TokenType.PUNCT_BACKTICK, "`", startLine, startCol);
                this.advance();
            } else if (this.currChar == '%' && this.peek() == '{') {
                this.isInTemplateMode = false;
                this.isInExpression = true;
                this.advance(); this.advance();
                token = this.makeToken(this.TokenType.PUNCT_PERCENT_LBRACE, "%{", startLine, startCol);
            } else {
                token = this.templateStringLiteral(startLine, startCol);
            }
        } else {

            if (this.currChar == '\0') {
                token = this.makeToken(this.TokenType.END_OF_FILE, "", startLine, startCol);
            } else if ((this.currChar == 'r' || this.currChar == 'R') && (this.peek() == '"' || this.peek() == '\'')) {

                this.advance();
                token = this.rawStringLiteral(this.currChar, startLine, startCol);
            } else if (isalpha(this.currChar) || this.currChar == '_') {
                token = this.identifier(startLine, startCol);
            } else if (isdigit(this.currChar)) {
                token = this.number(startLine, startCol);
            } else {
                switch (this.currChar) {
                    case '`':
                        this.isInTemplateMode = true;
                        token = this.makeToken(this.TokenType.PUNCT_BACKTICK, "`", startLine, startCol);
                        this.advance();
                        break;
                    case '"':
                        token = this.stringLiteral('"', startLine, startCol);
                        break;
                    case '\'':
                        token = this.stringLiteral('\'', startLine, startCol);
                        break;
                    case '/':
                        if (this.peek() == '/') {
                            this.skipLineComment();

                            token = this.nextToken();
                        } else if (this.peek() == '*') {
                            this.skipBlockComment();
                            token = this.nextToken();
                        } else {
                            token = this.punctuator(startLine, startCol);
                        }
                        break;
                    default:
                        token = this.punctuator(startLine, startCol);
                }
            }
        }

        if (token == null) {
            print("Warning, token is null?");
            token = this.makeToken(this.TokenType.UNKNOWN, "", startLine, startCol);
        }

        return token;
    }

    fn tokenize() {
        this.isInTemplateMode = false;
        this.isInExpression = false;
        this.pendingTemplateExpr = false;
        let tokens = [];
        while (true) {
            let token = this.nextToken();


            tokens.push(token);

            if (typeof(token.type) == "function") {

                print(token);
                break;
            }
            if (token.type == this.TokenType.END_OF_FILE) break;
        }

        return tokens;
    }
}