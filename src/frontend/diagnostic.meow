import * as String from "string";
import * as Io from "io";
import { tokenTypeToString } from "./token.meow";

export let ErrorCodes = {
    ERR_UNEXPECTED_TOKEN: 1001,
    ERR_INVALID_ASSIGNMENT_TARGET: 1002,
    ERR_MISSING_SEMICOLON: 1003,
    ERR_MISSING_RPAREN_GROUPING: 1004,
    ERR_MISSING_RBRACKET_ARRAY: 1005,
    ERR_MISSING_RBRACKET_COMPUTED_KEY: 1006,
    ERR_MISSING_COLON_OBJECT_KEY: 1007,
    ERR_INVALID_OBJECT_KEY: 1008,
    ERR_MISSING_RBRACE_OBJECT: 1009,
    ERR_MISSING_BACKTICK_TEMPLATE: 1010,
    ERR_MISSING_RBRACE_TEMPLATE_EXPR: 1011,
    ERR_MISSING_PROPERTY_NAME_SUPER: 1012,
    ERR_MISSING_CLASS_NAME_NEW: 1013,
    ERR_MISSING_IDENTIFIER_LET: 1014,
    ERR_MISSING_FUNCTION_NAME: 1015,
    ERR_MISSING_CLASS_NAME_DECL: 1016,
    ERR_MISSING_SUPERCLASS_NAME: 1017,
    ERR_MISSING_LBRACE_CLASS_BODY: 1018,
    ERR_INVALID_STATIC_DECLARATION: 1019,
    ERR_MISSING_RBRACE_CLASS_BODY: 1020,
    ERR_MISSING_RPAREN_PARAMS: 1021,
    ERR_INVALID_PARAMETER_NAME: 1022,
    ERR_REST_PARAM_NOT_IDENTIFIER: 1023,
    ERR_MISSING_RBRACE_BLOCK: 1024,
    ERR_MISSING_CATCH: 1025,
    ERR_MISSING_LPAREN_CATCH: 1026,
    ERR_MISSING_CATCH_VAR: 1027,
    ERR_MISSING_RPAREN_CATCH: 1028,
    ERR_MISSING_RBRACE_IMPORT_LIST: 1029,
    ERR_MISSING_FROM_IMPORT: 1030,
    ERR_MISSING_AS_IMPORT: 1031,
    ERR_MISSING_NAMESPACE_IMPORT_NAME: 1032,
    ERR_INVALID_EXPORT_SYNTAX: 1033,
    ERR_EXPECTED_CASE_OR_DEFAULT: 1034,
    ERR_MISSING_COLON_CASE: 1035,
    ERR_MISSING_LBRACE_SWITCH: 1036,
    ERR_MISSING_RBRACE_SWITCH: 1037,
    ERR_MISSING_WHILE_DOWHILE: 1038,
    ERR_MISSING_IN_OR_COLON_FORIN: 1039,
    ERR_MISSING_RPAREN_FORIN: 1040,
    ERR_MISSING_SEMICOLON_FOR_CONDITION: 1041,
    ERR_MISSING_RPAREN_FOR: 1042,
    ERR_UNKNOWN_PREFIX_EXPRESSION: 1043,
    ERR_UNKNOWN_LITERAL_TYPE: 1044,
    ERR_UNKNOWN_COMPOUND_ASSIGN_OP: 1045,
    ERR_MISSING_PROPERTY_NAME_DOT: 1046,
    ERR_MISSING_LBRACE_TRY_BLOCK: 1047,
    ERR_INVALID_IMPORT_IDENTIFIER: 1048,
    ERR_INVALID_EXPORT_IDENTIFIER: 1049,
    
    // NEW CODES for Meow-C Static Types
    ERR_MISSING_AT_TYPE: 1050, 
    ERR_MISSING_TYPENAME_AFTER_AT: 1051,

    ERR_INVALID_BASE_TYPE: 2001,
    ERR_TYPE_MISMATCH_DECLARATION: 2002,
    ERR_VARIABLE_REDEFINITION: 2003,
    ERR_ASSIGNMENT_TO_CONST: 2004,
    ERR_TYPE_MISMATCH_ASSIGNMENT: 2005,
    ERR_BINARY_OP_TYPE_MISMATCH: 2006,
    ERR_OP_ON_POINTER: 2007,
    ERR_DEREFERENCE_NON_POINTER: 2008,
    ERR_ADDRESSOF_NON_LVALUE: 2009,
    ERR_UNDECLARED_VARIABLE: 2010,
};

export let ErrorMessages = {
    [ErrorCodes.ERR_UNEXPECTED_TOKEN]: "Token không mong đợi: %{tokenType}",
    [ErrorCodes.ERR_INVALID_ASSIGNMENT_TARGET]: "Đối tượng được gán không hợp lệ",
    [ErrorCodes.ERR_MISSING_SEMICOLON]: "Thiếu dấu chấm phẩy ';'",
    [ErrorCodes.ERR_MISSING_RPAREN_GROUPING]: "Thiếu ')' khi nhóm biểu thức",
    [ErrorCodes.ERR_MISSING_RBRACKET_ARRAY]: "Thiếu ']' khi tạo array",
    [ErrorCodes.ERR_MISSING_RBRACKET_COMPUTED_KEY]: "Thiếu ']' khi dùng biểu thức làm key",
    [ErrorCodes.ERR_MISSING_COLON_OBJECT_KEY]: "Cần một đấu hai chấm ':' sau key của object",
    [ErrorCodes.ERR_INVALID_OBJECT_KEY]: "Key của object không hợp lệ",
    [ErrorCodes.ERR_MISSING_RBRACE_OBJECT]: "Thiếu '}' khi tạo object",
    [ErrorCodes.ERR_MISSING_BACKTICK_TEMPLATE]: "Thiếu '`' cho khi tạo template",
    [ErrorCodes.ERR_MISSING_RBRACE_TEMPLATE_EXPR]: "Thiếu '}' cú pháp chèn biểu thức",
    [ErrorCodes.ERR_MISSING_PROPERTY_NAME_SUPER]: "Thiếu tên thuộc tính sau từ khóa 'super'",
    [ErrorCodes.ERR_MISSING_CLASS_NAME_NEW]: "Cần tên hàm/class để gọi sau từ khóa 'new'",
    [ErrorCodes.ERR_MISSING_IDENTIFIER_LET]: "Cần tên biến sau từ khóa 'let' hoặc 'const'",
    [ErrorCodes.ERR_MISSING_FUNCTION_NAME]: "Cần một cái tên cho hàm. Bạn quên rồi à?",
    [ErrorCodes.ERR_MISSING_CLASS_NAME_DECL]: "Thiếu tên class sau từ khóa 'class'",
    [ErrorCodes.ERR_MISSING_SUPERCLASS_NAME]: "Thiếu tên class cha sau ':'",
    [ErrorCodes.ERR_MISSING_LBRACE_CLASS_BODY]: "Thiếu '{' để bắt đầu thân class",
    [ErrorCodes.ERR_INVALID_STATIC_DECLARATION]: "Thiếu định nghĩa sau từ khóa 'static'",
    [ErrorCodes.ERR_MISSING_RBRACE_CLASS_BODY]: "Thiếu '}' khi kết thúc thân class",
    [ErrorCodes.ERR_MISSING_RPAREN_PARAMS]: "Thiếu dấu ')' để kết thúc những tham số",
    [ErrorCodes.ERR_INVALID_PARAMETER_NAME]: "Đây không phải tên tham số hợp lệ",
    [ErrorCodes.ERR_REST_PARAM_NOT_IDENTIFIER]: "Sau '...' phải là một tên biến!",
    [ErrorCodes.ERR_MISSING_RBRACE_BLOCK]: "Cần '}' sau block",
    [ErrorCodes.ERR_MISSING_CATCH]: "Thiếu 'catch' sau block 'try'",
    [ErrorCodes.ERR_MISSING_LPAREN_CATCH]: "Thiếu '(' sau 'catch'",
    [ErrorCodes.ERR_MISSING_CATCH_VAR]: "Thiếu tên biến đại diện cho lỗi cần bắt",
    [ErrorCodes.ERR_MISSING_RPAREN_CATCH]: "Thiếu ')' sau tên biến catch",
    [ErrorCodes.ERR_MISSING_RBRACE_IMPORT_LIST]: "Thiếu ngoặc nhọn '}' để đóng danh sách import.",
    [ErrorCodes.ERR_MISSING_FROM_IMPORT]: "Thiếu từ khóa 'from' sau danh sách import.",
    [ErrorCodes.ERR_MISSING_AS_IMPORT]: "Thiếu từ khóa 'as' sau '*'.",
    [ErrorCodes.ERR_MISSING_NAMESPACE_IMPORT_NAME]: "Cần một tên namespace sau 'as'.",
    [ErrorCodes.ERR_INVALID_EXPORT_SYNTAX]: "Đây không phải cú pháp 'export' hợp lệ...",
    [ErrorCodes.ERR_EXPECTED_CASE_OR_DEFAULT]: "Mong đợi 'case' hoặc 'default' bên trong switch.",
    [ErrorCodes.ERR_MISSING_COLON_CASE]: "Thiếu dấu ':' sau giá trị của case/default.",
    [ErrorCodes.ERR_MISSING_LBRACE_SWITCH]: "Cần một khối lệnh ngoặc nhọn '{' cho switch.",
    [ErrorCodes.ERR_MISSING_RBRACE_SWITCH]: "Thiếu '}' để đóng khối lệnh switch.",
    [ErrorCodes.ERR_MISSING_WHILE_DOWHILE]: "Thiếu từ khóa 'while' sau thân của vòng lặp 'do'.",
    [ErrorCodes.ERR_MISSING_IN_OR_COLON_FORIN]: "Thiếu 'in' hoặc ':' khi lặp qua",
    [ErrorCodes.ERR_MISSING_RPAREN_FORIN]: "Cần ')' để kết thúc for-in",
    [ErrorCodes.ERR_MISSING_SEMICOLON_FOR_CONDITION]: "Cần ';' sau điều kiện trong for",
    [ErrorCodes.ERR_MISSING_RPAREN_FOR]: "Cần ')' để kết thúc 'for'",
    [ErrorCodes.ERR_UNKNOWN_PREFIX_EXPRESSION]: "Biểu thức tiền tố không xác định",
    [ErrorCodes.ERR_UNKNOWN_LITERAL_TYPE]: "Kiểu dữ liệu literal không xác định",
    [ErrorCodes.ERR_UNKNOWN_COMPOUND_ASSIGN_OP]: "Toán tử gán ghép không xác định",
    [ErrorCodes.ERR_MISSING_PROPERTY_NAME_DOT]: "Cần tên thuộc tính sau dấu chấm '.'",
    [ErrorCodes.ERR_MISSING_LBRACE_TRY_BLOCK]: "Thiếu '{' sau từ khóa 'try'",
    [ErrorCodes.ERR_INVALID_IMPORT_IDENTIFIER]: "Tên định danh không xác định trong danh sách import",
    [ErrorCodes.ERR_INVALID_EXPORT_IDENTIFIER]: "Cần tên biến trong danh sách export",

    // NEW MESSAGES for Meow-C Static Types
    [ErrorCodes.ERR_MISSING_AT_TYPE]: "Cần ký tự '@' để khai báo kiểu tĩnh (ví dụ: let @int32 x;)",
    [ErrorCodes.ERR_MISSING_TYPENAME_AFTER_AT]: "Cần tên kiểu (ví dụ: int32, char) sau ký tự '@'",

    [ErrorCodes.ERR_INVALID_BASE_TYPE]: "Kiểu cơ sở '%{typeName}' không hợp lệ. Chỉ hỗ trợ %{validTypes}.",
    [ErrorCodes.ERR_TYPE_MISMATCH_DECLARATION]: "Kiểu không khớp: Không thể gán giá trị kiểu '%{valueType}' cho biến kiểu '%{declaredType}'.",
    [ErrorCodes.ERR_VARIABLE_REDEFINITION]: "Lỗi định nghĩa: Biến '%{variableName}' đã được định nghĩa trong phạm vi này.",
    [ErrorCodes.ERR_ASSIGNMENT_TO_CONST]: "Lỗi hằng số: Không thể gán giá trị mới cho hằng số '%{variableName}'.",
    [ErrorCodes.ERR_TYPE_MISMATCH_ASSIGNMENT]: "Kiểu không khớp trong phép gán. Kiểu đích ('%{targetType}') và kiểu nguồn ('%{valueType}') không khớp.",
    [ErrorCodes.ERR_BINARY_OP_TYPE_MISMATCH]: "Toán tử hai ngôi yêu cầu hai vế có cùng kiểu dữ liệu.",
    [ErrorCodes.ERR_OP_ON_POINTER]: "Lỗi con trỏ: Không thể thực hiện phép toán số học/logic trên con trỏ.",
    [ErrorCodes.ERR_DEREFERENCE_NON_POINTER]: "Lỗi dereference: Không thể dereference một giá trị không phải là con trỏ (kiểu: %{typeStr}).",
    [ErrorCodes.ERR_ADDRESSOF_NON_LVALUE]: "Lỗi '&': Toán tử '&' chỉ có thể lấy địa chỉ của một l-value (biến, *ptr, hoặc array[index]).",
    [ErrorCodes.ERR_UNDECLARED_VARIABLE]: "Lỗi định danh: Biến '%{variableName}' chưa được khai báo.",
};

fn _getLineContent(filename, lineNum) {
    if (Io.fileExists(filename)) {
        let content = Io.read(filename);
        if (content) {
            let lines = String.split(content, "\n");
            if (lineNum > 0 && lineNum <= lines.length) {
                return String.trim(lines[lineNum - 1]);
            }
        }
    }
    return null;
}

export fn getParseErrorMessage(code, token) {
    let filename = Io.getFileName(token.file);
    let baseMsg = ErrorMessages[code];
    if (!baseMsg) {
        return "Lỗi phân tích cú pháp không xác định (Code: " + str(code) + ") tại " + filename + ", dòng " + token.line + ", cột " + token.col;
    }

    let msg = "Lỗi phân tích cú pháp (Code: " + str(code) + "): " + baseMsg;
    if (token.type != null) {
        let tokenTypeString = tokenTypeToString(token.type);
        msg = String.replace(msg, "%{tokenType}", tokenTypeString);
    }
    
    let finalMsg = msg + " tại " + filename + ", dòng " + token.line + ", cột " + token.col;
    let lineContent = _getLineContent(token.file, token.line);
    if (lineContent) {
        let indicator = "";
        for (let i = 1; i < token.col; ++i) {
            indicator += (lineContent[i-1] == "\t") ? "\t" : " ";
        }
        indicator += "^";
        finalMsg += "\n\n" + lineContent + "\n" + indicator;
    }

    return finalMsg;
}

fn getSemanticErrorMessage(code, node, replacements) {
    let token = node.token;
    let filename = Io.getFileName(token.file);
    let baseMsg = ErrorMessages[code];
    if (!baseMsg) {
        return "Lỗi ngữ nghĩa không xác định (Code: " + str(code) + ") tại " + filename + ", dòng " + token.line + ", cột " + token.col;
    }

    let msg = "Lỗi Phân Tích Ngữ Nghĩa (Code: " + str(code) + "): " + baseMsg;

    if (replacements) {
        for (key in replacements.keys()) {
            msg = String.replace(msg, "%{" + key + "}", str(key));
        }
    }

    let finalMsg = msg + " tại " + filename + ", dòng " + token.line + ", cột " + token.col;
    let lineContent = _getLineContent(token.file, token.line);
    if (lineContent) {
        let indicator = "";
        for (let i = 1; i < token.col; ++i) {
            indicator += (lineContent[i-1] == "\t") ? "\t" : " ";
        }
        indicator += "^";
        finalMsg += "\n\n" + lineContent + "\n" + indicator;
    }

    return finalMsg;
}

export let Diagnostic = {
    ParseErr: fn(code, token) {
        return getParseErrorMessage(code, token);
    },
    SemanticErr: fn(code, node, replacements) {
        return getSemanticErrorMessage(code, node, replacements);
    },
};


export let Precedence = {
    NONE: 0,
    ASSIGN: 1,
    NULLISH: 2,
    TERNARY: 3,
    LOGICAL_OR: 4,
    LOGICAL_AND: 5,
    BITWISE_OR: 6,
    BITWISE_XOR: 7,
    BITWISE_AND: 8,
    EQUALITY: 9,
    COMPARISON: 10,
    BITWISE_SHIFT: 11,
    SUM: 12,
    PRODUCT: 13,
    EXPONENT: 14,
    UNARY: 15,
    CALL: 16,
    INDEX: 17,
    PRIMARY: 18,
};