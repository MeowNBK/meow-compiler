// ===== FILE: src/backend/cacheManager.meow =====
import * as Io from "io";
import * as Json from "json";
import * as System from "system";
import { Compiler } from "backend/compiler.meow";
import { makeCacheFile } from "backend/utils/makeCacheFile.meow";
import { getDirectoryPath } from "backend/utils/pathUtils.meow";

export class CacheManager {
    fn init(compilerInstance, isNoCache, options) {
        this.compiler = compilerInstance; 
        this.isNoCache = isNoCache;
        this.options = options;
        
        this.compiledModules = {};
        this.dependencyGraph = {};
        this.reverseGraph = {};
    }

    fn compileProject(entryPath) {
        let initialDir = ".";
        let entryCache = this._getCachedOrCompile(entryPath, initialDir);
        
        if (this.options.out) {
            Io.copyFile(entryCache, this.options.out);
            return Io.getAbsolutePath(this.options.out);
        }
        return entryCache;
    }

    fn _getCachedOrCompile(sourcePath, importerDir) {
        let absolutePath = this.compiler._resolvePath(sourcePath, importerDir);
        if (this.compiledModules[absolutePath]) return this.compiledModules[absolutePath];

        let cachePath = makeCacheFile(absolutePath, this.options.buildDir || "builds/build");
        let metaPath = cachePath + ".meta";
        
        if (this._isCacheValid(absolutePath, cachePath)) {
            let metaText = Io.read(metaPath);
            if (!metaText) {
                print("[ERROR] Không thể đọc meta file: " + metaPath);
                System.exit(1);
            }
            let meta = Json.parse(metaText);
            this.dependencyGraph[absolutePath] = meta.imports || [];

            for (imp in this.dependencyGraph[absolutePath]) {
                if (!this.reverseGraph[imp]) this.reverseGraph[imp] = {};
                this.reverseGraph[imp][absolutePath] = true;
            }

            this.compiledModules[absolutePath] = Io.getAbsolutePath(cachePath);
            return Io.getAbsolutePath(cachePath);
        }

        let imports = this.compiler.getImportsOnly(absolutePath);

        for (imp in imports) {
            let sourceDir = getDirectoryPath(absolutePath);
            this._getCachedOrCompile(imp, sourceDir);
            if (!this.reverseGraph[imp]) this.reverseGraph[imp] = {};
            this.reverseGraph[imp][absolutePath] = true;
        }
        let compileResult = this.compiler.compileFile(absolutePath, this);
        let bytecodeText = compileResult.bytecodeText;

        Io.write(cachePath, bytecodeText);
        let metaOut = { imports: imports, srcTime: Io.getFileTimestamp(absolutePath), srcSize: Io.getFileSize(absolutePath) };
        metaOut.importTimes = {};
        metaOut.importSizes = {};
        for (imp in imports) {
            metaOut.importTimes[imp] = Io.getFileTimestamp(imp);
            metaOut.importSizes[imp] = Io.getFileSize(imp);
        }
        Io.write(metaPath, Json.stringify(metaOut));

        this.dependencyGraph[absolutePath] = imports;
        this.compiledModules[absolutePath] = Io.getAbsolutePath(cachePath);
        
        let dependents = this._gatherDependents(absolutePath, null);
        for (d in dependents) {
            if (!this.compiledModules[d]) {
                let dd = getDirectoryPath(d);
                this._getCachedOrCompile(d, dd);
            }
        }

        return Io.getAbsolutePath(cachePath);
    }

    fn _gatherDependents(absSource, accum) {
        if (!accum) accum = {};
        let direct = this.reverseGraph[absSource];
        if (!direct) return accum;
        for (d in direct) {
            if (!accum[d]) {
                accum[d] = true;
                this._gatherDependents(d, accum);
            }
        }
        return accum;
    }

    fn _isCacheValid(absSourcePath, cachePath) {
        if (this.isNoCache || this.options.force) return false;
        if (!Io.fileExists(cachePath)) return false;

        let metaPath = cachePath + ".meta";
        if (!Io.fileExists(metaPath)) return false;

        let metaText = Io.read(metaPath);
        if (!metaText) return false;

        let meta = Json.parse(metaText);
        if (!meta) return false;

        if (!Io.fileExists(absSourcePath)) return false;
        let srcTime = Io.getFileTimestamp(absSourcePath);
        let srcSize = Io.getFileSize(absSourcePath);
        if (meta.srcTime != srcTime || meta.srcSize != srcSize) return false;
        
        for (imp in meta.imports) {
            let impCachePath = makeCacheFile(imp, this.options.buildDir || "builds/build");
            if (!this._isCacheValid(imp, impCachePath)) {
                return false;
            }
        }
        return true;
    }
}


// ===== FILE: src/backend/codeGenerator.meow =====
import * as Emitter from "backend/emitter.meow";
import { OpCodes } from "backend/opCodes.meow";
import { Visitor } from "backend/visitor/visitor.meow";
import { CompilerState } from "backend/compilerState.meow";

export class CodeGenerator {
    fn init(ast, compiler, cacheManager, sourceName) {
        this.ast = ast;
        this.compiler = compiler;
        this.cacheManager = cacheManager;
        this.sourceName = sourceName;
        this.protos = {};
        this.states = [];
        this.currentState = null;
        this.isInsideClass = false;
    }

    fn compile() {
        let mainStr = "@main";
        this.enterState("@main");
        this.currentState.proto.sourceName = this.sourceName;
        
        for (let i = 0; i < this.ast.body.length; ++i) {
            this.visitStatement(this.ast.body[i]);
        }
        
        let mainProto = this.exitState();
        this.protos["@main"] = mainProto;

        return this.protos;
    }

    fn enterState(name) {
        let parentState = this.currentState;
        let newState = new CompilerState(name);

        if (parentState) {
            for (key in parentState.moduleVariables.keys()) {
                newState.moduleVariables[key] = parentState.moduleVariables[key];
            }
            for (key in parentState.importedVariables.keys()) {
                newState.importedVariables[key] = parentState.importedVariables[key];
            }
        }

        this.states.push(newState);
        this.currentState = newState;
    }

    fn exitState() {
        let finishedState = this.states.pop();
        let proto = finishedState.proto;

        let lastIdx = proto.code.length - 1;
        if (lastIdx < 0 || proto.code[lastIdx].op != OpCodes.RETURN) {

            finishedState.allocator.withTemp(fn(r) {
                Emitter.emit(proto, OpCodes.LOAD_NULL, [r]);
                Emitter.emit(proto, OpCodes.RETURN, [r]);
            });
        }
        
        proto.numRegisters = finishedState.allocator.usedRegisters();
        let recomputed = Emitter.computeMaxRegister(proto) + 1;
        if (recomputed > proto.numRegisters) proto.numRegisters = recomputed;

        if (!proto.upvalueDescs) proto.upvalueDescs = [];
        proto.numUpvalues = proto.upvalueDescs.length;

        Emitter.patchPendingJumps(proto);
        
        if (this.states.length > 0) {
            this.currentState = this.states[this.states.length - 1];
        } else {
            this.currentState = null;
        }
        return proto;
    }
    
    fn visitStatement(node) {
        if (node == null) return;
        let handler = Visitor.statements[node.type];
        assert(handler, `Lỗi: Không hỗ trợ kiểu statement '%{node.type}'`);
        handler(this, node);
    }

    fn visitExpression(node) {
        if (node == null) return -1;
        let handler = Visitor.expressions[node.type];
        assert(handler, `Lỗi: Không hỗ trợ kiểu expression '%{node.type}'`);
        return handler(this, node);
    }
}


// ===== FILE: src/backend/compiler.meow =====
import * as Io from "io";
import * as Json from "json";
import * as System from "system";
import { Lexer } from "frontend/lexer.meow";
import { Parser } from "frontend/parser.meow";
import { Preprocessor } from "frontend/preprocessor.meow";
import { ScopeAnalyzer } from "middle-end/scopeAnalyzer.meow";
import { BytecodeStringifier } from "backend/bytecodeStringifier.meow";
import { CodeGenerator } from "backend/codeGenerator.meow";
import { getDirectoryPath, isAbsolutePath } from "backend/utils/pathUtils.meow";

export class Compiler {
    fn init(options) {
        this.options = options || {};
    }

    fn getImportsOnly(absolutePath) {
        if (!Io.fileExists(absolutePath)) {
            print("[ERROR] getImportsOnly: File nguồn không tồn tại: " + absolutePath);
            return [];
        }
        let source = Io.read(absolutePath);
        if (source == null) {
            print("[ERROR] getImportsOnly: Không thể đọc file nguồn: " + absolutePath);
            return [];
        }

        let preprocessor = new Preprocessor();
        let processedSource = preprocessor.process(source, absolutePath);
        let lexer = new Lexer(processedSource, absolutePath);
        let tokens = lexer.tokenize();
        let parser = new Parser(tokens);
        let ast = parser.parseProgram();
        if (!ast) {
            print("[ERROR] getImportsOnly: Không thể parse AST: " + absolutePath);
            return [];
        }
        
        let sourceDir = getDirectoryPath(absolutePath);
        let imports = this._extractImportsFromAST(ast, sourceDir);
        return imports;
    }


    fn compileFile(absolutePath, cacheManager) {
        if (!Io.fileExists(absolutePath)) {
            print("[ERROR] File nguồn không tồn tại: " + absolutePath);
            System.exit(1);
        }

        let source = Io.read(absolutePath);
        if (source == null) {
            print("[ERROR] Không thể đọc file nguồn: " + absolutePath);
            System.exit(1);
        }

        let preprocessor = new Preprocessor();
        let processedSource = preprocessor.process(source, absolutePath);
        let lexer = new Lexer(processedSource, absolutePath);
        let tokens = lexer.tokenize();
        let parser = new Parser(tokens);
        let ast = parser.parseProgram();
        if (!ast) {
            print("[ERROR] Meta.compile trả về null/undefined cho: " + absolutePath);
            System.exit(1);
        }
        let analyzer = new ScopeAnalyzer(ast);
        analyzer.analyze();
        
        let sourceDir = getDirectoryPath(absolutePath);
        let imports = this._extractImportsFromAST(ast, sourceDir);
        
        let generator = CodeGenerator(ast, this, cacheManager, absolutePath);
        let protos = generator.compile();

        let stringifier = BytecodeStringifier();
        let bytecodeText = stringifier.stringify(protos);

        return {
            "bytecodeText": bytecodeText,
            "imports": imports
        };
    }

    fn _resolvePath(p, importerDir) {
        if (isAbsolutePath(p)) return Io.getAbsolutePath(p);
        let absImporter = null;
        if (importerDir && importerDir.length > 0) {
            absImporter = Io.getAbsolutePath(importerDir);
        }

        let isExplicitRelative = false;
        if (p.startsWith("./") || p.startsWith("../")) isExplicitRelative = true;
        let candidates = [];
        if (isExplicitRelative && absImporter) {
            candidates.push(absImporter + "/" + p);
        }

        if (this && this.options && this.options.includePaths) {
            for (ip in this.options.includePaths) {
                candidates.push(Io.getAbsolutePath(ip) + "/" + p);
            }
        }

        candidates.push(Io.getAbsolutePath(".") + "/" + p);
        candidates.push(p);
        let tryWithExt = !p.endsWith(".meow");
        for (cand in candidates) {
            let absCand = Io.getAbsolutePath(cand);
            if (Io.fileExists(absCand)) return absCand;
            if (tryWithExt) {
                let absExt = Io.getAbsolutePath(cand + ".meow");
                if (Io.fileExists(absExt)) return absExt;
            }
        }

        if (isExplicitRelative && absImporter) return Io.getAbsolutePath(absImporter + "/" + p);
        if (absImporter && !isExplicitRelative) return Io.getAbsolutePath(absImporter + "/" + p);
        return Io.getAbsolutePath(p);
    }

    fn _extractImportsFromAST(ast, sourceDir) {
        let imports = [];
        if (!ast || !ast.body) return imports;
        for (stmt in ast.body) {
            if (stmt.type == "ImportStatement") {
                let dependencyPath = stmt.path.value;
                if (dependencyPath.endsWith(".meow")) {
                    imports.push(this._resolvePath(dependencyPath, sourceDir));
                }
            }
        }
        return imports;
    }
}


// ===== FILE: src/backend/compilerState.meow =====
import * as Emitter from "backend/emitter.meow";
import { RegisterAllocator } from "backend/registerAllocator.meow";
import { ConstantPool } from "backend/constantPool.meow";

export class CompilerState {
    fn init(name) {
        this.proto = Emitter.createProto(name, 256);
        this.pool = ConstantPool(this.proto.constantPool);
        this.allocator = RegisterAllocator(256);
        this.scope = [{}];
        this.loopLabels = [];
        this.moduleVariables = {};
        this.importedVariables = {};
        this.capturedLocals = {};
        this.regToLocalIndex = {};
        this.localIndexToReg = {};
        this.localCount = 0;
    }
}


// ===== FILE: src/backend/constantPool.meow =====
export class ConstantPool {
    fn init(pool) {
        this.pool = pool; 
        this.lookup = {};
    }

    fn add(value) {
        if (typeof(value) == "object" && value != null && (value["sourceName"] != null)) {
             let key = "proto:" + value.sourceName;
             if (this.lookup[key] != null) {
                 return this.lookup[key];
             }
             let index = this.pool.length;
             this.pool.push(value);
             this.lookup[key] = index;
             return index;
        }

        let valueStr = str(value);

        let key = "meow:" + valueStr;
        
        if (this.lookup[key]) {
            return this.lookup[key];
        }

        let index = this.pool.length;
        this.pool.push(value);
        this.lookup[key] = index;
        
        return index;
    }

    fn get(index) {
        if (index >= 0 && index < this.pool.length) {
            return this.pool[index];
        }
        assert(false, "Lỗi: Index hằng số nằm ngoài giới hạn!");
        return null;
    }
}


// ===== FILE: src/backend/emitter.meow =====

import { OpCodes } from "backend/opCodes.meow";

let __PROTO_ID_COUNTER = 0;

let __LABEL_COUNTER = 0;
let __ANONYMOUS_FN_COUNTER = 0;

export fn createLabel(prefix) {
    __LABEL_COUNTER += 1;

    let label = prefix + "_" + __LABEL_COUNTER;

    return label;
}

export fn createAnonymousFunctionName() {
    __ANONYMOUS_FN_COUNTER += 1;
    return "__fn_" + str(__ANONYMOUS_FN_COUNTER);
}

export fn createProto(name, numRegisters) {
    let id = __PROTO_ID_COUNTER;
    __PROTO_ID_COUNTER = __PROTO_ID_COUNTER + 1;
    
    return {
        "id": id,
        "numRegisters": numRegisters,
        "sourceName": name,
        "code": [],
        "constantPool": [],
        "upvalueDescs": [],
        "labels": {},
        "pendingJumps": [],
        "numUpvalues": 0
    };
}

export fn emit(proto, opcode, args) {
    let inst = {"op": opcode, "args": [] };
    let ip = proto.code.length;
    for (a in args) {
        if (typeof(a) == "object" && a != null && (a["label"] != null)) {
            inst.args.push(-1);
            proto.pendingJumps.push({"ip": ip, "argIndex": inst.args.length - 1, "label": a.label});
        } else {
            inst.args.push(a);
        }
    }
    proto.code.push(inst);
}

export fn defineLabel(proto, label) {
    proto.labels[label] = proto.code.length;
}

export fn patchPendingJumps(proto) {
    for (p in proto.pendingJumps) {
        assert(proto.labels[p.label] != null, "Lỗi: Không tìm thấy label '" + p.label + "'!");
        let targetIp = proto.labels[p.label];
        proto.code[p.ip].args[p.argIndex] = targetIp;
    }
    proto.pendingJumps = [];
}

let __REG_ARGS = {
    [OpCodes.MOVE]: [0, 1],
    [OpCodes.LOAD_CONST]: [0],
    [OpCodes.LOAD_NULL]: [0],
    [OpCodes.LOAD_TRUE]: [0],
    [OpCodes.LOAD_FALSE]: [0],
    [OpCodes.LOAD_INT]: [0],
    [OpCodes.NOT]: [0, 1],
    [OpCodes.NEG]: [0, 1],
    [OpCodes.ADD]: [0, 1, 2],
    [OpCodes.SUB]: [0, 1, 2],
    [OpCodes.MUL]: [0, 1, 2],
    [OpCodes.DIV]: [0, 1, 2],
    [OpCodes.EQ]: [0, 1, 2],
    [OpCodes.NEQ]: [0, 1, 2],
    [OpCodes.LT]: [0, 1, 2],
    [OpCodes.LE]: [0, 1, 2],
    [OpCodes.GT]: [0, 1, 2],
    [OpCodes.GE]: [0, 1, 2],
    [OpCodes.BIT_AND]: [0, 1, 2],
    [OpCodes.BIT_OR]: [0, 1, 2],
    [OpCodes.BIT_XOR]: [0, 1, 2],
    [OpCodes.LSHIFT]: [0, 1, 2],
    [OpCodes.RSHIFT]: [0, 1, 2],
    [OpCodes.JUMP_IF_FALSE]: [0],
    [OpCodes.JUMP_IF_TRUE]: [0],
    [OpCodes.JUMP]: [],
    [OpCodes.GET_PROP]: [0, 1],
    [OpCodes.SET_PROP]: [0, 2],
    [OpCodes.GET_INDEX]: [0, 1, 2],
    [OpCodes.SET_INDEX]: [0, 1, 2],
    [OpCodes.NEW_ARRAY]: [0, 1],
    [OpCodes.NEW_HASH]: [0, 1],
    [OpCodes.CALL]: [0, 1, 2],
    [OpCodes.RETURN]: [0],
    [OpCodes.GET_UPVALUE]: [0],
    [OpCodes.SET_UPVALUE]: [1],
    [OpCodes.CLOSE_UPVALUES]: [],
    [OpCodes.CLOSURE]: [0],
    [OpCodes.IMPORT_MODULE]: [0],
    [OpCodes.GET_EXPORT]: [0, 1],
    [OpCodes.GET_GLOBAL]: [0],
    [OpCodes.SET_GLOBAL]: [1],
    [OpCodes.EXPORT]: [1],
    [OpCodes.NEW_CLASS]: [0],
    [OpCodes.SET_METHOD]: [0, 2],
    [OpCodes.INHERIT]: [0, 1],
    [OpCodes.GET_SUPER]: [0],
    [OpCodes.THROW]: [0],
    [OpCodes.SETUP_TRY]: [],
    [OpCodes.POP_TRY]: []
};

export fn getRegArgIndices(opcode) {
    return __REG_ARGS[opcode];
}

export fn computeMaxRegister(proto) {
    let maxR = -1;
    for (inst in proto.code) {
        let regIdxs = __REG_ARGS[inst.op];
        if (regIdxs != null) {
            for (idx in regIdxs) {
                if (idx < inst.args.length) {
                    let v = inst.args[idx];
                    if (typeof(v) == "int" && v > maxR) maxR = v;
                }
            }
        }
    }
    return maxR;
}

// ===== FILE: src/backend/opCodes.meow =====
export let OpCodes = {
    LOAD_CONST: "LOAD_CONST", 
    LOAD_NULL: "LOAD_NULL", 
    LOAD_TRUE: "LOAD_TRUE",
    LOAD_FALSE: "LOAD_FALSE", 
    LOAD_INT: "LOAD_INT", 
    MOVE: "MOVE",

    ADD: "ADD", 
    SUB: "SUB", 
    MUL: "MUL", 
    DIV: "DIV", 
    MOD: "MOD", 
    POW: "POW",

    EQ: "EQ", 
    NEQ: "NEQ", 
    GT: "GT", 
    GE: "GE", 
    LT: "LT", 
    LE: "LE",

    NEG: "NEG", 
    NOT: "NOT",

    GET_GLOBAL: "GET_GLOBAL", 
    SET_GLOBAL: "SET_GLOBAL", 
    GET_UPVALUE: "GET_UPVALUE",
    SET_UPVALUE: "SET_UPVALUE", 
    CLOSURE: "CLOSURE", 
    CLOSE_UPVALUES: "CLOSE_UPVALUES",
    JUMP: "JUMP", 
    JUMP_IF_FALSE: "JUMP_IF_FALSE",
    JUMP_IF_TRUE: "JUMP_IF_TRUE",
    CALL: "CALL", 
    RETURN: "RETURN", 
    HALT: "HALT",

    NEW_ARRAY: "NEW_ARRAY", 
    NEW_HASH: "NEW_HASH", 
    GET_INDEX: "GET_INDEX", 
    SET_INDEX: "SET_INDEX",
    GET_KEYS: "GET_KEYS",
    GET_VALUES: "GET_VALUES",

    NEW_CLASS: "NEW_CLASS", 
    GET_PROP: "GET_PROP", 
    SET_PROP: "SET_PROP",
    SET_METHOD: "SET_METHOD", 
    INHERIT: "INHERIT",
    GET_SUPER: "GET_SUPER",

    BIT_AND: "BIT_AND", 
    BIT_OR: "BIT_OR", 
    BIT_XOR: "BIT_XOR", 
    BIT_NOT: "BIT_NOT",
    LSHIFT: "LSHIFT", 
    RSHIFT: "RSHIFT",
    
    THROW: "THROW", 
    SETUP_TRY: "SETUP_TRY", 
    POP_TRY: "POP_TRY",
    IMPORT_MODULE: "IMPORT_MODULE",
    
    EXPORT: "EXPORT", 
    GET_EXPORT: "GET_EXPORT",
    IMPORT_ALL: "IMPORT_ALL",
};


// ===== FILE: src/backend/registerAllocator.meow =====
export class RegisterAllocator {
    fn init(numRegisters) {
        this._numRegisters = (numRegisters > 0) ? numRegisters : 256;
        this.reset();
    }

    fn reset() {
        this._nextRegister = 0;
    }

    fn ralloc() {
        let r = this._nextRegister;
        this._nextRegister++;
        return r;
    }

    fn rallocBlock(n) {
        assert(n > 0, "RegisterAllocator.rallocBlock: n phải > 0");
        let startReg = this._nextRegister;
        this._nextRegister += n;
        return startReg;
    }

    fn free(reg) {}

    fn beginScope() {}

    fn endScope() {}

    fn take() {
        return this.ralloc();
    }

    fn withTemp(fnUse) {
        let r = this.ralloc();
        let out = fnUse(r);
        return out;
    }

    fn usedRegisters() { 
        return this._nextRegister;
    }

    fn numRegisters() { 
        return this._nextRegister; 
    }
}

// ===== FILE: src/backend/utils/makeCacheFile.meow =====
import * as Io from "io";

export fn makeCacheFile(sourcePath, cacheDir) {
    let basename = Io.getFileStem(sourcePath);

    if (!Io.fileExists(cacheDir)) {
        Io.createDir(cacheDir);
    }

    let cacheName = basename + ".meowb";
    return cacheDir + "/" + cacheName;
}


// ===== FILE: src/backend/utils/pathUtils.meow =====
import * as Io from "io";

export fn getDirectoryPath(fullPath) {
    let filename = Io.getFileName(fullPath);
    if (filename.length >= fullPath.length) return "";
    return fullPath.slice(0, fullPath.length - filename.length);
}

export fn isAbsolutePath(path) {
    if (path.length == 0) return false;
    if (path[0] == "/" || path[0] == "\\") return true;
    if (path.length >= 3 && path[1] == ":") {
        let driveLetter = path[0];
        if ((driveLetter >= "a" && driveLetter <= "z") || (driveLetter >= "A" && driveLetter <= "Z")) {
            if (path[2] == "/" || path[2] == "\\") return true;
        }
    }
    return false;
}


// ===== FILE: src/backend/visitor/expression.meow =====
import * as Emitter from "backend/emitter.meow";
import { OpCodes } from "backend/opCodes.meow";
import { TokenType, tokenTypeToString, stringToTokenType } from "frontend/token.meow";

let binaryOps = {
    [TokenType.OP_PLUS]:      fn(l, r) { return l + r; }, [TokenType.OP_MINUS]:     fn(l, r) { return l - r; },
    [TokenType.OP_MULTIPLY]:  fn(l, r) { return l * r; }, [TokenType.OP_DIVIDE]:    fn(l, r) { return l / r; },
    [TokenType.OP_MODULO]:    fn(l, r) { return l % r; }, [TokenType.OP_EXPONENT]:  fn(l, r) { return l ** r; },
    [TokenType.OP_EQ]:        fn(l, r) { return l == r; }, [TokenType.OP_NEQ]:      fn(l, r) { return l != r; },
    [TokenType.OP_LT]:        fn(l, r) { return l < r; }, [TokenType.OP_GT]:       fn(l, r) { return l > r; },
    [TokenType.OP_LE]:        fn(l, r) { return l <= r; }, [TokenType.OP_GE]:      fn(l, r) { return l >= r; },
    [TokenType.OP_BIT_AND]:   fn(l, r) { return l & r; }, [TokenType.OP_BIT_OR]:    fn(l, r) { return l | r; },
    [TokenType.OP_BIT_XOR]:   fn(l, r) { return l ^ r; }, [TokenType.OP_LSHIFT]:    fn(l, r) { return l << r; },
    [TokenType.OP_RSHIFT]:    fn(l, r) { return l >> r; },
};
let unaryOps = {
    [TokenType.OP_MINUS]:       fn(r) { return -r; }, [TokenType.OP_LOGICAL_NOT]: fn(r) { return !r; },
    [TokenType.OP_BIT_NOT]:     fn(r) { return ~r; },
};
fn isLiteral(type) { return type == "IntegerLiteral" || type == "RealLiteral" || type == "StringLiteral" || type == "BooleanLiteral" || type == "NullLiteral"; }
fn toNode(value) {
    let t = typeof(value);
    if (t == "int") return { "type": "IntegerLiteral", "value": value };
    if (t == "real") return { "type": "RealLiteral", "value": value };
    if (t == "string") return { "type": "StringLiteral", "value": value };
    if (t == "bool") return { "type": "BooleanLiteral", "value": value };
    if (t == "null") return { "type": "NullLiteral" };
    return null;
}
fn handleBinary(node) {
    if (!node || node.type != "BinaryExpression") return node;
    node.left = handleBinary(node.left); node.right = handleBinary(node.right);
    if (isLiteral(node.left.type) && isLiteral(node.right.type)) {
        let func = binaryOps[node.op];
        if (func) return toNode(func(node.left.value, node.right.value));
    }
    return node;
}
fn handleUnary(node) {
    if (!node || node.type != "UnaryExpression") return node;
    node.right = handleUnary(node.right);
    if (isLiteral(node.right.type)) {
        let func = unaryOps[node.op];
        if (func) return toNode(func(node.right.value));
    }
    return node;
}

export fn visitIdentifier(cg, node) {
    assert(node.resolution, "Lỗi: visitIdentifier không tìm thấy 'resolution' cho '" + node.name + "'!");
    let resolution = node.resolution;
    
    let destReg = cg.currentState.allocator.ralloc();

    if (resolution.type == "local") {
        let localSlot = resolution.symbol.index;
        
        let reg = cg.currentState.localIndexToReg[localSlot];
        
        assert(reg != null, "Lỗi CodeGen: Không tìm thấy thanh ghi cho local slot " + str(localSlot) + " (biến '" + node.name + "')");
        
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, reg]);
        
    } else if (resolution.type == "upvalue") {
        Emitter.emit(cg.currentState.proto, OpCodes.GET_UPVALUE, [destReg, resolution.index]);
        
    } else { 
        let constIdx = cg.currentState.pool.add(resolution.name);
        Emitter.emit(cg.currentState.proto, OpCodes.GET_GLOBAL, [destReg, constIdx]);
    }
    
    return destReg;
}

export fn visitBinaryExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    if (node.op == TokenType.OP_LOGICAL_AND) {
        let endLabel = Emitter.createLabel("L_AND_END");
        let destReg = cg.currentState.allocator.ralloc();
        cg.currentState.allocator.beginScope();
        let leftReg = cg.visitExpression(node.left);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, leftReg]);
        Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [leftReg, {"label": endLabel}]);
        let rightReg = cg.visitExpression(node.right);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, rightReg]);
        cg.currentState.allocator.endScope();
        Emitter.defineLabel(cg.currentState.proto, endLabel);
        return destReg;
    }

    if (node.op == TokenType.OP_LOGICAL_OR) {
        let endLabel = Emitter.createLabel("L_OR_END");
        let destReg = cg.currentState.allocator.ralloc();
        cg.currentState.allocator.beginScope();
        let leftReg = cg.visitExpression(node.left);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, leftReg]);
        Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_TRUE, [leftReg, {"label": endLabel}]);
        let rightReg = cg.visitExpression(node.right);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, rightReg]);
        cg.currentState.allocator.endScope();
        Emitter.defineLabel(cg.currentState.proto, endLabel);
        return destReg;
    }
    
    let opMap = {
        [TokenType.OP_PLUS]: OpCodes.ADD, [TokenType.OP_MINUS]: OpCodes.SUB, [TokenType.OP_MULTIPLY]: OpCodes.MUL,
        [TokenType.OP_DIVIDE]: OpCodes.DIV, [TokenType.OP_MODULO]: OpCodes.MOD, [TokenType.OP_EXPONENT]: OpCodes.POW,
        [TokenType.OP_EQ]: OpCodes.EQ, [TokenType.OP_NEQ]: OpCodes.NEQ, [TokenType.OP_LT]: OpCodes.LT,
        [TokenType.OP_GT]: OpCodes.GT, [TokenType.OP_LE]: OpCodes.LE, [TokenType.OP_GE]: OpCodes.GE,
        [TokenType.OP_BIT_AND]: OpCodes.BIT_AND, [TokenType.OP_BIT_OR]: OpCodes.BIT_OR,
        [TokenType.OP_BIT_XOR]: OpCodes.BIT_XOR, [TokenType.OP_LSHIFT]: OpCodes.LSHIFT, [TokenType.OP_RSHIFT]: OpCodes.RSHIFT
    };
    let opcode = opMap[node.op];
    assert(opcode, "Lỗi: Toán tử nhị phân không được hỗ trợ: " + node.op);

    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let leftReg = cg.visitExpression(node.left);
    let rightReg = cg.visitExpression(node.right);
    Emitter.emit(cg.currentState.proto, opcode, [destReg, leftReg, rightReg]);
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitUnaryExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let opMap = { [TokenType.OP_MINUS]: OpCodes.NEG, [TokenType.OP_LOGICAL_NOT]: OpCodes.NOT, [TokenType.OP_BIT_NOT]: OpCodes.BIT_NOT };
    let opcode = opMap[node.op];
    assert(opcode, "Lỗi: Toán tử một ngôi không được hỗ trợ: " + node.op);

    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let operandReg = cg.visitExpression(node.operand);
    Emitter.emit(cg.currentState.proto, opcode, [destReg, operandReg]);
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitCallExpression(cg, node) {

    let destReg = cg.currentState.allocator.ralloc();


    let savedCalleeReg = cg.currentState.allocator.ralloc();

    cg.currentState.allocator.beginScope();

    let calleeTempReg = cg.visitExpression(node.callee);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [savedCalleeReg, calleeTempReg]);

    let argc = node.args.length;
    let tempArgRegs = [];

    for (let i = 0; i < argc; ++i) {
        let tempReg = cg.visitExpression(node.args[i]);
        tempArgRegs.push(tempReg);
    }

    let argStartReg = cg.currentState.allocator.rallocBlock(argc > 0 ? argc : 1);

    if (argc > 0) {
        let minSrc = tempArgRegs[0];
        let maxSrc = tempArgRegs[0];
        for (let k = 1; k < tempArgRegs.length; ++k) {
            if (tempArgRegs[k] < minSrc) minSrc = tempArgRegs[k];
            if (tempArgRegs[k] > maxSrc) maxSrc = tempArgRegs[k];
        }

        let destStart = argStartReg;
        let destEnd = argStartReg + argc - 1;
        let overlap = !(destEnd < minSrc || destStart > maxSrc);

        if (overlap && destStart > minSrc) {
            for (let i = argc - 1; i >= 0; --i) {
                let targetReg = argStartReg + i;
                let sourceReg = tempArgRegs[i];
                if (targetReg != sourceReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, sourceReg]);
                }
            }
        } else {
            for (let i = 0; i < argc; ++i) {
                let targetReg = argStartReg + i;
                let sourceReg = tempArgRegs[i];
                if (targetReg != sourceReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, sourceReg]);
                }
            }
        }
    }

    Emitter.emit(cg.currentState.proto, OpCodes.CALL, [destReg, savedCalleeReg, argStartReg, argc]);

    cg.currentState.allocator.endScope();

    cg.currentState.allocator.free(savedCalleeReg);

    return destReg;
}

export fn visitAssignmentExpression(cg, node) {
    let targetNode = node.target;
    cg.currentState.allocator.beginScope();
    
    if (targetNode.type == "Identifier") {
        
        assert(targetNode.resolution, "Lỗi: visitAssignment không tìm thấy 'resolution' cho '" + targetNode.name + "'!");
        let resolution = targetNode.resolution;
        
        let valueReg = cg.visitExpression(node.value);

        if (resolution.type == "local") {
            let localSlot = resolution.symbol.index;
            
            let reg = cg.currentState.localIndexToReg[localSlot];
            assert(reg != null, "Lỗi CodeGen: Gán cho local slot " + str(localSlot) + " không tìm thấy thanh ghi");
            
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [reg, valueReg]);
            
        } else if (resolution.type == "upvalue") {
            Emitter.emit(cg.currentState.proto, OpCodes.SET_UPVALUE, [resolution.index, valueReg]);
            
        } else { 
            let constIdx = cg.currentState.pool.add(resolution.name);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [constIdx, valueReg]);
        }
        
        cg.currentState.allocator.endScope();
        return valueReg;
        
    } else if (targetNode.type == "PropertyAccess") {
        let objReg = cg.visitExpression(targetNode.object);
        let valueReg = cg.visitExpression(node.value);
        let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, valueReg]);
        cg.currentState.allocator.endScope();
        return valueReg;
        
    } else if (targetNode.type == "IndexExpression") {
        let objReg = cg.visitExpression(targetNode.object);
        let indexReg = cg.visitExpression(targetNode.index);
        let valueReg = cg.visitExpression(node.value);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_INDEX, [objReg, indexReg, valueReg]);
        cg.currentState.allocator.endScope();
        return valueReg;
        
    } else {
        assert(false, "Lỗi: Đích của phép gán không được hỗ trợ: " + targetNode.type);
    }
    
    cg.currentState.allocator.endScope();
    return -1;
}

export fn visitPrefixUpdateExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let targetNode = node.operand;
    let op = (node.op == TokenType.OP_INCREMENT) ? OpCodes.ADD : OpCodes.SUB;

    cg.currentState.allocator.withTemp(fn(oneReg) {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [oneReg, 1]);
        if (targetNode.type == "Identifier") {
            assert(targetNode.resolution, "Lỗi: visitPrefixUpdateExpression không tìm thấy 'resolution' cho '" + targetNode.name + "'!");
            let resolution = targetNode.resolution;
            assert(resolution.type == "local", "Toán tử ++/-- chỉ hỗ trợ biến local.");
            
            let localSlot = resolution.symbol.index;
            let targetReg = cg.currentState.localIndexToReg[localSlot];
            assert(targetReg != null, "Lỗi CodeGen: Không tìm thấy thanh ghi cho local slot " + str(localSlot));

            Emitter.emit(cg.currentState.proto, op, [targetReg, targetReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, targetReg]);
        } else if (targetNode.type == "PropertyAccess") {            let objReg = cg.visitExpression(targetNode.object);
            let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
            let currentValReg = cg.currentState.allocator.ralloc();
            Emitter.emit(cg.currentState.proto, OpCodes.GET_PROP, [currentValReg, objReg, propNameIdx]);
            Emitter.emit(cg.currentState.proto, op, [currentValReg, currentValReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, currentValReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, currentValReg]);
        }
    });
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitPostfixUpdateExpression(cg, node) {
    if (typeof(node.op) == "string") {
        node.op = stringToTokenType(node.op);
    }
    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let targetNode = node.operand;
    let op = (node.op == TokenType.OP_INCREMENT) ? OpCodes.ADD : OpCodes.SUB;

    cg.currentState.allocator.withTemp(fn(oneReg) {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [oneReg, 1]);
        if (targetNode.type == "Identifier") {
            assert(targetNode.resolution, "Lỗi: visitPostfixUpdateExpression không tìm thấy 'resolution' cho '" + targetNode.name + "'!");
            let resolution = targetNode.resolution;
            assert(resolution.type == "local", "Toán tử ++/-- chỉ hỗ trợ biến local.");
            
            let localSlot = resolution.symbol.index;
            let targetReg = cg.currentState.localIndexToReg[localSlot];
            assert(targetReg != null, "Lỗi CodeGen: Không tìm thấy thanh ghi cho local slot " + str(localSlot));

            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, targetReg]);
            Emitter.emit(cg.currentState.proto, op, [targetReg, targetReg, oneReg]);
        } else if (targetNode.type == "PropertyAccess") {            let objReg = cg.visitExpression(targetNode.object);
            let propNameIdx = cg.currentState.pool.add(targetNode.property.name);
            Emitter.emit(cg.currentState.proto, OpCodes.GET_PROP, [destReg, objReg, propNameIdx]);
            let newValReg = cg.currentState.allocator.ralloc();
            Emitter.emit(cg.currentState.proto, op, [newValReg, destReg, oneReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, newValReg]);
        }
    });
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitIndexExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    cg.currentState.allocator.beginScope();
    let objReg = cg.visitExpression(node.object);
    let indexReg = cg.visitExpression(node.index);
    Emitter.emit(cg.currentState.proto, OpCodes.GET_INDEX, [destReg, objReg, indexReg]);
    cg.currentState.allocator.endScope();
    return destReg;
}

export fn visitPropertyAccess(cg, node) {

    let savedObjReg = cg.currentState.allocator.ralloc();


    cg.currentState.allocator.beginScope();
    let objTempReg = cg.visitExpression(node.object);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [savedObjReg, objTempReg]);
    cg.currentState.allocator.endScope();


    let destReg = cg.currentState.allocator.ralloc();
    let propNameIdx = cg.currentState.pool.add(node.property.name);
    let opcode = OpCodes.GET_PROP;
    if (node.object.type == "Identifier" && (cg.currentState.moduleVariables[node.object.name] != null)) {
        opcode = OpCodes.GET_EXPORT;
    }

    Emitter.emit(cg.currentState.proto, opcode, [destReg, savedObjReg, propNameIdx]);

    cg.currentState.allocator.free(savedObjReg);

    return destReg;
}


export fn visitThisExpression(cg, node) {
    let thisReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [thisReg, 0]);
    return thisReg;
}

export fn visitSuperExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    let nameIdx = cg.currentState.pool.add(node.method.name);
    Emitter.emit(cg.currentState.proto, OpCodes.GET_SUPER, [destReg, nameIdx]);
    return destReg;
}

export fn visitNewExpression(cg, node) {
    return cg.visitExpression(node.expression);
}

export fn visitTernaryExpression(cg, node) {
    let destReg = cg.currentState.allocator.ralloc();
    let elseLabel = Emitter.createLabel("L_TERNARY_ELSE");
    let endLabel = Emitter.createLabel("L_TERNARY_END");

    cg.currentState.allocator.beginScope();
    let condReg = cg.visitExpression(node.condition);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": elseLabel}]);
    cg.currentState.allocator.endScope();

    cg.currentState.allocator.beginScope();
    let thenReg = cg.visitExpression(node.thenBranch);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, thenReg]);
    cg.currentState.allocator.endScope();
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": endLabel}]);

    Emitter.defineLabel(cg.currentState.proto, elseLabel);
    cg.currentState.allocator.beginScope();
    let elseReg = cg.visitExpression(node.elseBranch);
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, elseReg]);
    cg.currentState.allocator.endScope();

    Emitter.defineLabel(cg.currentState.proto, endLabel);
    return destReg;
}

export fn visitPropertyAssignment(cg, node) {
    let valueReg = cg.visitExpression(node.value);
    
    cg.currentState.allocator.beginScope();
    
    let objReg = cg.visitExpression(node.targetObj);
    
    let propNameIdx = cg.currentState.pool.add(node.property.name);
    
    Emitter.emit(cg.currentState.proto, OpCodes.SET_PROP, [objReg, propNameIdx, valueReg]);
    
    cg.currentState.allocator.endScope(); 
    
    return valueReg;
}


// ===== FILE: src/backend/visitor/literal.meow =====
import * as String from "string";
import * as Emitter from "backend/emitter.meow";
import { OpCodes } from "backend/opCodes.meow";

fn _emitConst(cg, value) {
    let constIdx = cg.currentState.pool.add(value);

    let reg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_CONST, [reg, constIdx]);
    return reg;
}

export fn visitIntegerLiteral(cg, node) {
    let reg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [reg, node.value]);
    return reg;
}

export fn visitStringLiteral(cg, node) {
    return _emitConst(cg, node.value);
}

export fn visitRealLiteral(cg, node) {
    return _emitConst(cg, node.value);
}

export fn visitBooleanLiteral(cg, node) {
    let reg = cg.currentState.allocator.ralloc();
    let opcode = node.value ? OpCodes.LOAD_TRUE : OpCodes.LOAD_FALSE;
    Emitter.emit(cg.currentState.proto, opcode, [reg]);
    return reg;
}

export fn visitNullLiteral(cg, node) {
    let reg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_NULL, [reg]);
    return reg;
}

export fn visitArrayLiteral(cg, node) {
    let count = node.elements.length;
    if (count == 0) {
        let dst = cg.currentState.allocator.ralloc();
        Emitter.emit(cg.currentState.proto, OpCodes.NEW_ARRAY, [dst, 0, 0]);
        return dst;
    }

    cg.currentState.allocator.beginScope();
    let startReg = cg.currentState.allocator.rallocBlock(count);
    
    for (let i = 0; i < count; ++i) {
        let elemReg = cg.visitExpression(node.elements[i]);
        let targetReg = startReg + i;
        if (elemReg != targetReg) {
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetReg, elemReg]);
        }
    }

    let dstReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.NEW_ARRAY, [dstReg, startReg, count]);

    
    cg.currentState.allocator.endScope();
    return dstReg;
}

export let visitObjectLiteral = fn(cg, node) {
    let count = node.properties.length;
    if (count == 0) {
        let dst = cg.currentState.allocator.ralloc();
        Emitter.emit(cg.currentState.proto, OpCodes.NEW_HASH, [dst, 0, 0]);
        return dst;
    }

    cg.currentState.allocator.beginScope();

    let startReg = cg.currentState.allocator.rallocBlock(count * 2);
    let targetKeyReg = 0;
    let targetValReg = 0;

    for (let i = 0; i < count; ++i) {
        let pair = node.properties[i];
        let keyNode = pair.key;
        let valNode = pair.value;

        targetKeyReg = startReg + i * 2;
        targetValReg = startReg + i * 2 + 1;

        if (keyNode.type == 'StringLiteral') {
            let constIdx = cg.currentState.pool.add(keyNode.value);
            cg.currentState.allocator.withTemp(fn(tempReg) {
                Emitter.emit(cg.currentState.proto, OpCodes.LOAD_CONST, [tempReg, constIdx]);
                if (tempReg != targetKeyReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetKeyReg, tempReg]);
                }
            });
        } else if (keyNode.type == 'Identifier') {
            let constIdx = cg.currentState.pool.add(keyNode.name);
            cg.currentState.allocator.withTemp(fn(tempReg) {
                Emitter.emit(cg.currentState.proto, OpCodes.LOAD_CONST, [tempReg, constIdx]);
                if (tempReg != targetKeyReg) {
                    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetKeyReg, tempReg]);
                }
            });
        } else {
            let keyReg = cg.visitExpression(keyNode);
            if (keyReg != targetKeyReg) {
                Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetKeyReg, keyReg]);
            }
        }

        let valReg = cg.visitExpression(valNode);
        if (valReg != targetValReg) {
            Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [targetValReg, valReg]);
        }
    }

    let dstReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.NEW_HASH, [dstReg, startReg, count]);
    cg.currentState.allocator.endScope();
    return dstReg;
};

export let visitFunctionLiteral = fn(cg, node) {
    let descriptiveName;
    if (node.name) { 
        let safeName = String.replace(node.name, "@", "_");
        safeName = String.replace(safeName, " ", "_");
        descriptiveName = safeName;
    } else { 
        descriptiveName = Emitter.createAnonymousFunctionName();
    }
    
    let parentSource = (cg.currentState && cg.currentState.proto && cg.currentState.proto.sourceName) ? cg.currentState.proto.sourceName : "anon_parent";
    let funcName = '@' + descriptiveName + '_' + parentSource + '_' + str(cg.currentState ? cg.currentState.proto.code.length : 0);
    
    cg.enterState(funcName);
    let paramScope = cg.currentState.scope[0];
    
    if (cg.isInsideClass) {
        cg.currentState.allocator.ralloc(); 
    }

    let wasInsideClass = cg.isInsideClass;
    cg.isInsideClass = false;

    for (paramNode in node.parameters) {
        assert(paramNode.resolution && paramNode.resolution.type == "local", "Lỗi: Tham số " + paramNode.name + " không được resolve là local");
        
        let localSlot = paramNode.resolution.symbol.index;
        
        let reg = cg.currentState.allocator.ralloc();
        
        cg.currentState.localIndexToReg[localSlot] = reg;
        cg.currentState.regToLocalIndex[str(reg)] = localSlot;
        
        paramScope[paramNode.name] = localSlot;
    }

    cg.visitStatement(node.body);
    
    let childProto = cg.exitState();

    cg.isInsideClass = wasInsideClass;

    let upvalues = node.resolved_upvalues;
    if (upvalues && upvalues.length > 0) {
        childProto.upvalueDescs = []; 
        childProto.numUpvalues = upvalues.length;

        for (up in upvalues) {
            if (up.isLocal) {
                let localSlot = up.index; 
                
                let registerToCapture = cg.currentState.localIndexToReg[localSlot];
                
                assert(registerToCapture != null, "Lỗi CodeGen: Không thể map upvalue local slot " + str(localSlot) + " sang register.");
                
                cg.currentState.capturedLocals[localSlot] = true;
                
                childProto.upvalueDescs.push({ "isLocal": true, "index": registerToCapture });
            } else {
                childProto.upvalueDescs.push({ "isLocal": false, "index": up.index });
            }
        }
    }

    assert(childProto.sourceName && childProto.sourceName.length > 3, "Bad childProto.sourceName after visitFunctionLiteral");

    cg.protos[childProto.sourceName] = childProto;
    let parentPool = cg.currentState.pool;
    let protoIdx = parentPool.add(childProto);

    let destReg = cg.currentState.allocator.ralloc();
    Emitter.emit(cg.currentState.proto, OpCodes.CLOSURE, [destReg, protoIdx]);

    return destReg;
};

export fn visitTemplateLiteral(cg, node) {
    if (node.parts.length == 0) {
        return _emitConst(cg, "");
    }

    let resultReg = cg.visitExpression(node.parts[0]);

    cg.currentState.allocator.beginScope();
    for (let i = 1; i < node.parts.length; ++i) {
        let partReg = cg.visitExpression(node.parts[i]);
        Emitter.emit(cg.currentState.proto, OpCodes.ADD, [resultReg, resultReg, partReg]);

    }
    cg.currentState.allocator.endScope();

    return resultReg;
}


// ===== FILE: src/backend/visitor/statement.meow =====
import * as Io from "io";
import * as Json from "json";
import * as Emitter from "backend/emitter.meow";
import { OpCodes } from "backend/opCodes.meow";

fn _endScopeAndCloseUpvalues(cg) {
    let scopeToEnd = cg.currentState.scope[cg.currentState.scope.length - 1];
    let lowestRegisterToClose = -1;

    for (varName in scopeToEnd.keys()) {
        let localIndex = scopeToEnd[varName];

        if (localIndex != null && cg.currentState.capturedLocals[localIndex]) {
            let register = cg.currentState.localIndexToReg[localIndex];
            if (register != null) {

                if (lowestRegisterToClose == -1 || register < lowestRegisterToClose) {
                    lowestRegisterToClose = register;
                }
            }
        }

        let register = cg.currentState.localIndexToReg[localIndex];
        if (register != null) {
            cg.currentState.localIndexToReg[localIndex] = null;
            cg.currentState.regToLocalIndex[str(register)] = null;
        }
    }

    if (lowestRegisterToClose != -1) {
        Emitter.emit(cg.currentState.proto, OpCodes.CLOSE_UPVALUES, [lowestRegisterToClose]);
    }

    cg.currentState.scope.pop();
    cg.currentState.allocator.endScope();
}

export let visitLetStatement = fn(cg, node) {
    let name = node.name.name;
    
    assert(node.name.resolution && node.name.resolution.type == "local", "Lỗi: LetStatement " + name + " không được resolve là local");
    let localSlot = node.name.resolution.symbol.index;
    
    let scopeLevel = cg.currentState.scope.length - 1;
    let currentScope = cg.currentState.scope[scopeLevel];

    let destReg;
    if (scopeLevel > 0) {
        destReg = cg.currentState.allocator.take();
    } else {
        destReg = cg.currentState.allocator.ralloc();
    }

    cg.currentState.regToLocalIndex[str(destReg)] = localSlot;
    cg.currentState.localIndexToReg[localSlot] = destReg;
    currentScope[name] = localSlot;
    
    if (node.value != null) {
        cg.currentState.allocator.beginScope();
        let valueReg = cg.visitExpression(node.value);
        Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, valueReg]);
        cg.currentState.allocator.endScope();
    } else {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_NULL, [destReg]);
    }

    if (scopeLevel == 0 && cg.states.length == 1) {
        let constIdx = cg.currentState.pool.add(name);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [constIdx, destReg]);
    }
};

export let visitFunctionStatement = fn(cg, node) {
    let name = node.name.name;
    node.func.name = name;
    
    assert(node.name.resolution && node.name.resolution.type == "local", "Lỗi: FunctionStatement " + name + " không được resolve là local");
    let localSlot = node.name.resolution.symbol.index; //

    let scopeLevel = cg.currentState.scope.length - 1;
    let currentScope = cg.currentState.scope[scopeLevel];

    let destReg;
    if (scopeLevel > 0) {
        destReg = cg.currentState.allocator.take();
    } else {
        destReg = cg.currentState.allocator.ralloc();
    }
    
    cg.currentState.regToLocalIndex[str(destReg)] = localSlot;
    cg.currentState.localIndexToReg[localSlot] = destReg;
    currentScope[name] = localSlot;

    let valueReg = cg.visitExpression(node.func);
    
    Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [destReg, valueReg]);
    
    if (scopeLevel == 0 && cg.states.length == 1) {
        let constIdx = cg.currentState.pool.add(name);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [constIdx, destReg]);
    }
};

export fn visitClassStatement(cg, node) {
    let className = node.name.name;
    let classNameIdx = cg.currentState.pool.add(className);

    assert(node.name.resolution && node.name.resolution.type == "local", "Lỗi: ClassStatement " + className + " không được resolve là local");
    let localSlot = node.name.resolution.symbol.index;

    let classReg = cg.currentState.allocator.take();
    
    cg.currentState.regToLocalIndex[str(classReg)] = localSlot;
    cg.currentState.localIndexToReg[localSlot] = classReg;
    let currentScope = cg.currentState.scope[cg.currentState.scope.length - 1];
    currentScope[className] = localSlot;
    
    Emitter.emit(cg.currentState.proto, OpCodes.NEW_CLASS, [classReg, classNameIdx]);
    
    cg.currentState.allocator.beginScope();
    if (node.superclass != null) {
        let parentClassReg = cg.visitExpression(node.superclass);
        Emitter.emit(cg.currentState.proto, OpCodes.INHERIT, [classReg, parentClassReg]);
    }

    cg.isInsideClass = true;
    for (methodNode in node.methods) {
        let methodName = methodNode.name.name;
        methodNode.func.name = className + "." + methodName;
        let methodClosureReg = cg.visitExpression(methodNode.func);
        let methodNameIdx = cg.currentState.pool.add(methodName);
        Emitter.emit(cg.currentState.proto, OpCodes.SET_METHOD, [classReg, methodNameIdx, methodClosureReg]);
    }
    cg.isInsideClass = false;
    cg.currentState.allocator.endScope();

    if (cg.currentState.scope.length == 1) {
        Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [classNameIdx, classReg]);
    }
}


export fn visitReturnStatement(cg, node) {
    let reg;
    if (node.value != null) {
        reg = cg.visitExpression(node.value);
    } else {
        reg = cg.currentState.allocator.take();
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_NULL, [reg]);
    }
    Emitter.emit(cg.currentState.proto, OpCodes.RETURN, [reg]);
}

export fn visitIfStatement(cg, node) {
    let elseLabel = Emitter.createLabel("L_ELSE");
    let endLabel = Emitter.createLabel("L_ENDIF");

    cg.currentState.allocator.beginScope();
    let condReg = cg.visitExpression(node.condition);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": node.elseBranch ? elseLabel : endLabel}]);
    cg.currentState.allocator.endScope();

    cg.visitStatement(node.thenBranch);

    if (node.elseBranch != null) {
        Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": endLabel}]);
        Emitter.defineLabel(cg.currentState.proto, elseLabel);
        cg.visitStatement(node.elseBranch);
    }

    Emitter.defineLabel(cg.currentState.proto, endLabel);
}

export fn visitWhileStatement(cg, node) {
    let startLabel = Emitter.createLabel("L_WHILE_START");
    let endLabel = Emitter.createLabel("L_WHILE_END");

    cg.currentState.loopLabels.push({ "continueTarget": startLabel, "breakTarget": endLabel });

    Emitter.defineLabel(cg.currentState.proto, startLabel);

    cg.currentState.allocator.beginScope();
    let condReg = cg.visitExpression(node.condition);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": endLabel}]);
    cg.currentState.allocator.endScope();

    cg.visitStatement(node.body);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": startLabel}]);
    Emitter.defineLabel(cg.currentState.proto, endLabel);

    cg.currentState.loopLabels.pop();
}

export fn visitBreakStatement(cg, node) {
    assert(cg.currentState.loopLabels.length > 0, "Lỗi: 'break' chỉ có thể được dùng trong vòng lặp!");
    let labels = cg.currentState.loopLabels[cg.currentState.loopLabels.length - 1];
    
    assert(labels.breakTarget, "Lỗi logic: Vòng lặp không có nhãn 'break'.");
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": labels.breakTarget}]);
}

export fn visitContinueStatement(cg, node) {
    assert(cg.currentState.loopLabels.length > 0, "Lỗi: 'continue' chỉ có thể được dùng trong vòng lặp!");
    let labels = cg.currentState.loopLabels[cg.currentState.loopLabels.length - 1];

    assert(labels.continueTarget, "Lỗi logic: Vòng lặp không hỗ trợ 'continue'.");
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": labels.continueTarget}]);
}

export fn visitBlockStatement(cg, node) {
    cg.currentState.allocator.beginScope();
    cg.currentState.scope.push({});

    for (statement in node.statements) {
        cg.visitStatement(statement);
    }

    _endScopeAndCloseUpvalues(cg);
}

export fn visitExpressionStatement(cg, node) {
    cg.currentState.allocator.beginScope();
    cg.visitExpression(node.expression);
    cg.currentState.allocator.endScope();
}

export fn visitForStatement(cg, node) {

    cg.currentState.allocator.beginScope();
    cg.currentState.scope.push({});
    
    if (node.init != null) {
        cg.visitStatement(node.init);
    }

    let conditionLabel = Emitter.createLabel("L_FOR_COND");
    let updateLabel = Emitter.createLabel("L_FOR_UPDATE");
    let endLabel = Emitter.createLabel("L_FOR_END");
    cg.currentState.loopLabels.push({ "continueTarget": updateLabel, "breakTarget": endLabel });

    Emitter.defineLabel(cg.currentState.proto, conditionLabel);

    if (node.condition != null) {
        cg.currentState.allocator.withTemp(fn(condReg) {
             let tempReg = cg.visitExpression(node.condition);
             Emitter.emit(cg.currentState.proto, OpCodes.MOVE, [condReg, tempReg]);
             Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": endLabel}]);
        });
    }

    cg.visitStatement(node.body);

    Emitter.defineLabel(cg.currentState.proto, updateLabel);
    if (node.update != null) {
        cg.currentState.allocator.beginScope();
        cg.visitExpression(node.update);
        cg.currentState.allocator.endScope();
    }

    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": conditionLabel}]);
    Emitter.defineLabel(cg.currentState.proto, endLabel);

    cg.currentState.loopLabels.pop();

    _endScopeAndCloseUpvalues(cg);
}

export fn visitForInStatement(cg, node) {
    cg.currentState.allocator.beginScope();
    cg.currentState.scope.push({});

    let collectionReg = cg.visitExpression(node.collection);
    let keysArrayReg = cg.currentState.allocator.take();
    Emitter.emit(cg.currentState.proto, OpCodes.GET_VALUES, [keysArrayReg, collectionReg]);

    let indexReg = cg.currentState.allocator.take();
    Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [indexReg, 0]);

    let lengthReg = cg.currentState.allocator.take();
    let lengthNameIdx = cg.currentState.pool.add("length");
    Emitter.emit(cg.currentState.proto, OpCodes.GET_PROP, [lengthReg, keysArrayReg, lengthNameIdx]);
    
    let startLabel = Emitter.createLabel("L_FORIN_START");
    let endLabel = Emitter.createLabel("L_FORIN_END");
    
    cg.currentState.loopLabels.push({ "continueTarget": startLabel, "breakTarget": endLabel });
    Emitter.defineLabel(cg.currentState.proto, startLabel);
    
    let condReg = cg.currentState.allocator.take();
    Emitter.emit(cg.currentState.proto, OpCodes.LT, [condReg, indexReg, lengthReg]);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [condReg, {"label": endLabel}]);

    let keyReg = cg.currentState.allocator.take();
    Emitter.emit(cg.currentState.proto, OpCodes.GET_INDEX, [keyReg, keysArrayReg, indexReg]);

    let varName = node.variable.name;
    
    assert(node.variable.resolution && node.variable.resolution.type == "local", "Lỗi: Biến ForIn " + varName + " không được resolve là local");
    let localSlot = node.variable.resolution.symbol.index;
    
    cg.currentState.regToLocalIndex[str(keyReg)] = localSlot;
    cg.currentState.localIndexToReg[localSlot] = keyReg;
    cg.currentState.scope[cg.currentState.scope.length - 1][varName] = localSlot;
    
    cg.visitStatement(node.body);
    
    cg.currentState.allocator.withTemp(fn(oneReg) {
        Emitter.emit(cg.currentState.proto, OpCodes.LOAD_INT, [oneReg, 1]);
        Emitter.emit(cg.currentState.proto, OpCodes.ADD, [indexReg, indexReg, oneReg]);
    });
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": startLabel}]);
    Emitter.defineLabel(cg.currentState.proto, endLabel);
    
    cg.currentState.loopLabels.pop();

    _endScopeAndCloseUpvalues(cg);
}

export fn visitThrowStatement(cg, node) {
    cg.currentState.allocator.beginScope();
    let errorReg = cg.visitExpression(node.argument);
    Emitter.emit(cg.currentState.proto, OpCodes.THROW, [errorReg]);
    cg.currentState.allocator.endScope();
}

export fn visitTryStatement(cg, node) {
    let catchLabel = Emitter.createLabel("L_CATCH");
    let endLabel = Emitter.createLabel("L_END_TRY");

    Emitter.emit(cg.currentState.proto, OpCodes.SETUP_TRY, [{"label": catchLabel}]);
    cg.visitStatement(node.tryBlock);
    Emitter.emit(cg.currentState.proto, OpCodes.POP_TRY, []);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": endLabel}]);

    Emitter.defineLabel(cg.currentState.proto, catchLabel);
    
    cg.currentState.allocator.beginScope();
    cg.currentState.scope.push({});
    
    if (node.catchVariable != null) {
        let errorVarName = node.catchVariable.name;
        
        assert(node.catchVariable.resolution && node.catchVariable.resolution.type == "local", "Lỗi: Biến Catch " + errorVarName + " không được resolve là local");
        let localSlot = node.catchVariable.resolution.symbol.index;

        let errorReg = 0; 
        
        cg.currentState.regToLocalIndex[str(errorReg)] = localSlot;
        cg.currentState.localIndexToReg[localSlot] = errorReg;
        cg.currentState.scope[cg.currentState.scope.length - 1][errorVarName] = localSlot;
    }
    
    cg.visitStatement(node.catchBlock);

    _endScopeAndCloseUpvalues(cg);
    Emitter.defineLabel(cg.currentState.proto, endLabel);
}

export fn visitExportStatement(cg, node) {
    cg.visitStatement(node.declaration);
    let name = node.declaration.name.name;
    let currentScope = cg.currentState.scope[cg.currentState.scope.length - 1];
    assert(currentScope[name] != null, "Lỗi logic: Biến '" + name + "' không có trong scope sau khi khai báo.");
    let localIndex = currentScope[name];
    let regIndex = cg.currentState.localIndexToReg[localIndex];
    assert(regIndex != null, "Lỗi nghiêm trọng: Không tìm thấy thanh ghi cho biến được export '" + name + "'");
    let nameIdx = cg.currentState.pool.add(name);
    Emitter.emit(cg.currentState.proto, OpCodes.EXPORT, [nameIdx, regIndex]);
}

export let stdlib = { "io": true, "array": true, "json": true, "object": true, "string": true, "system": true };
fn _getDirectoryPath(fullPath) {
    let filename = Io.getFileName(fullPath);
    if (filename.length >= fullPath.length) return "";
    return fullPath.slice(0, fullPath.length - filename.length);
}

export fn visitImportStatement(cg, node) {
    let sourcePath = node.path.value;
    let pathIdx;
    if (stdlib[sourcePath] != null || sourcePath.endsWith(".meowb")) {
        pathIdx = cg.currentState.pool.add(sourcePath);
    } else if (sourcePath.endsWith(".meow")) {
        let currentFileDir = _getDirectoryPath(cg.currentState.proto.sourceName);
        
        let importAbsolutePath = cg.compiler._resolvePath(sourcePath, currentFileDir);

        let cachePath = cg.cacheManager.compiledModules[importAbsolutePath];
        
        assert(cachePath, "Lỗi logic: Module " + importAbsolutePath + " lẽ ra phải được biên dịch rồi!");
        pathIdx = cg.currentState.pool.add(cachePath);
    } else {
        pathIdx = cg.currentState.pool.add(sourcePath);
    }

    if (node.namespaceImport != null) {
        let moduleName = node.namespaceImport.name;
        assert(node.namespaceImport.resolution && node.namespaceImport.resolution.type == "local", "Lỗi: Import namespace " + moduleName + " không được resolve là local");
        let localSlot = node.namespaceImport.resolution.symbol.index;
        
        let moduleReg = cg.currentState.allocator.ralloc();
        Emitter.emit(cg.currentState.proto, OpCodes.IMPORT_MODULE, [moduleReg, pathIdx]);

        cg.currentState.regToLocalIndex[str(moduleReg)] = localSlot;
        cg.currentState.localIndexToReg[localSlot] = moduleReg;
        cg.currentState.scope[cg.currentState.scope.length - 1][moduleName] = localSlot;

        if (cg.currentState.scope.length == 1 && cg.states.length == 1) {
            let nameIdx = cg.currentState.pool.add(moduleName);
            Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [nameIdx, moduleReg]);
        }

        cg.currentState.moduleVariables[moduleName] = true;
    } else if (node.namedImports.length > 0) {
        cg.currentState.allocator.withTemp(fn(tempModuleReg) {
            Emitter.emit(cg.currentState.proto, OpCodes.IMPORT_MODULE, [tempModuleReg, pathIdx]);
            
            for (importId in node.namedImports) {
                let importName = importId.name;
                let nameIdx = cg.currentState.pool.add(importName);
    
                assert(importId.resolution && importId.resolution.type == "local", "Lỗi: Import " + importName + " không được resolve là local");
                let localSlot = importId.resolution.symbol.index;

                let localReg = cg.currentState.allocator.ralloc();
                Emitter.emit(cg.currentState.proto, OpCodes.GET_EXPORT, [localReg, tempModuleReg, nameIdx]);

         
                cg.currentState.regToLocalIndex[str(localReg)] = localSlot;
                cg.currentState.localIndexToReg[localSlot] = localReg;
                cg.currentState.scope[cg.currentState.scope.length - 1][importName] = localSlot;
                if (cg.currentState.scope.length == 1 && cg.states.length == 1) {
                    Emitter.emit(cg.currentState.proto, OpCodes.SET_GLOBAL, [nameIdx, localReg]);
                }
                
                cg.currentState.importedVariables[importName] = true;
            }
        });

    } else {
        cg.currentState.allocator.withTemp(fn(tempModuleReg) {
            Emitter.emit(cg.currentState.proto, OpCodes.IMPORT_MODULE, [tempModuleReg, pathIdx]);
        });
    }
}

export fn visitDoWhileStatement(cg, node) {
    let startLabel = Emitter.createLabel("L_DOWHILE_START");
    let endLabel = Emitter.createLabel("L_DOWHILE_END");
    
    cg.currentState.loopLabels.push({ "continueTarget": startLabel, "breakTarget": endLabel });
    Emitter.defineLabel(cg.currentState.proto, startLabel);
    
    cg.visitStatement(node.body);

    cg.currentState.allocator.beginScope();
    let condReg = cg.visitExpression(node.condition);
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_TRUE, [condReg, {"label": startLabel}]);
    cg.currentState.allocator.endScope();

    Emitter.defineLabel(cg.currentState.proto, endLabel);
    cg.currentState.loopLabels.pop();
}

export fn visitSwitchStatement(cg, node) {
    cg.currentState.allocator.beginScope();
    cg.currentState.scope.push({});

    let switchValueReg = cg.visitExpression(node.value);
    let bodyLabels = [];
    let testChainLabels = [];
    let defaultBodyLabel = null;
    let endLabel = Emitter.createLabel("L_SWITCH_END");
    
    for (i in range(0, node.cases.length)) {
        bodyLabels.push(Emitter.createLabel("L_CASE_BODY"));
        testChainLabels.push(Emitter.createLabel("L_NEXT_TEST"));
    }
    cg.currentState.loopLabels.push({ "continueTarget": null, "breakTarget": endLabel });

    for (i in range(0, node.cases.length)) {
        let cas = node.cases[i];
        if (i > 0) {
            Emitter.defineLabel(cg.currentState.proto, testChainLabels[i-1]);
        }

        if (cas.value != null) {
            let caseValueReg = cg.visitExpression(cas.value);
            let eqReg = cg.currentState.allocator.take();
            Emitter.emit(cg.currentState.proto, OpCodes.EQ, [eqReg, switchValueReg, caseValueReg]);
            Emitter.emit(cg.currentState.proto, OpCodes.JUMP_IF_FALSE, [eqReg, {"label": testChainLabels[i]}]);
            Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": bodyLabels[i]}]);
        } else {
            defaultBodyLabel = bodyLabels[i];
            Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": testChainLabels[i]}]);
        }
    }
    
    Emitter.defineLabel(cg.currentState.proto, testChainLabels[testChainLabels.length - 1]);
    let finalJumpTarget = defaultBodyLabel ? defaultBodyLabel : endLabel;
    Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": finalJumpTarget}]);

    for (i in range(0, node.cases.length)) {
        Emitter.defineLabel(cg.currentState.proto, bodyLabels[i]);
        for (stmt in node.cases[i].statements) {
            cg.visitStatement(stmt);
        }
        
        let bodyStmts = node.cases[i].statements;
        if (bodyStmts.length == 0 || (bodyStmts[bodyStmts.length-1].type != "ReturnStatement" && bodyStmts[bodyStmts.length-1].type != "BreakStatement" && bodyStmts[bodyStmts.length-1].type != "ContinueStatement" && bodyStmts[bodyStmts.length-1].type != "ThrowStatement")) {
             Emitter.emit(cg.currentState.proto, OpCodes.JUMP, [{"label": endLabel}]);
        }
    }

    Emitter.defineLabel(cg.currentState.proto, endLabel);
    cg.currentState.loopLabels.pop();

    _endScopeAndCloseUpvalues(cg);
}


// ===== FILE: src/backend/visitor/visitor.meow =====
import * as Expression from "backend/visitor/expression.meow";
import * as Statement from "backend/visitor/statement.meow";
import * as Literal from "backend/visitor/literal.meow";

export let Visitor = {
    statements: {
        "LetStatement": Statement.visitLetStatement,
        "FunctionStatement": Statement.visitFunctionStatement,
        "ClassStatement": Statement.visitClassStatement,
        "ReturnStatement": Statement.visitReturnStatement,
        "IfStatement": Statement.visitIfStatement,
        "WhileStatement": Statement.visitWhileStatement,
        "BreakStatement": Statement.visitBreakStatement,
        "ContinueStatement": Statement.visitContinueStatement,
        "BlockStatement": Statement.visitBlockStatement, 
        "ForStatement": Statement.visitForStatement,
        "ForInStatement": Statement.visitForInStatement,
        "ThrowStatement": Statement.visitThrowStatement,
        "TryStatement": Statement.visitTryStatement,
        "ExpressionStatement": Statement.visitExpressionStatement,
        "ExportStatement": Statement.visitExportStatement,
        "ImportStatement": Statement.visitImportStatement,
        "DoWhileStatement": Statement.visitDoWhileStatement,
        "SwitchStatement": Statement.visitSwitchStatement,
    },
    expressions: {
        "IntegerLiteral": Literal.visitIntegerLiteral,
        "StringLiteral": Literal.visitStringLiteral,
        "RealLiteral": Literal.visitRealLiteral,
        "BooleanLiteral": Literal.visitBooleanLiteral,
        "NullLiteral": Literal.visitNullLiteral, 
        "ArrayLiteral": Literal.visitArrayLiteral,
        "ObjectLiteral": Literal.visitObjectLiteral,
        "FunctionLiteral": Literal.visitFunctionLiteral,
        "TemplateLiteral": Literal.visitTemplateLiteral,

        "Identifier": Expression.visitIdentifier,
        "BinaryExpression": Expression.visitBinaryExpression,
        "UnaryExpression": Expression.visitUnaryExpression,
        "CallExpression": Expression.visitCallExpression,
        "AssignmentExpression": Expression.visitAssignmentExpression,
        "PrefixUpdateExpression": Expression.visitPrefixUpdateExpression,
        "PostfixUpdateExpression": Expression.visitPostfixUpdateExpression,
        "IndexExpression": Expression.visitIndexExpression,
        "PropertyAccess": Expression.visitPropertyAccess,
        "NewExpression": Expression.visitNewExpression,
        "ThisExpression": Expression.visitThisExpression,
        "SuperExpression": Expression.visitSuperExpression,
        "TernaryExpression": Expression.visitTernaryExpression,
    }
};


